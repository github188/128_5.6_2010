if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Dept_Tree]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Dept_Tree]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Dept_Tree_Static]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Dept_Tree_Static]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Directional_Inset]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Directional_Inset]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Directional_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Directional_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_EmpInWellCount_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_EmpInWellCount_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_KJ128N_Insert_Update_His_AreaEmpOverTime]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_KJ128N_Insert_Update_His_AreaEmpOverTime]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_PagesShow]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_PagesShow]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_PagesShow_z]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_PagesShow_z]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_RT_Duty_Tree]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_RT_Duty_Tree]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_RT_EmpHelp_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_RT_EmpHelp_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_RT_Station_Head_count_houhui]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_RT_Station_Head_count_houhui]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_RT_Station_Head_houhui]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_RT_Station_Head_houhui]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_RT_TerOverEmp_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_RT_TerOverEmp_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_SaveTerSet]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_SaveTerSet]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Shine_Shen_EmployeeAttendanceQuery]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Shine_Shen_EmployeeAttendanceQuery]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Shine_StatMonthEmp_z]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Shine_StatMonthEmp_z]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Shine_hh_StatMonthEmp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Shine_hh_StatMonthEmp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Statement_ConfineArea]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Statement_ConfineArea]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Statement_EmpInWell]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Statement_EmpInWell]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Statement_KeyArea]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Statement_KeyArea]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_Statement_OverTime]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_Statement_OverTime]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_StationInfo_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_StationInfo_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_StationInfo_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_StationInfo_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_TerInfo_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_TerInfo_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_TerInfo_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_TerInfo_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_TerInfo_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_TerInfo_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_TerSet_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_TerSet_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_TerSet_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_TerSet_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_WalkSpeed_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_WalkSpeed_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_WalkSpeed_Delete_All]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_WalkSpeed_Delete_All]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_WalkSpeed_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_WalkSpeed_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_houhui_His_Statoin]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_houhui_His_Statoin]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_houhui_his_Dept_Tree]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_houhui_his_Dept_Tree]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_DeptInfo_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_DeptInfo_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_DeptInfo_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_DeptInfo_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_DeptInfo_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_DeptInfo_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_DutyInfo_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_DutyInfo_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_Emp_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_Emp_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_Emp_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_Emp_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[A_zjw_WorkType_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[A_zjw_WorkType_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[AddStationHead]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[AddStationHead]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Associate_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Associate_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Associate_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Associate_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Associate_Logic]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Associate_Logic]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Associate_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Associate_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Auto_Alter_His_View]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Auto_Alter_His_View]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Auto_Delete_His_View]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Auto_Delete_His_View]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_AreaDirection]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_AreaDirection]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_Directional]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_Directional]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_InOutMine]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_InOutMine]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_InOutReceiver]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_InOutReceiver]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_InOutStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_InOutStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHis_InOutStationHead]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHis_InOutStationHead]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHistory]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHistory]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[CreateHistoryDataTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[CreateHistoryDataTable]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Create_AutoAlter_BaseData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Create_AutoAlter_BaseData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DeleteRealTimePostInfoByID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[DeleteRealTimePostInfoByID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[DeleteWalkConfigInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[DeleteWalkConfigInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPagingRecord]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetPagingRecord]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPagingRecord2]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetPagingRecord2]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[GetPagingRecord_Shen]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[GetPagingRecord_Shen]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[InsertCodeSenderSet]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[InsertCodeSenderSet]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[InsertHistoryPostInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[InsertHistoryPostInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[InsertWalkConfigInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[InsertWalkConfigInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_AlarmSet_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_AlarmSet_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_CodeAlarmElectricity_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_CodeAlarmElectricity_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_CodeSender_Info_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_CodeSender_Info_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_CodeSender_Set_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_CodeSender_Set_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Delete_SpecialWorkTypeTerrial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Delete_SpecialWorkTypeTerrial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Delete_StationHead]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Delete_StationHead]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Detail_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Detail_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Detail_InsertAndUpdate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Detail_InsertAndUpdate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Info_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Info_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Info_Select_TreeView]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Info_Select_TreeView]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Lead_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Lead_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Dept_Lead_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Dept_Lead_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Display_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Display_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Detail_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Detail_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Detail_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Detail_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Detail_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Detail_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Health_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Health_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Home_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Home_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Home_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Home_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_InCompany_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_InCompany_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_InCompany_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_InCompany_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_InCompany_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_InCompany_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Info_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Info_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_NowCompany_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_NowCompany_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_NowCompany_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_NowCompany_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Photo_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Photo_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Photo_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Photo_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Search_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Search_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_Search_InsertAndUpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_Search_InsertAndUpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_SelectByDept]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_SelectByDept]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Emp_SysSet_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Emp_SysSet_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_EnumTable_FunID_List]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_EnumTable_FunID_List]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Equ_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Equ_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Equ_Del]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Equ_Del]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Equ_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Equ_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_GetEmployeeInfoDetail_ByEmpID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_GetEmployeeInfoDetail_ByEmpID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_GetHistoryInOutStationHead]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_GetHistoryInOutStationHead]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_GetHistoryInOutStationHead_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_GetHistoryInOutStationHead_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Graphics_AddConfigFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Graphics_AddConfigFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Graphics_AddDConfigFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Graphics_AddDConfigFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Graphics_UpdateConfigFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Graphics_UpdateConfigFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Graphics_UpdateDConfigFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Graphics_UpdateDConfigFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_HisInOutTotal_Proc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_HisInOutTotal_Proc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_HisStationBad_Degree_Proc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_HisStationBad_Degree_Proc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_HisStationHeadBad_Degree_Proc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_HisStationHeadBad_Degree_Proc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_HisStationHead_Query_Equ]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_HisStationHead_Query_Equ]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_His_InoutMine_Equ_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_His_InoutMine_Equ_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_His_InoutMine_Query_Equ]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_His_InoutMine_Query_Equ]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_HisInOutStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_HisInOutStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_HisStationHeadInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_HisStationHeadInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_His_Directional]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_His_Directional]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_His_InOutMine]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_His_InOutMine]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_His_OverTimeAlarm]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_His_OverTimeAlarm]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_HistoryBadStations]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_HistoryBadStations]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_InOutHisTerritorial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_InOutHisTerritorial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_RTInStationHeadInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_RTInStationHeadInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_RTTerritorialInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_RTTerritorialInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_SpecialWorkTypeTerrial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_SpecialWorkTypeTerrial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_UnCommanTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_UnCommanTable]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Updata_InMineStationInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Updata_InMineStationInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_His_AreaEmpOverTime]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_His_AreaEmpOverTime]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_InOutMine]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_InOutMine]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_InOutMine_Attendance]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_InOutMine_Attendance]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_RTInOutStaion]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_RTInOutStaion]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_RTInOutStaion_Zdc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_RTInOutStaion_Zdc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_RT_AreaDirectiona]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_RT_AreaDirectiona]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Insert_Update_RT_DirectionalAntenna]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Insert_Update_RT_DirectionalAntenna]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_QueryEmployeeInfo_ByWorkTypeID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_QueryEmployeeInfo_ByWorkTypeID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_HistorySpecialWorkTypeTerrial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_HistorySpecialWorkTypeTerrial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_RealTimeTerrialAlarm]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_RealTimeTerrialAlarm]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_SpecialWorkTypeTerrial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_SpecialWorkTypeTerrial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_TerrialInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_TerrialInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_TerrialType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_TerrialType]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_UncommanData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_UncommanData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Query_WorkType]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Query_WorkType]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_RTDirectionalAll_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_RTDirectionalAll_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_RTDirectional_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_RTDirectional_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_SaveLog]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_SaveLog]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Station_Info_Select_TreeView]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Station_Info_Select_TreeView]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Station_OutStationType_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Station_OutStationType_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Update_CodeSenderLow]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Update_CodeSenderLow]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128N_Update_SpecialWorkTypeTerrial]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128N_Update_SpecialWorkTypeTerrial]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128_EmpIO]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128_EmpIO]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[KJ128_WorkTypeIO]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[KJ128_WorkTypeIO]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[MenuInsert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[MenuInsert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[OverSpeed_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[OverSpeed_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[OverSpeed_OutWell]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[OverSpeed_OutWell]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTDeptSmallInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTDeptSmallInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTDisplayStationHeadInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTDisplayStationHeadInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTStaHeadCodeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTStaHeadCodeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTStationCodeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTStationCodeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTStationHeadInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTStationHeadInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTStationHeadInfo_Zdc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTStationHeadInfo_Zdc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetRTStationInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetRTStationInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_GetStation_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_GetStation_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_HisInWellCount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_HisInWellCount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_RTAlarmInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_RTAlarmInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_loginLogs]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_loginLogs]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_userLogin]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_userLogin]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[PROC_userLogin_ForWeb]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[PROC_userLogin_ForWeb]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Proc_DbackPic_AddFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Proc_DbackPic_AddFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Proc_His_Area]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Proc_His_Area]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Proc_His_DirectionalAntenna]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Proc_His_DirectionalAntenna]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Proc_His_InOutReceiver]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Proc_His_InOutReceiver]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Proc_RT_DirectionalAntenna]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Proc_RT_DirectionalAntenna]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SSZY_QueryByTime_DJC]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SSZY_QueryByTime_DJC]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectHistoryPostInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectHistoryPostInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectHistoryWalkInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectHistoryWalkInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectInOutConfineAreaTimeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectInOutConfineAreaTimeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectInOutKeyAreaTimeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectInOutKeyAreaTimeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectRealTimeAlarmPostInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectRealTimeAlarmPostInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectRealTimeClimeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectRealTimeClimeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectRealTimeWalkAlarmInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectRealTimeWalkAlarmInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectRealTimeWalkInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectRealTimeWalkInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[SelectWalkConfigInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[SelectWalkConfigInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_AddGraphicsBackGroudFile]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_AddGraphicsBackGroudFile]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admin_GetUGPLevelID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admin_GetUGPLevelID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admin_GetUGPLevelID_ByAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admin_GetUGPLevelID_ByAccount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admin_lastLoard]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admin_lastLoard]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admins_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admins_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admins_DeleteByPrimaryKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admins_DeleteByPrimaryKey]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admins_GetID_ByAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admins_GetID_ByAccount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admins_GetModelByPrimaryKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admins_GetModelByPrimaryKey]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Admins_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Admins_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_AlarmSetting_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_AlarmSetting_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_AlarmSetting_DeleteByPrimaryKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_AlarmSetting_DeleteByPrimaryKey]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_AlarmSetting_UpdateA]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_AlarmSetting_UpdateA]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Customer_GetList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Customer_GetList]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Customer_ID_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Customer_ID_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Customer_ID_GetEntity]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Customer_ID_GetEntity]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Customer_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Customer_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Departments_GetClassInfoByDeptID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Departments_GetClassInfoByDeptID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_GetDropDownListData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_GetDropDownListData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_GetList_StationsInfoAndEnumInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_GetList_StationsInfoAndEnumInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_GetRecordByPage]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_GetRecordByPage]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryAttendance_GetEmpInfoByTimerIntervalID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryAttendance_GetEmpInfoByTimerIntervalID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryHolidays_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryHolidays_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryHolidays_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryHolidays_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryHolidays_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryHolidays_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryHolidays_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryHolidays_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryInOutStation_QueryView]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryInOutStation_QueryView]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HistoryInOutStation_QueryView_ZZHA]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HistoryInOutStation_QueryView_ZZHA]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HolidayType_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HolidayType_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HolidayType_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HolidayType_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HolidayType_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HolidayType_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_HolidayType_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_HolidayType_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_InfoClass_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_InfoClass_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_InfoClass_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_InfoClass_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_InfoClass_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_InfoClass_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_InfoClass_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_InfoClass_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_Edit]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_Edit]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_GetModelByPrimaryKey]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_GetModelByPrimaryKey]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_GetParentMenu]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_GetParentMenu]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_ID_DeleteA]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_ID_DeleteA]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Menus_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Menus_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Points_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Points_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Points_DeleteByPointId]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Points_DeleteByPointId]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Points_GetList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Points_GetList]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Points_GetListByPointId]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Points_GetListByPointId]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Points_GetListDistinct]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Points_GetListDistinct]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_RealTimeInStation_GetListShowAll]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_RealTimeInStation_GetListShowAll]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_RealTimeInStation_GetListShowAllByUserId]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_RealTimeInStation_GetListShowAllByUserId]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_AddHistoryOutStation_DeleteRealTimeInStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_AddHistoryOutStation_DeleteRealTimeInStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_AttendanceInitialData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_AttendanceInitialData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_AttendanceParticulars]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_AttendanceParticulars]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_AttendanceStatisticByDuty]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_AttendanceStatisticByDuty]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_AttendanceStatisticSalary]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_AttendanceStatisticSalary]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceDayByDayStatistic]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceDayByDayStatistic]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceDelete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceDelete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendancePersonelStatistic]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendancePersonelStatistic]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceQuery]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceQuery]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRateStatistic]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRateStatistic]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeDelete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeDelete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeDeleteAndInsert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeDeleteAndInsert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorDelete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorDelete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorDeleteAndInsert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorDeleteAndInsert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorQuery]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeErrorQuery]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_EmployeeAttendanceRealTimeQuery]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeQuery]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_GetEmployeeInfoByDeptID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_GetEmployeeInfoByDeptID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_HistoryAttendanceAdd]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_HistoryAttendanceAdd]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_HistoryAttendanceUpdate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_HistoryAttendanceUpdate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_InsertHisTerrialOverEmp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_InsertHisTerrialOverEmp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_InsertTerritorial_Config]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_InsertTerritorial_Config]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_RT_TerrialOverEmp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_RT_TerrialOverEmp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_UnitPrice_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_UnitPrice_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_UnitPrice_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_UnitPrice_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_UnitPrice_Modify]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_UnitPrice_Modify]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_UnitPrice_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_UnitPrice_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_Shen_Update_CodeSender_Common]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_Shen_Update_CodeSender_Common]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_StationsInfo_GetListAndEnumInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_StationsInfo_GetListAndEnumInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_StationsInfo_GetListStationInfoByAddress]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_StationsInfo_GetListStationInfoByAddress]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_StationsInfo_UpdateHeadAntenna]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_StationsInfo_UpdateHeadAntenna]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_StationsInfo_UpdateXY]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_StationsInfo_UpdateXY]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TastTime_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TastTime_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TastTime_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TastTime_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TastTime_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TastTime_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TastTime_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TastTime_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TimerInterval_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TimerInterval_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TimerInterval_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TimerInterval_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TimerInterval_Query]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TimerInterval_Query]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_TimerInterval_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_TimerInterval_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroupMenu_Delete_DeleteMenu]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroupMenu_Delete_DeleteMenu]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroupMenu_GetSingeUserGroupMenu]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroupMenu_GetSingeUserGroupMenu]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroupMenu_Insert_InsertMenu]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroupMenu_Insert_InsertMenu]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroupPower_GetList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroupPower_GetList]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroup_GetUGPLevelID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroup_GetUGPLevelID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_Add]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_Add]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_Add1]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_Add1]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_GetList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_GetList]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_ID_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_ID_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_ID_GetEntity]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_ID_GetEntity]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_UserGroups_Update_ForWeb]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_UserGroups_Update_ForWeb]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_djc_HisInMineEmpTotal]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_djc_HisInMineEmpTotal]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_djc_HisSpecialEmpAlarm]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_djc_HisSpecialEmpAlarm]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shine_djc_StatMonthEmp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Shine_djc_StatMonthEmp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[StatCount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[StatCount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[UpdateRealTimePostMeasure]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[UpdateRealTimePostMeasure]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[UpdateWalkConfigInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[UpdateWalkConfigInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[UserGroups_GetList]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[UserGroups_GetList]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[W_GetUserGroupMenu]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[W_GetUserGroupMenu]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Wwy_Station_InOutStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Wwy_Station_InOutStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Wwy_Station_InStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Wwy_Station_InStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Wwy_Station_InStation_BackUP]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Wwy_Station_InStation_BackUP]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Wwy_Station_Load]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Wwy_Station_Load]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Wwy_Station_StateChange]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Wwy_Station_StateChange]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Yl_Station_ExecProc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Yl_Station_ExecProc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Zdc_KJ128N_BaseTest]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Zdc_KJ128N_BaseTest]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Zdc_KJ128N_TestData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[Zdc_KJ128N_TestData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[cjg_select_tcpIpConfig]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[cjg_select_tcpIpConfig]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[deleteMenus1]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[deleteMenus1]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[deleteRealWriteToHisAlert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[deleteRealWriteToHisAlert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_His_PathAlert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_His_PathAlert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_Path_Detail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_Path_Detail]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_Path_Emp_Relation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_Path_Emp_Relation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_Path_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_Path_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_RealTimeAlarmPathInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_RealTimeAlarmPathInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_RealTimePathAlert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_RealTimePathAlert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_RealTimePathCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_RealTimePathCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_passStationHeadByCardNO]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_passStationHeadByCardNO]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[delete_pathStringByCardNO]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[delete_pathStringByCardNO]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[getAlluser]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[getAlluser]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[getMenuAll]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[getMenuAll]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[getUserGroupsByAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[getUserGroupsByAccount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[getUserGroupsPowerByAccount]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[getUserGroupsPowerByAccount]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[inserUser]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[inserUser]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insertUserGroupMenu1]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insertUserGroupMenu1]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_HisPathCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_HisPathCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_His_PathAlert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_His_PathAlert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_Path_Detail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_Path_Detail]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_Path_Emp_Relation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_Path_Emp_Relation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_Path_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_Path_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_RealTimeAlarmPathInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_RealTimeAlarmPathInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_RealTimePathCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_RealTimePathCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_passStationHead]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_passStationHead]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[insert_pathStringByEmpNo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[insert_pathStringByEmpNo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[leadMonthStatement]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[leadMonthStatement]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[pathDetailInfo_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[pathDetailInfo_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[pathDetail_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[pathDetail_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[pathDetail_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[pathDetail_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_GetRTTotalInfo_Zdc]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_GetRTTotalInfo_Zdc]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_Inser_into_RealTimeCodeSender]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_Inser_into_RealTimeCodeSender]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisAreaANDDeleteRealArea]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisAreaANDDeleteRealArea]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisEmployeeAttendanceAndDelete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisEmployeeAttendanceAndDelete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisMineANDDeleteRealMine]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisMineANDDeleteRealMine]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisOverTimeEmployee]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisOverTimeEmployee]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisStationByStationError]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisStationByStationError]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisStationByStationHeadError]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisStationByStationHeadError]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisStationHis]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisStationHis]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertHisStationSame]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertHisStationSame]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRTEmployeeAttendance]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRTEmployeeAttendance]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRTOverSpeed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRTOverSpeed]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRealAreaInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRealAreaInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRealMine]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRealMine]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRealStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRealStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertRealStationTemp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertRealStationTemp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_InsertUpdateRealTimeOverEmp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_InsertUpdateRealTimeOverEmp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_Insert_Update_InMineStationInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_Insert_Update_InMineStationInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_IpStationConfig_add_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_IpStationConfig_add_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_IpStationConfig_delete_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_IpStationConfig_delete_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_IpStationConfig_update_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_IpStationConfig_update_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_Station_tcpip_update_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_Station_tcpip_update_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_UpdateHisOverSpeed]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_UpdateHisOverSpeed]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_UpdateRealStation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_UpdateRealStation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_UpdateRealStationByStationError]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_UpdateRealStationByStationError]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_UpdateRealStationByStationHeadError]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_UpdateRealStationByStationHeadError]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_insert_HistoryAttendance_cjg]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_insert_HistoryAttendance_cjg]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_insert_RealTimeAttendance]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_insert_RealTimeAttendance]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_insert_RealTimeAttendance_cjg]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_insert_RealTimeAttendance_cjg]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_insert_emp_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_insert_emp_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_insert_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_insert_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_select_emp_by_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_select_emp_by_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[proc_select_his_station_head_time_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[proc_select_his_station_head_time_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[process_EmpHelpInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[process_EmpHelpInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[process_InCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[process_InCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[process_OutCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[process_OutCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[process_RealTimeAlarmPathInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[process_RealTimeAlarmPathInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[process_WalkLogic]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[process_WalkLogic]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[processupinfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[processupinfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectClimeInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectClimeInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectConfineAreaInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectConfineAreaInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectEmpStateByTime]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectEmpStateByTime]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectKeyAreaInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectKeyAreaInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectRealTimePostInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectRealTimePostInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectStationConfigInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectStationConfigInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectUserGrupByAccountID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectUserGrupByAccountID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectUserGrupByAdminID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectUserGrupByAdminID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectUserGrupByUserGroupID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectUserGrupByUserGroupID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[selectUserGrupBymenuID]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[selectUserGrupBymenuID]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_Dept_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_Dept_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_EmpPassInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_EmpPassInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_Emp_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_Emp_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_HisPathCheckByInterval]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_HisPathCheckByInterval]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_HisPathCheckByPath]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_HisPathCheckByPath]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_HisPath_by_txjl]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_HisPath_by_txjl]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_His_PathAlert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_His_PathAlert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_Path_Detail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_Path_Detail]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_Path_Emp_Relation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_Path_Emp_Relation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_Path_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_Path_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_RealTimeAlarmPathInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_RealTimeAlarmPathInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_RealTimePathCheckByInterval]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_RealTimePathCheckByInterval]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_RealTimePathCheckByPath]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_RealTimePathCheckByPath]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_RealTimePath_by_txj]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_RealTimePath_by_txj]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_StationHeadInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_StationHeadInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_StationInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_StationInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[select_TimeInterval]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[select_TimeInterval]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[updateMenu1]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[updateMenu1]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[updateUser]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[updateUser]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[update_Path_Detail]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[update_Path_Detail]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[update_Path_Emp_Relation]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[update_Path_Emp_Relation]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[update_Path_Info]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[update_Path_Info]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[update_RealTimeAlarmPathInfo]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[update_RealTimeAlarmPathInfo]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[update_RealTimePathCheck]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[update_RealTimePathCheck]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[workExceptionStatement]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[workExceptionStatement]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zdc_Auto_buzou]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zdc_Auto_buzou]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zdc_KJ128N_Test_11Month4Day]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zdc_KJ128N_Test_11Month4Day]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_DeleteHisData]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_DeleteHisData]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Delete_AllTable]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Delete_AllTable]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Delete_RT_EmpHelp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Delete_RT_EmpHelp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_DeptInfo_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_DeptInfo_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_EmpPost_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_EmpPost_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_EmpPost_Updata]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_EmpPost_Updata]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Emp_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Emp_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Emp_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Emp_Update]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_GetPagingRecord_HisInWellCounts]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_GetPagingRecord_HisInWellCounts]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_HisInOutMine_Select]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_HisInOutMine_Select]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_OverEmpInWell]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_OverEmpInWell]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_OverEmpOutWell]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_OverEmpOutWell]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_RTPost_Delete]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_RTPost_Delete]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_RTPost_Inset]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_RTPost_Inset]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_RTPost_UpDate]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_RTPost_UpDate]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_SavePrint]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_SavePrint]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Select_RT_EmpHelp]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Select_RT_EmpHelp]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_Select_Station]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_Select_Station]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_WorkType_Insert]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_WorkType_Insert]
GO

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[zjw_WorkType_Update]') and OBJECTPROPERTY(id, N'IsProcedure') = 1)
drop procedure [dbo].[zjw_WorkType_Update]
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE proc [dbo].[A_Dept_Tree]
@a int --0为人 其他为设备
as

create table #c (ID int,Name varchar(20),ParentID int,IsChild bit,IsUserNum bit,Num int)
declare @count int
if(@a=0)
begin
insert into #c(ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num) values(0 ,'所有' ,-1 ,0,1 ,0 )
insert #c select t.DeptID ID,t.DeptName name,t.ParentDeptID ParentID, 1 IsChild,1 IsUserNum, (select count(*) from RT_InStationHeadInfo As Ri
					Left Join Emp_Info As Ei On Ei.EmpID = Ri.UserID 
					Left Join Emp_NowCompany As En On En.EmpID = Ri.UserID and Ri.CsTypeID=0
					Left Join Dept_Info As Di On Di.DeptID = En.DeptID where Di.DeptID=t.DeptID) Num from dbo.Dept_Info as t
end
else
begin
insert into #c(ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num) values(0 ,'所有' ,-1 ,0,1 ,0 )
insert #c select t.DeptID ID,t.DeptName name,t.ParentDeptID ParentID, 1 IsChild,1 IsUserNum, (select count(*) from RT_InStationHeadInfo As Ri 
								Left Join Equ_BaseInfo as Eb on Ri.UserID=Eb.EquID and Ri.CsTypeID=1 
								Left Join Dept_Info as Di on Eb.DeptID=Di.DeptID  where Di.DeptID=t.DeptID) Num from dbo.Dept_Info as t
end
select * from #c
drop table #c





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE proc [dbo].[A_Dept_Tree_Static]
as
create table #c (ID int,Name varchar(20),ParentID int,IsChild bit,IsUserNum bit,Num int)
insert into #c(ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num) values(0 ,'所有' ,-1 ,0,0 ,0 )
insert #c select DeptID ID,DeptName name,ParentDeptID ParentID, 1 IsChild,0 IsUserNum, 0 Num from dbo.Dept_Info
select * from #c
drop table #c


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE  proc A_Directional_Inset
(
	@DetectionInfo nvarchar(20),
	@Directional nvarchar(50),
	@BeginStationAddress int,
	@BeginStationHeadAddress int,
	@EndStationAddress int,
	@EndStationHeadAddress int,
	@CodeSenderDirlID int
)
as
begin
if(not exists(Select 1 From CodeSender_DirectionalAntenna Where DetectionInfo=@DetectionInfo))
begin
	insert into CodeSender_DirectionalAntenna(CodeSenderDirlID,DetectionInfo,Directional,BeginStationAddress,BeginStationHeadAddress,EndStationAddress,EndStationHeadAddress)
	values(@CodeSenderDirlID,@DetectionInfo,@Directional,@BeginStationAddress,@BeginStationHeadAddress,@EndStationAddress,@EndStationHeadAddress )
end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc [dbo].[A_Directional_UpDate]
(
	@DetectionInfo nvarchar(20),
	@Directional nvarchar(50)
)
as
begin
if(exists(Select 1 From CodeSender_DirectionalAntenna Where DetectionInfo=@DetectionInfo))
begin
	update CodeSender_DirectionalAntenna
	Set Directional=@Directional
	Where DetectionInfo=@DetectionInfo
end

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




create   proc A_EmpInWellCount_Select
(
    @PageSize     int = 40,           -- 页尺寸
    @PageIndex    int = 1,            -- 页码
    @strWhere     varchar(1000) = '',  -- 查询条件 (注意: 不要加 where,不要包含时间)
    @strDateTime varchar(600)	      --时间查询条件
)
AS
begin
declare @strSQL   varchar(6000)       -- 主语句
Declare @strSQLAllCount varchar(3000)	--查询记录条数的SQL语句

Declare @strSQLTableTemp varchar(900)	--临时视图的SQL语句
Declare @strSQLTable varchar(3000)	--所要查询的表的SQL语句


set @strSQLTableTemp='Select * From His_InOutMine Where ' +@strDateTime

set @strSQLTable='Select Distinct  Hi.CodeSenderAddress As 标识卡号,  
Ei.EmpName As 姓名,  
Di.DeptName As 部门,  
Wi.WtName As 工种,  
(  Select Count(*) From ('+ @strSQLTableTemp +') As Hi1 Where Hi1.UserID = Ei.EmpID And Hi1.CsTypeID = 0  ) As 下井次数,  
dbo.FunConvertTime((  Select Sum(ContinueTime) From ('+ @strSQLTableTemp +') As Hi2 Where Hi2.UserID = Ei.EmpID And Hi2.CsTypeID =0  )) As 下井时长  
From  Emp_Info As Ei  
 Left Join Emp_NowCompany As En On En.EmpID = Ei.EmpID 
 Left Join Dept_Info As Di On Di.DeptID = En.DeptID  
Left Join Emp_WorkType As Ew On Ew.EmpID = Ei.EmpID  and Ew.IsEnable=1
Left Join WorkType_Info As Wi On Wi.WorkTypeID = Ew.WorkTypeID  
Left Join Duty_Info As Dio On Dio.DutyID = En.DutyID  
Left Join ('+ @strSQLTableTemp +') As Hi On Hi.UserID = Ei.EmpID  
Where Hi.CsTypeID = 0 And ' +@strWhere

	if(@PageIndex = 1)			--第一页
	begin
		Set @strSQL=' Select top '+ str(@PageSize) + ' * from ('+@strSQLTable+') as AB  order by 标识卡号 asc'
	end
	else if(@PageIndex>1)			--非第一页
	begin
		Set @strSQL=' Select top '+str(@PageSize) +' * From ('+@strSQLTable+') as AB Where '
			+' 标识卡号>(Select Max(标识卡号) From ( Select top '+str((@PageIndex-1)*@PageSize) +' 标识卡号'
			+' from ('+@strSQLTable+') as AB  order by 标识卡号 asc) as tblTmp) Order by 标识卡号 asc'
	end
	
--print(@strSQLTableTemp)
--print'-------------------------'
--print(@strSQLTable)
--print'-------------------------'
print(@strSQL)
--print'-------------------------'
	if(@strSQL<>'')
	begin
		exec(@strSQL)
		set @strSQLAllCount=' Select Count(1) as Total From ('+@strSQLTable+') as AB '
		exec (@strSQLAllCount)
	end
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--Select TerritorialID From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress --上个区域
--Select Ts.TerritorialID From Territorial_Set as Ts Left Join Station_Head_Info as Shi on Ts.StationHeadID=Shi.StationHeadID 
--				 Where Shi.StationAddress=@StationAddress and Shi.StationHeadAddress=@StationHeadAddress --当前区域
				 
--				 Select TerWorkTime From Territorial_Config Where TerritorialID=@TerritorialID_Old--上个区域的工作时间
				 
--				 Select InTerritorialTime From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress--进入上个区域的时间
				 
				 
				 
CREATE proc [dbo].[A_KJ128N_Insert_Update_His_AreaEmpOverTime]
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
as
declare crAreaEmpOverTime cursor for (select F1 as CodeSenderAddress from dbo.f_splitstr(@Cards,','))
open crAreaEmpOverTime
declare @CodeSenderAddress int	--发码器编号

fetch next from crAreaEmpOverTime into @CodeSenderAddress
while @@fetch_status=0
begin
	if not exists(Select TerritorialID From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress)
	begin
		--第一次进入区域
		print '第一次进入区域'
	end
	else
	begin
		declare TerritorialID_Old cursor for (Select TerritorialID From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress)
		open TerritorialID_Old
		declare @TerWorkTime	int	--额定工作时间
		declare @InTerritorialTime_Old datetime		--该员工在上一个区域的进入时间
		declare @TerritorialID_Old int	--上一次所在区域ID
		fetch next from TerritorialID_Old into @TerritorialID_Old
		while @@fetch_status=0
		begin
			set @TerWorkTime=(Select TerWorkTime From Territorial_Config Where TerritorialID=@TerritorialID_Old)
			set @InTerritorialTime_Old=(Select InTerritorialTime From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress and TerritorialID=@TerritorialID_Old )
			if not exists(Select Ts.TerritorialID From Territorial_Set as Ts Left Join Station_Head_Info as Shi on Ts.StationHeadID=Shi.StationHeadID 
				 Where Shi.StationAddress=@StationAddress and Shi.StationHeadAddress=@StationHeadAddress)
			begin
				--出区域
				print '出区域'
				if(DATEDIFF ( ss ,@InTerritorialTime_Old ,@DetectTime ) > @TerWorkTime)
						begin
							insert into His_TerritorialEmpOverTime(TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,TerWorkTime,OutTerritorialTime,
								CodeSenderAddress,EmpID,EmpName,DeptID,DeptName,WtName)
							select Rt.TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,Tc.TerWorkTime,@DetectTime,CodeSenderAddress,Ei.EmpID,Ei.EmpName,Enc.DeptID,Dei.DeptName,Wt.WtName 
							From RT_TerritorialInfo as Rt left join Territorial_Config as Tc on Rt.TerritorialID=Tc.TerritorialID
								left join Emp_Info as Ei on Rt.UserID=Ei.EmpID and Rt.CsTypeID=0
								left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
								left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
								left join Emp_WorkType as Ewt on Ei.EmpID=Ewt.EmpID and Ewt.IsEnable=1
								left join WorkType_Info as Wt on Ewt.WorkTypeID=Wt.WorkTypeID
							where CodeSenderAddress=@CodeSenderAddress
						end
				
			end
			else
			begin
				if(@TerritorialID_Old in(Select Ts.TerritorialID From Territorial_Set as Ts Left Join Station_Head_Info as Shi on Ts.StationHeadID=Shi.StationHeadID 
				 Where Shi.StationAddress=@StationAddress and Shi.StationHeadAddress=@StationHeadAddress))
				 begin
					--进入其他探头没有出区域
					print'进入探头没有出区域'
				 end
				 else
				 begin
					--进入其他探头出了区域
					print'进入其他探头计入其他区域出了区域'
					if(DATEDIFF ( ss ,@InTerritorialTime_Old ,@DetectTime ) > @TerWorkTime)
						begin
							insert into His_TerritorialEmpOverTime(TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,TerWorkTime,OutTerritorialTime,
								CodeSenderAddress,EmpID,EmpName,DeptID,DeptName,WtName)
							select Rt.TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,Tc.TerWorkTime,@DetectTime,CodeSenderAddress,Ei.EmpID,Ei.EmpName,Enc.DeptID,Dei.DeptName,Wt.WtName 
							From RT_TerritorialInfo as Rt left join Territorial_Config as Tc on Rt.TerritorialID=Tc.TerritorialID
								left join Emp_Info as Ei on Rt.UserID=Ei.EmpID and Rt.CsTypeID=0
								left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
								left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
								left join Emp_WorkType as Ewt on Ei.EmpID=Ewt.EmpID and Ewt.IsEnable=1
								left join WorkType_Info as Wt on Ewt.WorkTypeID=Wt.WorkTypeID
							where CodeSenderAddress=@CodeSenderAddress
						end
				 end
				 
				
			end
			
			fetch next from TerritorialID_Old into @TerritorialID_Old	
		end
		close TerritorialID_Old
		deallocate TerritorialID_Old
	end
	fetch next from crAreaEmpOverTime into @CodeSenderAddress
end

close crAreaEmpOverTime
deallocate crAreaEmpOverTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE proc A_PagesShow
@tablename varchar(1000),
@pagenum int,
@pageindex int,
@columnname varchar(20),
@pagecount int output,
@rowcount int output
as
begin
  declare @sqlstr varchar(3000)
  declare @count int
  declare @sql nvarchar(1000)
  set @sql='select @a=count(*) from '+@tablename+' a';
  exec sp_executesql @sql,N'@a int output',@count output
  set @rowcount=@count
  if(@count%@pagenum=0)
      set @pagecount=@count/@pagenum
  else
      set @pagecount=@count/@pagenum+1
  --print convert(varchar(20),@pagecount)
  set @sqlstr='Select TOP '+convert(char(20),@pagenum)+' * FROM '+@tablename+' a Where not exists (select * from (select top '+convert(char(20),(@pageindex-1)*@pagenum)+' * from '+@tablename+' c) b where b.'+@columnname+'=a.'+@columnname+')'
  exec(@sqlstr)
  print @sqlstr
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create   proc A_PagesShow_z
@tablename varchar(1000),
@pagenum int,
@pageindex int,
@columnname varchar(20),
@pagecount int output,
@rowcount int output
as
begin
  declare @sqlstr varchar(3000)
  declare @count int
  declare @sql nvarchar(1000)
  set @sql='select @a=count(*) from '+@tablename+' a';
  exec sp_executesql @sql,N'@a int output',@count output
  set @rowcount=@count
  set @pagecount=@count/@pagenum+1
  --print convert(varchar(20),@pagecount)
  if(@pageindex=1)
  begin
	Set @sqlstr='Select Top '+convert(char(20),@pagenum)+' * From '+@tablename+' a Order By 标识卡号'
  end
  else
  begin
  	set @sqlstr='Select TOP '+convert(char(20),@pagenum)+' * FROM '+@tablename+' a Where a.标识卡号> (select max(标识卡号) from (select top '+convert(char(20),(@pageindex-1)*@pagenum)+' * from '+@tablename+' c order by 标识卡号) b )'
  end
  exec(@sqlstr)
  print @sqlstr
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE proc [dbo].[A_RT_Duty_Tree]
as

create table #c (ID int,Name varchar(20),ParentID int,IsChild bit,IsUserNum bit,Num int)
insert #c select t.DutyID ID,t.DutyName Name,0 ParentID,1 IsChild,1 IsUserNum,(select count(*)from dbo.view_RT_InOutMineEmpNameList where 职务ID=t.DutyID) Num from dbo.Duty_Info as t
declare @ALLcount int
set @ALLcount=(select count(*)from dbo.view_RT_InOutMineEmpNameList where 职务ID is null)
insert into #c (ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num )values(0,'所有',-1,0,1,@ALLcount)
select * from #c
drop table #c




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create  proc A_RT_EmpHelp_Delete
(
	@CodeSenderAddress int,
	@EndTime datetime,
	@Measure nvarchar(200)
)
as
begin

--将实施救援表中的数据更新到历史求救表中，同时删除实时求救表中的记录
if(exists(Select 1 From RT_EmpHelp Where CodeSenderAddress = @CodeSenderAddress))
begin
	insert into dbo.His_EmpHelp (CodeSenderAddress,StationAddress,StationPlace,StationHeadAddress,StationHeadPlace,EmpName,DeptName,
				DutyName,WtName,BeginDateTime,EndDateTime,Measure)
	select 标识卡号,传输分站编号,传输分站位置,读卡分站编号,读卡分站位置,姓名,部门,
		职务,工种,求救开始时间,@EndTime,@Measure
	From A_Alarm_RTEmpHelp
	Where 标识卡号=@CodeSenderAddress
	
	delete RT_EmpHelp where CodeSenderAddress=@CodeSenderAddress
end

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc [dbo].[A_RT_Station_Head_count_houhui]
@str nvarchar(1000),
@pd int
as
declare @sql nvarchar(4000)
if(@pd=1)--人员监测
begin
set @sql=
'select count(*)
from RT_InStationHeadInfo As Ri
Left Join Emp_Info As Ei On Ei.EmpID = Ri.UserID 
Left Join Emp_NowCompany As En On En.EmpID = Ri.UserID and Ri.CsTypeID=0
Left Join Dept_Info As Di On Di.DeptID = En.DeptID 
Left Join Emp_WorkType As Ew On Ew.EmpID = Ri.UserID and Ew.IsEnable=1
Left Join WorkType_Info As Wi On Wi.WorkTypeID = Ew.WorkTypeID 
Left Join Station_Head_Info As Si On Si.StationHeadID = Ri.StationHeadID where '+@str
end
else--设备监测
begin
set @sql=
'select count(*) from RT_InStationHeadInfo As Ri 
Left Join Equ_BaseInfo as Eb on Ri.UserID=Eb.EquID and CsTypeID=1 
Left Join Dept_Info as Di on Eb.DeptID=Di.DeptID 
Left Join Station_Head_Info As Si On Si.StationHeadID = Ri.StationHeadID  where '+@str
end
print @sql
exec(@sql)




set ANSI_NULLS ON
set QUOTED_IDENTIFIER ON

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc [dbo].[A_RT_Station_Head_houhui]
@str nvarchar(1000),
@pd int
as
declare @sql nvarchar(4000)
if(@pd=1)--人员监测
begin
set @sql=
'select Ri.CodeSenderAddress 标识卡号,Ei.EmpName 姓名,Di.DeptName 部门,Wi.WtName 工种,Si.StationAddress 传输分站, Si.StationHeadAddress 读卡分站,Si.StationHeadPlace 读卡分站的位置,Ri.InStationHeadTime 进入时间, datediff(ss,Ri.InStationHeadTime,getdate()) 持续时长 
from RT_InStationHeadInfo As Ri
Left Join Emp_Info As Ei On Ei.EmpID = Ri.UserID 
Left Join Emp_NowCompany As En On En.EmpID = Ri.UserID 
Left Join Dept_Info As Di On Di.DeptID = En.DeptID 
Left Join Emp_WorkType As Ew On Ew.EmpID = Ri.UserID and Ew.IsEnable=1
Left Join WorkType_Info As Wi On Wi.WorkTypeID = Ew.WorkTypeID 
Left Join Station_Head_Info As Si On Si.StationHeadID = Ri.StationHeadID where Ri.CsTypeID=0 and '+@str
end
else--设备监测
begin
set @sql=
'select Ri.CodeSenderAddress 标识卡号,Eb.EquName 设备名称,Eb.EquNO 设备编号,Di.DeptName 部门,Si.StationAddress 传输分站, Si.StationHeadAddress 读卡分站,Si.StationHeadPlace 读卡分站的位置, Ri.InStationHeadTime 进入时间, datediff(ss,Ri.InStationHeadTime,getdate()) 持续时长 
from RT_InStationHeadInfo As Ri 
Left Join Equ_BaseInfo as Eb on Ri.UserID=Eb.EquID  
Left Join Dept_Info as Di on Eb.DeptID=Di.DeptID 
Left Join Station_Head_Info As Si On Si.StationHeadID = Ri.StationHeadID  where Ri.CsTypeID=1 and '+@str
end
print @sql
exec(@sql)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc A_RT_TerOverEmp_Insert
as
begin

insert into dbo.RT_TerOverEmp(TerritorialID,TerritorialName,TerritorialTypeName,TerEmpCount,NowTerEmpCount,NowOverCount,MaxOverCount,OverEmpBeginTime)
Select Tc.TerritorialID,Ti.TerritorialName,Tt.TypeName,Tc.TerEmpCount,(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Tc.TerritorialID and CsTypeID=0) as NowTerEmpCount,
	(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Tc.TerritorialID and CsTypeID=0)-Tc.TerEmpCount as NowOverCount,
	(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Tc.TerritorialID and CsTypeID=0)-Tc.TerEmpCount as MaxOverCount,getdate() as OverEmpBeginTime
From dbo.Territorial_Config as Tc left join Territorial_Info as Ti on Tc.TerritorialID=Ti.TerritorialID
	left join dbo.Territorial_Type as Tt on Ti.TerritorialTypeID=Tt.TerritorialTypeID
Where Tc.TerEmpCount<>-1 and (Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Tc.TerritorialID and CsTypeID=0)>Tc.TerEmpCount 
	and Tc.TerritorialID not in ( Select TerritorialID From dbo.RT_TerOverEmp)

/*
UpDate dbo.RT_TerOverEmp
Set TerEmpCount=(Select TerEmpCount From dbo.Territorial_Config Where TerritorialID=Rtt.TerritorialID) 
From dbo.RT_TerOverEmp as Rtt  
	-- Left Join dbo.Territorial_Config as Tc on Rtt.TerritorialID=Tc.TerritorialID
Where Rtt.TerEmpCount<>(Select TerEmpCount From dbo.Territorial_Config Where TerritorialID=Rtt.TerritorialID) 
*/

UpDate dbo.RT_TerOverEmp
Set TerEmpCount=Tc.TerEmpCount,
	NowTerEmpCount=(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Rtt.TerritorialID and CsTypeID=0 ),
	NowOverCount=(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Rtt.TerritorialID and CsTypeID=0 )-Tc.TerEmpCount
From dbo.RT_TerOverEmp as Rtt Left Join dbo.Territorial_Config as Tc on Rtt.TerritorialID=Tc.TerritorialID
Where (Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Rtt.TerritorialID and CsTypeID=0)>Rtt.TerEmpCount 
	or Rtt.TerEmpCount<>Tc.TerEmpCount
	--and Rtt.NowTerEmpCount<>(Select count(1) From dbo.RT_TerritorialInfo Where TerritorialID=Rtt.TerritorialID and CsTypeID=0)


UpDate dbo.RT_TerOverEmp
Set MaxOverCount=Rtt.NowOverCount
From dbo.RT_TerOverEmp as Rtt 
Where Rtt.NowOverCount>Rtt.MaxOverCount


Insert into dbo.His_TerOverEmp(TerritorialID,TerritorialName,TerritorialTypeName,TerEmpCount,MaxOverCount,OverEmpBeginTime,OverEmpEndTime)
Select TerritorialID,TerritorialName,TerritorialTypeName,TerEmpCount,MaxOverCount,OverEmpBeginTime,getdate() as OverEmpEndTime
From dbo.RT_TerOverEmp as Rtt
Where Rtt.TerEmpCount>=(Select Count(1) From dbo.RT_TerritorialInfo where TerritorialID=Rtt.TerritorialID and CsTypeID=0)

Delete dbo.RT_TerOverEmp
From dbo.RT_TerOverEmp as Rtt
Where Rtt.TerEmpCount>=(Select Count(1) From dbo.RT_TerritorialInfo where TerritorialID=Rtt.TerritorialID and CsTypeID=0)


--Select * From dbo.RT_TerOverEmp
--Select * From His_TerOverEmp

end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create  proc A_SaveTerSet
(
	@TerritorialID int,
	@StationHeadID int,
	@IsTerriorialEnter bit
)
as
begin
if(not exists(Select 1 From Territorial_Set Where TerritorialID=@TerritorialID and StationHeadID = @StationHeadID))
begin
	declare @StationID int		--该探头的分站ID	
	set @StationID =(Select StationID From Station_Info as Si left join Station_Head_Info as Shi on Si.StationAddress=Shi.StationAddress Where Shi.StationHeadID =@StationHeadID )

	insert into Territorial_Set(TerritorialID,StationID,StationHeadID,IsTerriorialEnter)
	values(@TerritorialID,@StationID,@StationHeadID,@IsTerriorialEnter)
end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create      procedure A_Shine_Shen_EmployeeAttendanceQuery @strWhere varchar(500),@PageIndex int,
@PageSize int 

as

declare @strsql varchar(4000)

declare @strsql1 varchar(4000)

declare @sql varchar(1000)

set @sql = 'select H.ID,BlockID,EmployeeName,D.DeptID,H.ClassID,D.DeptName,T.NameShort ClassShortName,H.BeginWorkTime,H.EndWorkTime,H.Remark,TimerIntervalID,DataAttendance
	  from HistoryAttendance H left join Dept_Info D on H.deptID = D.DeptID left join TimerInterval T on H.TimerIntervalID = T.ID   where H.IsHoliday = 0 and workTime>0 '+@strWhere 


set @strsql = 'select Count(*) from ('+@sql+') as X'
--print @sql
--print '*********1'
if @PageIndex = 1
begin

	SET @strsql1 = 'select top '+str(@PageSize)+' ID,BlockID,EmployeeName,DeptID,ClassID,DeptName,ClassShortName,BeginWorkTime,EndWorkTime,Remark,TimerIntervalID,DataAttendance  
			from ('+@sql+') as Z ORDER BY ID DESC'	
end

else
begin

	SET @strsql1 = 'select top '+str(@PageSize)+' ID,BlockID,EmployeeName,DeptID,ClassID,DeptName,ClassShortName,BeginWorkTime,EndWorkTime,Remark,TimerIntervalID,DataAttendance from 
	('+@sql+') as P where ID < (select MIN(ID) from ('+@sql+') as Q where ID in (select top '+str(@PageSize*(@PageIndex - 1))+
	' ID from ('+@sql+') as R order by ID DESC)) order by ID DESC'
end

--print @strsql1

EXEC(@strsql1)
--print '**************'
--print @strsql
exec(@strsql)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create   procedure A_Shine_StatMonthEmp_z
@year int,
@strwhere varchar(2000),
@IsLead int -- 统计类型0为次数 1时间
as
begin
declare @strsql varchar(2000)
if @strwhere <> ''
	begin
		set @strwhere = ' where '+@strwhere
	end
set @strsql='select a.EmpName,a.EmpID from Emp_Info as a 
left join Emp_NowCompany as enc on enc.EmpID = a.EmpID 
left join CodeSender_Set as cs on cs.UserID = enc.EmpID and cs.CsTypeID=0 
left join Emp_Info as ei on ei.EmpID = enc.EmpID 
left join Emp_WorkType as ew on ew.EmpID = enc.EmpID 
left join Duty_Info as di on di.DutyID=enc.DutyID 
'+@strwhere

declare @strsql1 varchar(7000)

set @strsql1 = 'Select w.EmpName,w.EmpID From ('+@strsql+') as w '

--print @strsql1
if @IsLead = 0
begin
set @strsql1 = 'select w.EmpName
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',1)) as c1
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',2)) as c2
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',3)) as c3
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',4)) as c4
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',5)) as c5
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',6)) as c6
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',7)) as c7
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',8)) as c8
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',9)) as c9
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',10)) as c10
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',11)) as c11
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',12)) as c12
,(select count(UserID) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year)+'-1-1'+char(39)+' and InTime<'+char(39)+str(@year+1)+'-1-1'+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID
from ('+@strsql1+') as w'
exec (@strsql1)
end
else
begin
set @strsql1 = 'select w.EmpName
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',1)) as d1
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',2)) as d2
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',3)) as d3
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',4)) as d4
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',5)) as d5
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',6)) as d6
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',7)) as d7
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',8)) as d8
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',9)) as d9
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',10)) as d10
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',11)) as d11
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',12)) as d12
,(select dbo.FunConvertTime(ISnull(sum(ContinueTime),0)) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year)+'-1-1'+char(39)+' and InTime<'+char(39)+str(@year+1)+'-1-1'+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID 
from ('+@strsql1+') as w'
exec (@strsql1)
end
exec ('select count(1) from ('+@strsql+') as r')
--print @strsql1
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





create  procedure [dbo].[A_Shine_hh_StatMonthEmp]
@year int,
@Uday int,
@Dday int,
@PageIndex int,
@PageSize int,
@strwhere varchar(2000),
@IsLead int -- 统计类型0为次数 1时间
as
begin
declare @strsql varchar(2000)
if @strwhere <> ''
	begin
		set @strwhere = ' where '+@strwhere
	end
set @strsql='select a.EmpName,a.EmpID from Emp_Info as a 
left join Emp_NowCompany as enc on enc.EmpID = a.EmpID 
left join CodeSender_Set as cs on cs.UserID = enc.EmpID and cs.CsTypeID=0 
left join Emp_Info as ei on ei.EmpID = enc.EmpID 
left join Emp_WorkType as ew on ew.EmpID = enc.EmpID 
left join Duty_Info as di on di.DutyID=enc.DutyID 
'+@strwhere

declare @strsql1 varchar(7000)
if(@PageIndex =1)
begin
	set @strsql1 = 'select top '+str(@PageSize)+' w.EmpName,w.EmpID 
	from ('+@strsql+') as w order by w.EmpID'
end
else
begin
SET @strsql1 = 'select top '+str(@PageSize)+' EmpID,EmpName from 
	('+@strsql+') as P where EmpID < (select MIN(EmpID) from ('+@strsql+') as 
Q where EmpID in (select top '+str(@PageSize*(@PageIndex - 1))+
	' EmpID from ('+@strsql+') as R order by EmpID DESC)) order by EmpID DESC'
end
print @strsql1
if @IsLead = 0
begin
set @strsql1 = 'select w.EmpName
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',1,'+str(@Uday)+','+str(@Dday)+')) as c1
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',2,'+str(@Uday)+','+str(@Dday)+')) as c2
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',3,'+str(@Uday)+','+str(@Dday)+')) as c3
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',4,'+str(@Uday)+','+str(@Dday)+')) as c4
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',5,'+str(@Uday)+','+str(@Dday)+')) as c5
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',6,'+str(@Uday)+','+str(@Dday)+')) as c6
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',7,'+str(@Uday)+','+str(@Dday)+')) as c7
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',8,'+str(@Uday)+','+str(@Dday)+')) as c8
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',9,'+str(@Uday)+','+str(@Dday)+')) as c9
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',10,'+str(@Uday)+','+str(@Dday)+')) as c10
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',11,'+str(@Uday)+','+str(@Dday)+')) as c11
,(dbo.A_EmpMonthStat_HH(w.EmpID,'+str(@year)+',12,'+str(@Uday)+','+str(@Dday)+')) as c12
,(select count(UserID) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year-1)+'-12-'+str(@Uday)+char(39)+' and InTime<'+char(39)+str(@year)+'-1-'+str(@Dday)+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID
from ('+@strsql1+') as w'
exec (@strsql1)
end
else
begin
set @strsql1 = 'select w.EmpName
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',1,'+str(@Uday)+','+str(@Dday)+')) as d1
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',2,'+str(@Uday)+','+str(@Dday)+')) as d2
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',3,'+str(@Uday)+','+str(@Dday)+')) as d3
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',4,'+str(@Uday)+','+str(@Dday)+')) as d4
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',5,'+str(@Uday)+','+str(@Dday)+')) as d5
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',6,'+str(@Uday)+','+str(@Dday)+')) as d6
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',7,'+str(@Uday)+','+str(@Dday)+')) as d7
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',8,'+str(@Uday)+','+str(@Dday)+')) as d8
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',9,'+str(@Uday)+','+str(@Dday)+')) as d9
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',10,'+str(@Uday)+','+str(@Dday)+')) as d10
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',11,'+str(@Uday)+','+str(@Dday)+')) as d11
,(dbo.A_EmpTimeMonthStat_HH(w.EmpID,'+str(@year)+',12,'+str(@Uday)+','+str(@Dday)+')) as d12
,(select dbo.FunConvertTime(ISnull(sum(ContinueTime),0)) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year-1)+'-12-'+str(@Uday)+char(39)+' and InTime<'+char(39)+str(@year)+'-1-'+str(@Dday)+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID 
from ('+@strsql1+') as w'
exec (@strsql1)
end
exec ('select count(1) from ('+@strsql+') as r')
print @strsql1
end
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc A_Statement_ConfineArea
(
	@strDate nvarchar(20)
)
as
begin
declare @Sql1 varchar(1000)
Declare @Sql2 varchar(3000)

Set @Sql1='Select CodeSenderAddress,datediff(s,InTerritorialTime,OutTerritorialTime) as ContinueTime 
From His_InOutTerritorial 
Where CsTypeID=0 and TerritorialTypeName=''限制区域'' and IsAlarm=1 and OutTerritorialTime>='''+@strDate+' 00:00:00'' and OutTerritorialTime<='''+@strDate+' 23:59:59'''

--print @Sql1
--print'-----------------------------------------------'

set @Sql2='Select B.CodeSenderAddress as 标识卡号,Ei.EmpNO as 员工编号,Ei.EmpName as 姓名,Dei.DeptName as 部门,Dui.DutyName as 职务,Wti.WtName as 工种,Counts as 进出次数,dbo.FunConvertTime(CTime) as 持续时长
From (Select CodeSenderAddress,count(1) as Counts,Sum(ContinueTime) as CTime From ('+@Sql1+') as A Group By CodeSenderAddress) as B 
Left Join CodeSender_Set as Css on B.CodeSenderAddress=Css.CodeSenderAddress 
Left Join Emp_Info as Ei on Css.UserID=Ei.EmpID 
Left Join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
Left Join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
Left Join Duty_Info as Dui on Enc.DutyID=Dui.DutyID 
Left Join Emp_WorkType as Ewt on Ewt.EmpID=Ei.EmpID and Ewt.IsEnable=1 
Left Join WorkType_Info as Wti on Ewt.WorkTypeID=Wti.WorkTypeID 
Where Css.CsTypeID=0
'
--Print @Sql2
--print'----------------------------------------------'
Exec (@Sql2)

end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE  proc A_Statement_EmpInWell
(
	@strDate nvarchar(20)
)
as
begin
declare @Sql1 varchar(1000)
Declare @Sql2 varchar(3000)

Set @Sql1='Select CodeSenderAddress,ContinueTime 
From His_InOutMine
Where OutTime>='''+@strDate+' 00:00:00'' and OutTime<='''+@strDate+' 23:59:59'''

--print @Sql1
--print'-----------------------------------------------'

Set @Sql2='Select B.CodeSenderAddress as 标识卡号,Ei.EmpNO as 员工编号,Ei.EmpName as 姓名,Dei.DeptName as 部门,Dui.DutyName as 职务,Wti.WtName as 工种,Counts as 下井次数,dbo.FunConvertTime(CTime) as 下井总时长 
From (Select CodeSenderAddress,count(1) as Counts,Sum(ContinueTime) as CTime From ('+@Sql1+') as A Group By CodeSenderAddress) as B 
Left Join CodeSender_Set as Css on B.CodeSenderAddress=Css.CodeSenderAddress 
Left Join Emp_Info as Ei on Css.UserID=Ei.EmpID 
Left Join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
Left Join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
Left Join Duty_Info as Dui on Enc.DutyID=Dui.DutyID 
Left Join Emp_WorkType as Ewt on Ewt.EmpID=Ei.EmpID and Ewt.IsEnable=1 
Left Join WorkType_Info as Wti on Ewt.WorkTypeID=Wti.WorkTypeID 
Where Css.CsTypeID=0'

--Print @Sql2
--print'----------------------------------------------'

Exec (@Sql2)

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc A_Statement_KeyArea
(
	@strDate nvarchar(20)
)
as
begin
declare @Sql1 varchar(1000)
Declare @Sql2 varchar(3000)

Set @Sql1='Select CodeSenderAddress,datediff(s,InTerritorialTime,OutTerritorialTime) as ContinueTime 
From His_InOutTerritorial 
Where CsTypeID=0 and TerritorialTypeName=''重点区域'' and OutTerritorialTime>='''+@strDate+' 00:00:00'' and OutTerritorialTime<='''+@strDate+' 23:59:59'''

--print @Sql1
--print'-----------------------------------------------'

set @Sql2='Select B.CodeSenderAddress as 标识卡号,Ei.EmpNO as 员工编号,Ei.EmpName as 姓名,Dei.DeptName as 部门,Dui.DutyName as 职务,Wti.WtName as 工种,Counts as 进出次数,dbo.FunConvertTime(CTime) as 持续时长
From (Select CodeSenderAddress,count(1) as Counts,Sum(ContinueTime) as CTime From ('+@Sql1+') as A Group By CodeSenderAddress) as B 
Left Join CodeSender_Set as Css on B.CodeSenderAddress=Css.CodeSenderAddress 
Left Join Emp_Info as Ei on Css.UserID=Ei.EmpID 
Left Join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
Left Join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
Left Join Duty_Info as Dui on Enc.DutyID=Dui.DutyID 
Left Join Emp_WorkType as Ewt on Ewt.EmpID=Ei.EmpID and Ewt.IsEnable=1 
Left Join WorkType_Info as Wti on Ewt.WorkTypeID=Wti.WorkTypeID 
Where Css.CsTypeID=0
'
--Print @Sql2
--print'----------------------------------------------'
Exec (@Sql2)

end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create  proc A_Statement_OverTime
(
	@strDate nvarchar(20)
)
as
begin
declare @Sql1 varchar(1000)
Declare @Sql2 varchar(3000)

Set @Sql1='Select CodeSenderAddress,DelayedTime as ContinueTime 
From His_OverTimeAlarm 
Where CsTypeID=0 and DelayedEndTime>='''+@strDate+' 00:00:00'' and DelayedEndTime<='''+@strDate+' 23:59:59'''

--print @Sql1
--print'-----------------------------------------------'

set @Sql2='Select B.CodeSenderAddress as 标识卡号,Ei.EmpNO as 员工编号,Ei.EmpName as 姓名,Dei.DeptName as 部门,Dui.DutyName as 职务,Wti.WtName as 工种,Counts as 进出次数,dbo.FunConvertTime(CTime) as 持续时长
From (Select CodeSenderAddress,count(1) as Counts,Sum(ContinueTime) as CTime From ('+@Sql1+') as A Group By CodeSenderAddress) as B 
Left Join CodeSender_Set as Css on B.CodeSenderAddress=Css.CodeSenderAddress 
Left Join Emp_Info as Ei on Css.UserID=Ei.EmpID 
Left Join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
Left Join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
Left Join Duty_Info as Dui on Enc.DutyID=Dui.DutyID 
Left Join Emp_WorkType as Ewt on Ewt.EmpID=Ei.EmpID and Ewt.IsEnable=1 
Left Join WorkType_Info as Wti on Ewt.WorkTypeID=Wti.WorkTypeID 
Where Css.CsTypeID=0
'
--Print @Sql2
--print'----------------------------------------------'
Exec (@Sql2)

end


--Exec A_Statement_OverTime '2008-09-17'




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加传输分站信息
create proc [A_StationInfo_Add]
(
@StationAddress int,
@StationPlace nvarchar(30),
@StationTel nvarchar(20),
@StationTypeID int,
@StationType nvarchar(10),
@StationState int,
@EditBaseInfo int,
@StationGroup int,
@StationModel int,
@BreakTime datetime
)
as
begin

if(not Exists(Select 1 From Station_Info Where StationAddress=@StationAddress))
begin
	insert into Station_Info(StationID,StationAddress,StationPlace,StationTel,StationTypeID,StationType,StationState,EditBaseInfo,StationGroup,StationModel,BreakTime)
	values(@StationAddress,@StationAddress,@StationPlace,@StationTel,@StationTypeID,@StationType,@StationState,@EditBaseInfo,@StationGroup,@StationModel,@BreakTime)

end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

create   proc A_StationInfo_UpDate
(
@StationAddress int,
@StationPlace nvarchar(30),
@StationTel nvarchar(20),
@StationTypeID int,
@StationType nvarchar(10),
@StationState int,
@EditBaseInfo int,
@StationGroup int,
@StationModel int
)
as
begin

if(Exists(Select 1 From Station_Info Where StationAddress=@StationAddress))
begin
	update Station_Info
	set StationPlace=@StationPlace,StationTel=@StationTel,StationTypeID=@StationTypeID,StationType=@StationType,StationState=@StationState,
		EditBaseInfo=@EditBaseInfo,StationGroup=@StationGroup,StationModel=@StationModel
	where StationAddress=@StationAddress
end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create  proc A_TerInfo_Delete
(
	@where varchar(2000)
)
as
begin

declare @strSQL1 varchar(5000)
declare @strSQL2 varchar(5000)

set @strSQL1='delete From dbo.Territorial_Config Where ' + @where
set @strSQL2='delete From dbo.Territorial_Info where ' + @where

exec(@strSQL1)
exec(@strSQL2)

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE proc A_TerInfo_Insert
(
	@TerritorialName nvarchar(20),
	@TerritorialTypeID int,
	@IsEnable bit=1,
	@Instruction nvarchar(500)=null,
	@TerWorkTime int,
	@TerEmpCount int,
	@Remark nvarchar(200),
	@ID int
)
as
begin

declare @TerritorialID int

	if(not exists(Select 1 From Territorial_Info Where TerritorialName=@TerritorialName ))
	begin
		insert into Territorial_Info(TerritorialID,TerritorialName,TerritorialTypeID,IsEnable,Instruction,Remark)
		values(@ID,@TerritorialName,@TerritorialTypeID,@IsEnable,@Instruction,@Remark)

		set @TerritorialID = (select TerritorialID From Territorial_Info Where TerritorialName=@TerritorialName)
		
		if( @TerritorialID is not null)
		begin
			if(not exists(Select 1 From Territorial_Config Where TerritorialID=@TerritorialID ))
			begin
				insert into Territorial_Config(TerConfigID,TerritorialID,TerWorkTime,TerEmpCount)
				values(@TerritorialID,@TerritorialID,@TerWorkTime,@TerEmpCount)
			end
		end
	end

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE  proc A_TerInfo_UpDate
(
	@TerritorialName nvarchar(20),
	@TerritorialTypeID int,
	@IsEnable bit=1,
	@Instruction nvarchar(500)=null,
	@TerWorkTime int,
	@TerEmpCount int,
	@Remark nvarchar(200),
	@TerritorialID int
)
as
begin
	if(exists(Select 1 From Territorial_Info Where TerritorialID=@TerritorialID ))
	begin
		update Territorial_Info
		Set TerritorialTypeID =@TerritorialTypeID,IsEnable =@IsEnable,Instruction =@Instruction,Remark=@Remark,TerritorialName  =@TerritorialName
		Where TerritorialID=@TerritorialID

		if(exists(Select 1 From Territorial_Config Where TerritorialID=@TerritorialID ))
		begin
			update Territorial_Config
			Set TerWorkTime=@TerWorkTime,TerEmpCount=@TerEmpCount
			Where TerritorialID =@TerritorialID
		end
		else
		begin
			Insert into Territorial_Config(TerConfigID,TerritorialID,TerWorkTime,TerEmpCount)
			values(@TerritorialID,@TerritorialID,@TerWorkTime,@TerEmpCount)
		end
	end

end







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc A_TerSet_Insert
(
	@TerritorialID int,
	@StationHeadID int,
	@IsTerriorialEnter bit,
	@ID int
)
as
begin
if(not exists(Select 1 From Territorial_Set Where TerritorialID=@TerritorialID and StationHeadID = @StationHeadID))
begin
	declare @StationID int		--该探头的分站ID	
	set @StationID =(Select StationID From Station_Info as Si left join Station_Head_Info as Shi on Si.StationAddress=Shi.StationAddress Where Shi.StationHeadID =@StationHeadID )

	insert into Territorial_Set(TerritorialSetID,TerritorialID,StationID,StationHeadID,IsTerriorialEnter)
	values(@ID,@TerritorialID,@StationID,@StationHeadID,@IsTerriorialEnter)
end
else
begin
	update Territorial_Set
	Set IsTerriorialEnter = @IsTerriorialEnter
	Where TerritorialID=@TerritorialID and StationHeadID = @StationHeadID

end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

create proc A_TerSet_Update
(
	@TerritorialID int,
	@Where varchar(3000)
)
as
delete from Territorial_Set where TerritorialID =@TerritorialID and StationHeadID not in(Select * From dbo.f_splitstr(@Where,',') as A )



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create   proc A_WalkSpeed_Delete
(
	@OverSpeedID int
)
as
begin
declare @FirstStationAddress int
declare @FirstStationHeadAddress int
declare @LastStationAddress int
declare @LastStationHeadAddress int
	
	Select @FirstStationAddress=FirstStationAddress,@FirstStationHeadAddress=FirstStationHeadAddress,@LastStationAddress=LastStationAddress,@LastStationHeadAddress=LastStationHeadAddress
	From dbo.OverSpeed
	Where OverSpeedID=@OverSpeedID

	update His_OverSpeed
	Set IsOutWell=1
	Where FirstStationAddress=@FirstStationAddress and FirstStationHeadAddress=@FirstStationHeadAddress and LastStationAddress=@LastStationAddress 
		and LastStationHeadAddress=@LastStationHeadAddress and( IsOverSpeed = 1 or IsLackSpeed = 1 )and IsOutWell=0

	delete From His_OverSpeed
	Where FirstStationAddress=@FirstStationAddress and FirstStationHeadAddress=@FirstStationHeadAddress and LastStationAddress=@LastStationAddress 
		and LastStationHeadAddress=@LastStationHeadAddress and IsOutWell=0

	delete from OverSpeed where OverSpeedID=@OverSpeedID

end 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create   proc A_WalkSpeed_Delete_All
(
	@strOverSpeedID varchar(6000)
)
as
begin
	declare @OverSpeedID int
	--定义游标
	declare processWalkSpeed cursor for (select F1 from dbo.f_splitstr(@strOverSpeedID,','))
	--打开游标
	open processWalkSpeed
	--移到下一行
	fetch next from processWalkSpeed into @OverSpeedID

	while (@@FETCH_STATUS <> -1)
	begin
		if @OverSpeedID<>''
		begin
			exec A_WalkSpeed_Delete @OverSpeedID
		end
		fetch next from processWalkSpeed into @OverSpeedID
	end
	--关闭游标
	close processWalkSpeed
	--释放游标
	deallocate processWalkSpeed
end 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create  proc A_WalkSpeed_InsertAndUpDate
(
	@FirstStationAddress int,		
	@FirstStationHeadAddress int,		
	@LastStationAddress int,
	@LastStationHeadAddress int,
	@WalkTime int,
	@Remark nvarchar(200),
	@LackWalkTime int,
	@ID int
)
as
begin

if(not exists(Select 1 From OverSpeed Where FirstStationAddress = @FirstStationAddress and FirstStationHeadAddress=@FirstStationHeadAddress 
		and LastStationAddress=@LastStationAddress and LastStationHeadAddress=@LastStationHeadAddress))
begin
	insert into OverSpeed(OverSpeedID,FirstStationAddress,FirstStationHeadAddress,LastStationAddress,LastStationHeadAddress,
			WalkTime,Remark,LackWalkTime)
	values(@ID,@FirstStationAddress,@FirstStationHeadAddress,@LastStationAddress,@LastStationHeadAddress,@WalkTime,@Remark,@LackWalkTime)

end
else
begin
	update OverSpeed
	Set WalkTime=@WalkTime,Remark=@Remark,LackWalkTime=@LackWalkTime
	Where FirstStationAddress = @FirstStationAddress and FirstStationHeadAddress=@FirstStationHeadAddress 
		and LastStationAddress=@LastStationAddress and LastStationHeadAddress=@LastStationHeadAddress
end 
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE proc [dbo].[A_houhui_His_Statoin]
@IsEmp int,  --0为人员 1为设备
@StrWhere varchar(1000),
@PageSize int =10  ,         -- 页尺寸
@PageIndex int =1          -- 页码
as

declare @Tab varchar(2000)
declare @strSQL varchar(5000)
if(@IsEmp=0)
begin
set @Tab='
select hi.HisStationHeadID, hi.CodeSenderAddress 标识卡,emp.EmpName 姓名, wt.WtName 工种,de.DeptName 部门,convert(varchar(10),hi.StationAddress)+'+''''+'@'+''''+'+convert(varchar(10),hi.StationHeadAddress) 传输分站@读卡分站,StationHeadPlace 读卡分站的位置,hi.InStationHeadTime 进入时间, datediff(mi,hi.InStationHeadTime,hi.OutStationHeadTime) 持续时长 from  dbo.His_InOutStationHead as hi 
			left join dbo.Emp_NowCompany as en on hi.UserID=en.EmpID and hi.CsTypeID=0 
			left join dbo.Emp_Info as emp on en.EmpID=emp.EmpID
			left join dbo.Dept_Info as de on en.DeptID=de.DeptID
			left join dbo.Emp_WorkType as ew on en.EmpID=ew.EmpID
			left join dbo.WorkType_Info as wt on ew.WorkTypeID=wt.WorkTypeID where '+@StrWhere
end
else
begin
set @Tab='
select hi.HisStationHeadID, hi.CodeSenderAddress 标识卡,eq.EquName 设备名称,eq.EquNO 设备编号,de.DeptName 部门,convert(varchar(10),hi.StationAddress)+'+''''+'@'+''''+'+convert(varchar(10),hi.StationHeadAddress) 传输分站@读卡分站,StationHeadPlace 读卡分站的位置,hi.InStationHeadTime 进入时间, datediff(mi,hi.InStationHeadTime,hi.OutStationHeadTime) 持续时长 from dbo.His_InOutStationHead as hi
				left join dbo.Equ_BaseInfo as eq on hi.UserID=eq.EquID and hi.CsTypeID=1
				left join dbo.Dept_Info as de on eq.DeptID=de.DeptID where '+@StrWhere
end




if(@PageIndex>1)
begin
set @strSQL = 'select top ' + str(@PageSize) + ' * from ('
    + @Tab + ') as t where  t.HisStationHeadID <(select min(t2.HisStationHeadID) from (select top ' + str((@PageIndex-1)*@PageSize) + ' t1.HisStationHeadID from (' + @Tab + ') as t1 order by t1.HisStationHeadID desc)as t2) order by t.HisStationHeadID desc' 
end
else
begin
set @strSQL='select top '+str(@PageSize)+' * from ('+@Tab+') as t order by t.HisStationHeadID desc'
end
print @strSQL
exec (@strSQL)
if(@IsEmp=0)
begin
select count(*) from dbo.His_InOutStation_1 where CsTypeID=0
end
else
begin
select count(*) from dbo.His_InOutStation_1 where CsTypeID=1
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE proc [dbo].[A_houhui_his_Dept_Tree]
@isemp int --0为人 1为设备
as

create table #c (ID int,Name varchar(20),ParentID int,IsChild bit,IsUserNum bit,Num int)
if(@isemp=0)
begin
insert into #c(ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num) values(0 ,'所有' ,-1 ,0,1 ,null )
update #c set Num=(select count(*) from dbo.His_InOutStation where CsTypeID=0) where ID=0
insert #c select t.DeptID ID,t.DeptName name,t.ParentDeptID ParentID, 1 IsChild,1 IsUserNum, (select count(*) from dbo.His_InOutStation as hi left join dbo.Emp_NowCompany as en on hi.UserID= en.EmpID where hi.CsTypeID=0 and en.DeptID=t.DeptID) Num from dbo.Dept_Info as t
end
else
begin
insert into #c(ID ,Name ,ParentID ,IsChild ,IsUserNum ,Num) values(0 ,'所有' ,-1 ,0,1 ,null )
update #c set Num=(select count(*) from dbo.His_InOutStation where CsTypeID=1) where ID=0
insert #c select t.DeptID ID,t.DeptName name,t.ParentDeptID ParentID, 1 IsChild,1 IsUserNum, (select count(*) from dbo.His_InOutStation as hi left join dbo.Equ_BaseInfo as en on hi.UserID= en.EquID where hi.CsTypeID=1 and en.DeptID=t.DeptID) Num from dbo.Dept_Info as t
end
select * from #c
drop table #c


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE   proc A_zjw_DeptInfo_Delete
(
	@strWhere varchar(6000)
)
as
begin

--delete @strWhere varchar(2000)

--set @strWhere=' DeptID= 65 or DeptID=64 Or DeptID=64'
declare @SqlEmp varchar(3000)

declare @SqlDept varchar(3000)

set @SqlEmp =' delete from Emp_Info where EmpID in ( Select EmpID From dbo.Emp_NowCompany Where '+ @strWhere+' ) '

set @SqlDept=' delete From Dept_Info where '+@strWhere 

print @SqlEmp
exec(@SqlEmp)
print @SqlDept
exec(@SqlDept)

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE      proc A_zjw_DeptInfo_Insert
(
--基本表
  @ParentDeptID int,
  @DeptLevelID int,
  @DeptNO nvarchar(20),
  @DeptName nvarchar(20),
  @Remark nvarchar(200),
  @ClassID int,

--配置表
  @MaxTimeSec int,
  @MinTimeSec int,

--信息表
  @DeptTel1 nvarchar(20),
  @DeptTel2 nvarchar(20),
  @DeptFax nvarchar(20),
  @DeptPost nvarchar(6),
  @DeptAddress nvarchar(250),
  @DeptEmail nvarchar(100),

--领导表
  @EmpID int,
  @LeadDateTime datetime,

--部门工时单价
  @UnitPrice float,

  @SerialNO int,		--部门排列序号
  @ID int
)
as

begin
declare @DeptID int	--部门ID

if( not exists( Select 1 From Dept_Info Where DeptNO=@DeptNO))
begin
	--部门基本表
	Insert into [Dept_Info]
	(DeptID,ParentDeptID,DeptLevelID,DeptNO,DeptName,Remark,ClassID,SerialNO)
	values
	(@ID,@ParentDeptID,@DeptLevelID,@DeptNO,@DeptName,@Remark,@ClassID,@SerialNO)
end
else
begin
	Update Detp_Info
	Set ParentDeptID=@ParentDeptID,DeptLevelID=@DeptLevelID,DeptName=@DeptName,
		Remark=@Remark,ClassID=@ClassID,SerialNO=@SerialNO
	where DeptNO=@DeptNO
end	


select @DeptID = DeptID from Dept_Info where DeptNO = @DeptNO

--print @DeptID

if(@DeptID is not null)
begin
	
	--部门信息表
	if((select count(*) from Dept_Detail where DeptID=@DeptID)>0)
	begin
--print '部门信息 1'
		Update Dept_Detail 
		   set DeptTel1=@DeptTel1,DeptTel2=@DeptTel2,DeptFax=@DeptFax,
		       DeptPost=@DeptPost,DeptAddress=@DeptAddress,DeptEmail=@DeptEmail
		where DeptID=@DeptID
	end
	else
	begin
--print '部门信息 2'
		Insert into [Dept_Detail]
		(DeptDetailID,DeptID,DeptTel1,DeptTel2,DeptFax,DeptPost,DeptAddress,DeptEmail)
		values
		(@DeptID,@DeptID,@DeptTel1,@DeptTel2,@DeptFax,@DeptPost,@DeptAddress,@DeptEmail)
	end

	--部门配置表
	if(not exists(select 1 from Dept_SysSet where DeptID = @DeptID ))
	begin
--print '部门配置'
	Insert into [Dept_SysSet]
	(DeptSysSetID,DeptID,MaxTimeSec,MinTimeSec)
	values
	(@DeptID,@DeptID,@MaxTimeSec,@MinTimeSec)
	end	

	--部门领导表
	if(@EmpID>0)
	begin
		if((select count(*) from Dept_Lead where DeptID=@DeptID)>0)
		begin
--print '部门领导 1'
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			update Dept_Lead 
			set EmpID=@EmpID,LeadDateTime=@LeadDateTime
			where DeptID = @DeptID
		end
		else
		begin
			
--print '部门领导 2'
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			Insert into [Dept_Lead]
			    (DeptLeadID,DeptID,EmpID,LeadDateTime)
			values
			    (@DeptID,@DeptID,@EmpID,@LeadDateTime)
		
		end
	end

	--部门工时单价
	if(@UnitPrice <> -1000)
	begin
		if(not exists(Select 1 From UnitPrice Where DeptID =@DeptID))
		begin
			insert into UnitPrice
				([ID],DeptID,UnitPrice)
			values
				(@DeptID,@DeptID,@UnitPrice)
		end

	end

end

end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE         proc A_zjw_DeptInfo_UpDate
(
--基本表
  @ParentDeptID int,
  @DeptLevelID int,
  @DeptNO nvarchar(20),
  @DeptName nvarchar(20),
  @Remark nvarchar(200),
  @ClassID int,

--配置表
  @MaxTimeSec int,
  @MinTimeSec int,

--信息表
  @DeptTel1 nvarchar(20),
  @DeptTel2 nvarchar(20),
  @DeptFax nvarchar(20),
  @DeptPost nvarchar(6),
  @DeptAddress nvarchar(250),
  @DeptEmail nvarchar(100),

--领导表
  @EmpID int,
  @LeadDateTime datetime,

--部门工时单价
  @UnitPrice float,

  @DeptID int,
  @SerialNO int		--部门排列序号

)
as

begin


if(exists(Select 1 From Dept_Info Where DeptID=@DeptID) )
begin
	--部门基本表
	Update Dept_Info
	Set ParentDeptID=@ParentDeptID,DeptLevelID=@DeptLevelID,DeptName=@DeptName,
		Remark=@Remark,ClassID=@ClassID,DeptNO=@DeptNO,SerialNO=@SerialNO
	where DeptID=@DeptID

	
	--部门信息表
	if((select count(1) from Dept_Detail where DeptID=@DeptID)>0)
	begin
		Update Dept_Detail 
		   set DeptTel1=@DeptTel1,DeptTel2=@DeptTel2,DeptFax=@DeptFax,
		       DeptPost=@DeptPost,DeptAddress=@DeptAddress,DeptEmail=@DeptEmail
		where DeptID=@DeptID
	end
	else
	begin
		Insert into [Dept_Detail]
		(DeptDetailID,DeptID,DeptTel1,DeptTel2,DeptFax,DeptPost,DeptAddress,DeptEmail)
		values
		(@DeptID,@DeptID,@DeptTel1,@DeptTel2,@DeptFax,@DeptPost,@DeptAddress,@DeptEmail)
	end

	--部门配置表
	if(not exists(select 1 from Dept_SysSet where DeptID = @DeptID ))
	begin
		Insert into [Dept_SysSet]
		(DeptSysSetID,DeptID,MaxTimeSec,MinTimeSec)
		values
		(@DeptID,@DeptID,@MaxTimeSec,@MinTimeSec)
	end	
	else
	begin
		update Dept_SysSet
		Set MaxTimeSec=@MaxTimeSec,MinTimeSec=@MinTimeSec
		where DeptID=@DeptID
	end

	--部门领导表
	if( @EmpID>0)
	begin
		if((select count(1) from Dept_Lead where DeptID=@DeptID)>0)
		begin
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			update Dept_Lead 
			set EmpID=@EmpID,LeadDateTime=@LeadDateTime
			where DeptID = @DeptID
		end
		else
		begin
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			Insert into [Dept_Lead]
			    (DeptLeadID,DeptID,EmpID,LeadDateTime)
			values
			    (@DeptID,@DeptID,@EmpID,@LeadDateTime)
		
		end
	end

	--部门工时单价
	if(@UnitPrice > -1000)
	begin
		print @UnitPrice
		if(not exists(Select 1 From UnitPrice Where DeptID =@DeptID))
		begin
			insert into UnitPrice
				([ID],DeptID,UnitPrice)
			values
				(@DeptID,@DeptID,@UnitPrice)
		end
		else
		begin
			update dbo.UnitPrice
			Set UnitPrice=@UnitPrice
			Where DeptID = @DeptID
		end
	end

	--更改与此部门绑定的最大工作时间的员工的最大工作时间
	update Emp_NowCompany
	Set MaxSecTime=@MaxTimeSec,MinSecTime=@MinTimeSec
	Where DeptID=@DeptID and Selectmode=1

end

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  proc A_zjw_DutyInfo_Delete
(
	@strWhere varchar(2000)
)
as
begin

--delete @strWhere varchar(2000)

--set @strWhere=' DeptID= 65 or DeptID=64 Or DeptID=64'
declare @SqlEmp varchar(3000)

declare @SqlDuty varchar(3000)

set @SqlEmp =' delete from Emp_Info where EmpID in ( Select EmpID From dbo.Emp_NowCompany Where DutyID = '+ @strWhere+' ) '

set @SqlDuty=' delete From Duty_Info where DutyID = '+@strWhere 

print @SqlEmp
exec(@SqlEmp)
print @SqlDuty
exec(@SqlDuty)


end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/*
	增加员工信息
	李乐
	2008-07-30 13：52
*/

CREATE       proc A_zjw_Emp_Insert
(	
	@EmpName nvarchar(20),
	@Sex bit,
	@Remark nvarchar(200),
	@EmpNO nvarchar(10),
	@DeptID int,

	@DutyID int,
	@MaxSecTime int,
	@MinSecTime int,
	@Selectmode int,
	@ClassGroup nvarchar(50)=null,

	@WorkPlace nvarchar(50)=null,
	@Photo image =null,
	@EmpTel1 nvarchar(20)=null,
	@EmpTel2 nvarchar(20)=null,
	@EmpTel3 nvarchar(20)=null,

	@EmpQQ nvarchar(20)=null,
	@EmpMsn nvarchar(20)=null,
	@HomePage nvarchar(200)=null,
	@EmpEmail nvarchar(80)=null,
	@EmpEmailBackup nvarchar(80)=null,

	@Nation nvarchar(30)=null,
	@WedlockID int,
	@ClanID int,
	@NativePlace nvarchar(50)=null,
	@CensusRegister nvarchar(50)=null,

	@SchoolRecordID int,
	@GraduateFrom nvarchar(35)=null,
	@Specialty nvarchar(50)=null,
	@OfficialDesignation nvarchar(50)=null,
	@Idcard nvarchar(20)=null,

	@BirthDay datetime=null,
	@Height int=0,
	@Weight int=0,
	@StateOfHealth nvarchar(50)=null,
	@HomeTel1 nvarchar(20)=null,

	@HomeTel2 nvarchar(20)=null,
	@HomeAddress nvarchar(250)=null,
	@Postalcode nvarchar(6)=null,
	@ProbationDate datetime=null,
	@OfficiallyDate datetime=null,

	@ContractExpDate datetime=null,
	@ContractExpAppendDate datetime=null,
	@IsGearShift bit,
	@HireTypeID int,
	@Archives nvarchar(100)=null,

	@DimissionTime datetime=null,
	@EmpDetailRemark nvarchar(200)=null,
	@EmpSerchRemark nvarchar(200)=null,
	@EmpHomeRemark nvarchar(200)=null,
	@EmpInCompanyRemark nvarchar(200)=null,

	@EmpNowCompanyRemark nvarchar(200)=null,
	@WorkTypeID1 int,
	@IsMostly1 bit,
	@IsEnable1 bit,
	@Company nvarchar(20)=null,
	@ID int
)
as
begin

declare @EmpID int	--定义员工ID
declare @PhotoID int	--员工照片表ID

BEGIN TRANSACTION		--创建事务

if(not exists(Select 1 From Emp_Info Where EmpNO=@EmpNO))	
begin
	if (@Idcard = '')
		Set @Idcard=null


	--插入员工信息表(Emp_Info)
	Insert into [Emp_Info](EmpID,EmpName,Sex,Remark,EmpNO)
	values(@ID,@EmpName,@Sex,@Remark,@EmpNO)

	--为员工ID(EmpID)赋值
	select @EmpID=EmpID From Emp_Info where EmpNO=@EmpNO

	--插入员工在公司表
	if(not exists ( Select 1 From Emp_NowCompany Where EmpID=@EmpID))
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end

		Insert into [Emp_NowCompany] (EmpNowCoID,EmpID,DeptID,DutyID,MaxSecTime,MinSecTime,
				Selectmode,ClassGroup,WorkPlace,Remark)
		values (@EmpID,@EmpID,@DeptID,@DutyID,@MaxSecTime,@MinSecTime,@Selectmode,
			@ClassGroup,@WorkPlace,@EmpNowCompanyRemark)

	end

	--插入员工照片表
	if( @Photo is not null )
	begin
	    Insert into [Emp_Photo]
	      (PhotoID,EmpID,Photo)
	    values
	      (@EmpID,@EmpID,@Photo)
	end

	--为@PhotoID赋值
	select @PhotoID=PhotoID From Emp_Photo where EmpID=@EmpID 

	--插入员工家庭联系方式表(Emp_Search)
	if(not exists ( Select 1 From dbo.Emp_Search Where EmpID=@EmpID))
	begin
		Insert into [Emp_Search] (EmpSearchID,EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,
			EmpEmail,EmpEmailBackup,Remark)
		values (@EmpID,@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,
			@EmpEmail,@EmpEmailBackup,@EmpSerchRemark)
	end
	
	--插入员工详细信息表(Emp_Detail)

	if(not exists( Select 1 From Emp_Detail Where EmpID=@EmpID))
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		insert into Emp_Detail(EmpDetailID,EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,
			GraduateFrom,Specialty,OfficialDesignation,PhotoID,Idcard,BirthDay,Remark,Company)
		values (@EmpID,@EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,
			@GraduateFrom,@Specialty,@OfficialDesignation,@PhotoID,@Idcard,@BirthDay,@EmpDetailRemark,@Company)
	end

	--插入员工健康表(Emp_Health)
	if(not exists ( Select 1 From Emp_Health Where EmpID=@EmpID))
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		insert into Emp_Health(EmpHealthID,EmpID,Height,Weight,StateOfHealth)
		values (@EmpID,@EmpID,@Height,@Weight,@StateOfHealth)
	end

	--插入员工家庭表(Emp_Home)
	if( not exists ( Select 1 From Emp_Home Where EmpID=@EmpID))
	begin
		insert into Emp_Home(EmpHomeID,EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
		values (@EmpID,@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@EmpHomeRemark)
	end

	--插入员工进公司表(Emp_InCompany)
	if( not exists ( Select 1 From Emp_InCompany where EmpID=@EmpID))
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		insert into Emp_InCompany(EmpInCoID,EmpID,ProbationDate,OfficiallyDate,ContractExpDate,
			ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
		values (@EmpID,@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,
			@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@EmpInCompanyRemark)
	end

	--插入员工工种表
	if( @WorkTypeID1 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID1 ))
		begin
			insert into Emp_WorkType(EmpWorkTypeID,EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@EmpID,@WorkTypeID1,@IsMostly1,@IsEnable1)
	
		end
	end
end

commit
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







/*
	增加员工信息
	赵建伟
	2008-06-23 13：52
*/

CREATE       proc A_zjw_Emp_Update
(
	@EmpName nvarchar(20),
	@Sex bit,
	@Remark nvarchar(200),
	@EmpNO nvarchar(10),
	@DeptID int,

	@DutyID int,
	@MaxSecTime int,
	@MinSecTime int,
	@Selectmode int,
	@ClassGroup nvarchar(50)=null,

	@WorkPlace nvarchar(50)=null,
	@Photo image =null,
	@EmpTel1 nvarchar(20)=null,
	@EmpTel2 nvarchar(20)=null,
	@EmpTel3 nvarchar(20)=null,

	@EmpQQ nvarchar(20)=null,
	@EmpMsn nvarchar(20)=null,
	@HomePage nvarchar(200)=null,
	@EmpEmail nvarchar(80)=null,
	@EmpEmailBackup nvarchar(80)=null,

	@Nation nvarchar(30)=null,
	@WedlockID int,
	@ClanID int,
	@NativePlace nvarchar(50)=null,
	@CensusRegister nvarchar(50)=null,

	@SchoolRecordID int,
	@GraduateFrom nvarchar(35)=null,
	@Specialty nvarchar(50)=null,
	@OfficialDesignation nvarchar(50)=null,
	@Idcard nvarchar(20)=null,

	@BirthDay datetime=null,
	@Height int=0,
	@Weight int=0,
	@StateOfHealth nvarchar(50)=null,
	@HomeTel1 nvarchar(20)=null,

	@HomeTel2 nvarchar(20)=null,
	@HomeAddress nvarchar(250)=null,
	@Postalcode nvarchar(6)=null,
	@ProbationDate datetime,
	@OfficiallyDate datetime,

	@ContractExpDate datetime,
	@ContractExpAppendDate datetime,
	@IsGearShift bit,
	@HireTypeID int,
	@Archives nvarchar(100)=null,

	@DimissionTime datetime,
	@EmpDetailRemark nvarchar(200)=null,
	@EmpSerchRemark nvarchar(200)=null,
	@EmpHomeRemark nvarchar(200)=null,
	@EmpInCompanyRemark nvarchar(200)=null,

	@EmpNowCompanyRemark nvarchar(200)=null,
	@WorkTypeID1 int,
	@IsMostly1 bit,
	@IsEnable1 bit,
	@Company nvarchar(20)=null,

	@EmpID int
)
as
begin

declare @PhotoID int	--员工照片表ID

begin transaction EmpInfo_Trans	--创建事务

begin

if(exists(Select 1 From Emp_Info Where EmpID=@EmpID))	
begin

	if (@Idcard = '')
		Set @Idcard=null
	
	--修改员工信息表(Emp_Info)
	update Emp_Info 
	Set EmpName=@EmpName,Sex=@Sex,Remark=@Remark,EmpNO=@EmpNO
	where EmpID=@EmpID

	--修改员工在公司表
	if(not exists ( Select 1 From Emp_NowCompany Where EmpID=@EmpID))
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end

		Insert into [Emp_NowCompany] (EmpNowCoID,EmpID,DeptID,DutyID,MaxSecTime,MinSecTime,
				Selectmode,ClassGroup,WorkPlace,Remark)
		values (@EmpID,@EmpID,@DeptID,@DutyID,@MaxSecTime,@MinSecTime,@Selectmode,
			@ClassGroup,@WorkPlace,@EmpNowCompanyRemark)

	end
	else
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end
		
		update Emp_NowCompany
		Set DeptID=@DeptID,DutyID=@DutyID,MaxSecTime=@MaxSecTime,MinSecTime=@MinSecTime,
			Selectmode=@Selectmode,ClassGroup=@ClassGroup,WorkPlace=@WorkPlace,Remark=@EmpNowCompanyRemark
		Where EmpID=@EmpID
	
	end

	--修改员工照片表
	if( @Photo is not null )
	begin
		if( not exists(Select 1 From Emp_Photo Where EmpID=@EmpID) )
		begin
			Insert into [Emp_Photo](PhotoID,EmpID,Photo)
			values(@EmpID,@EmpID,@Photo)
		end
		else
		begin
			UPdate Emp_Photo
			Set Photo=@Photo
			where EmpID=@EmpID
		end
	end
	else
	begin
		Delete From Emp_Photo
		Where EmpID=@EmpID
	end
	--为@PhotoID赋值
	select @PhotoID=PhotoID From Emp_Photo where EmpID=@EmpID 

	--修改员工家庭联系方式表(Emp_Search)
	if(not exists ( Select 1 From dbo.Emp_Search Where EmpID=@EmpID))
	begin
		Insert into [Emp_Search] (EmpSearchID,EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,
			EmpEmail,EmpEmailBackup,Remark)
		values (@EmpID,@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,
			@EmpEmail,@EmpEmailBackup,@EmpSerchRemark)
	end
	else
	begin
		Update Emp_Search
		Set EmpTel1=@EmpTel1,EmpTel2=@EmpTel2,EmpTel3=@EmpTel3,EmpQQ=@EmpQQ,EmpMsn=@EmpMsn,
			HomePage=@HomePage,EmpEmail=@EmpEmail,EmpEmailBackup=@EmpEmailBackup,Remark=@EmpSerchRemark
		where EmpID=@EmpID

	end

	--修改员工详细信息表(Emp_Detail)
	if(not exists( Select 1 From Emp_Detail Where EmpID=@EmpID))
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		insert into Emp_Detail(EmpDetailID,EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,
			GraduateFrom,Specialty,OfficialDesignation,PhotoID,Idcard,BirthDay,Remark,Company)
		values ( @EmpID,@EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,
			@GraduateFrom,@Specialty,@OfficialDesignation,@PhotoID,@Idcard,@BirthDay,@EmpDetailRemark,@Company)
	end
	else
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		update Emp_Detail
		Set Nation=@Nation,WedlockID=@WedlockID,ClanID=@ClanID,NativePlace=@NativePlace,CensusRegister=@CensusRegister,
			SchoolRecordID=@SchoolRecordID,GraduateFrom=@GraduateFrom,Specialty=@Specialty,OfficialDesignation=@OfficialDesignation,
			PhotoID=@PhotoID,Idcard=@Idcard,BirthDay=@BirthDay,Remark=@EmpDetailRemark,Company=@Company
		where EmpID=@EmpID
	end

	--修改员工健康表(Emp_Health)
	if(not exists ( Select 1 From Emp_Health Where EmpID=@EmpID))
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		insert into Emp_Health(EmpHealthID,EmpID,Height,Weight,StateOfHealth)
		values (@EmpID,@EmpID,@Height,@Weight,@StateOfHealth)
	end
	else
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		update Emp_Health
		Set Height=@Height,Weight=@Weight,StateOfHealth=@StateOfHealth
		Where EmpID=@EmpID
	end


	--修改员工家庭表(Emp_Home)
	if( not exists ( Select 1 From Emp_Home Where EmpID=@EmpID))
	begin
		insert into Emp_Home(EmpHomeID,EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
		values (@EmpID,@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@EmpHomeRemark)
	end
	else
	begin
		Update Emp_Home
		Set HomeTel1=@HomeTel1,HomeTel2=@HomeTel2,HomeAddress=@HomeAddress,Postalcode=@Postalcode,Remark=@EmpHomeRemark
		Where EmpID=@EmpID
	end
	

	--修改员工进公司表(Emp_InCompany)
	if( not exists ( Select 1 From Emp_InCompany where EmpID=@EmpID))
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		insert into Emp_InCompany(EmpInCoID,EmpID,ProbationDate,OfficiallyDate,ContractExpDate,
			ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
		values (@EmpID,@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,
			@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@EmpInCompanyRemark)
	end
	else
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		update Emp_InCompany
		Set ProbationDate=@ProbationDate,OfficiallyDate=@OfficiallyDate,ContractExpDate=@ContractExpDate,
			ContractExpAppendDate=@ContractExpAppendDate,IsGearShift=@IsGearShift,HireTypeID=@HireTypeID,
			Archives=@Archives,DimissionTime=@DimissionTime,Remark=@EmpInCompanyRemark
		Where EmpID=@EmpID
	end

	--删除该员工的工种表
	delete From Emp_WorkType Where EmpID=@EmpID

	--插入员工工种表1
	if( @WorkTypeID1 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID1 ))
		begin
			insert into Emp_WorkType(EmpWorkTypeID,EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@EmpID,@WorkTypeID1,@IsMostly1,@IsEnable1)
	
		end
	end

end

end

end


--判断是否全部执行成功
if @@error=0


begin
	commit transaction EmpInfo_Trans
        
end

else
begin
	
	rollback TRANSACTION EmpInfo_Trans
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE   proc A_zjw_WorkType_Update
(
	@WorkTypeID int,
	@WtName nvarchar(50),
	@CerTypeID int,
	@Remark nvarchar(50),
	@MaxTimeSec int,
	@MinTimeSec int
)
as
begin


if( exists( Select 1 From dbo.WorkType_Info Where WorkTypeID=@WorkTypeID))
begin
	update WorkType_Info Set CerTypeID=@CerTypeID,Remark=@Remark,WtName=@WtName
	where WorkTypeID=@WorkTypeID

	if(exists (Select 1 From WorkType_SysSet Where WorkTypeID=@WorkTypeID))
	begin
		update WorkType_SysSet Set MaxTimeSec=@MaxTimeSec,MinTimeSec=@MinTimeSec
		where WorkTypeID=@WorkTypeID
	end
	else
	begin
		insert into WorkType_SysSet(WorkTypeSysSetID,WorkTypeID,MaxTimeSec,MinTimeSec)
		values(@WorkTypeID,@WorkTypeID,@MaxTimeSec,@MinTimeSec)
	end
	--更改与此工种绑定的最大工作时间的员工的最大工作时间
	update Emp_NowCompany
	Set MaxSecTime=@MaxTimeSec,MinSecTime=@MinTimeSec
	Where Selectmode=3 and EmpID in(Select EmpID From Emp_WorkType Where WorkTypeID = @WorkTypeID and IsEnable = 1)

end 
end 




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



-- 批量添加基站
CREATE        proc AddStationHead
@str varchar(3000),
-- 基站信息
@StationPlace nvarchar(30),
@StationTel nvarchar(20),
@StationTypeID int,
@StationType nvarchar(10),
@StationState int,
@EditBaseInfo int,
@StationGroup int
as
begin
	-- 定义要添加的基站地址 游标
	
	declare cr cursor for SELECT convert(int,col) FROM Array_Split(@str,',') 
	where col not in (select StationAddress from Station_Info)
	open cr
	declare @col int
	fetch next from cr into @col
	while @@fetch_status=0
	begin
		if len(@col) = 0 or @col is null
		begin
		-- 关闭游标
		close cr
		return
		end

		if not exists (select 1 from Station_Info where StationAddress = @col)
		begin
			declare @sp varchar(30)
			if @StationPlace = ''
				set @sp = @col
			else
				set @sp = @StationPlace
			
			-- 添加基站信息
			insert into Station_Info(StationAddress,StationPlace,StationTel,StationTypeID
			,StationType,StationState,EditBaseInfo,StationGroup)
			values(@col,@sp,@StationTel,@StationTypeID
			,@StationType,@StationState,@EditBaseInfo,@StationGroup)
		end
		fetch next from cr into @col
	end
	close cr
	deallocate cr
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc Associate_Delete
@id int
as
delete from Associate where id=@id and endTime>getdate()

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE proc [dbo].[Associate_Insert]
@stationAddress int,
@stationHeadAddress int,
@stationHeadPlace varchar(20),
@beginTime datetime,
@endTime datetime,
@empid1 int,
@empid2 int,
@empName1 varchar(20),
@empName2 varchar(20),
@ID int
as
declare @count int
select @count=count(1) from Associate where stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress and beginTime=@beginTime
	 and endTime=@endTime and empID1=@empid1 and empID2=@empid2
if @count<=0
begin
insert into Associate([id],stationAddress,stationHeadAddress,stationHeadPlace,beginTime,endTime,empID1,empID2,empName1,empName2,isFlagEmp1,isFlagEmp2)
values(@ID,@stationAddress,@stationHeadAddress,@stationHeadPlace,@beginTime,@endTime,@empid1,@empid2,@empName1,@empName2,1,1)
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc Associate_Logic
@DetectTime datetime,
@StationAddress int,
@StationHeadAddress int,
@Cards varchar(6000)
as
declare @count int
--获取时间范围内的数据
select @count=count(1) from Associate 
where stationAddress=@StationAddress and stationHeadAddress=@StationHeadAddress and beginTime<=@DetectTime and endTime>=@DetectTime
if(@count>0)
begin
	declare @CRADNO varchar(20)--发码器编号,对应了人的编号
	--定义游标
	declare AssociateInfo cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open AssociateInfo
	--移到下一行
	fetch next from AssociateInfo into @CRADNO
	while (@@FETCH_STATUS <> -1)
	begin
		if @CRADNO<>''
		begin
			--查找此@CRADNO对应的人的编号
			declare @EmpID int
			select @EmpID=UserID from CodeSender_Set  where CodeSenderAddress=convert(int,@CRADNO) and CsTypeId=0
			--执行修改
			exec Associate_Update @StationAddress,@StationHeadAddress,@DetectTime,@EmpID
		end
		fetch next from AssociateInfo into @CRADNO
	end
	--关闭游标
	close AssociateInfo
	--释放游标
	deallocate AssociateInfo
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc Associate_Update
@stationAddress int,
@stationHeadAddress int,
@time datetime,
@empid int
as
declare @count int
--获取在该时段内第一个人未按时进入的信息
select @count=count(1) from Associate 
	where stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress and empid1=@empid and begintime<@time and endTime>@time and isFlagEmp1=1
if @count>0
begin
	update Associate set isFlagEmp1=2
	where stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress and empid1=@empid and begintime<@time and endTime>@time and isFlagEmp1=1
end
else
begin
	--获取在该时段内第二个人未按时进入的信息
	select @count=count(1) from Associate 
		where stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress and empid2=@empid and begintime<@time and endTime>@time and isFlagEmp2=1
	if @count>0
	begin
		update Associate set isFlagEmp2=2
		where stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress and empid2=@empid and begintime<@time and endTime>@time and isFlagEmp2=1
	end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-- 修改创建分区视图
CREATE        proc Auto_Alter_His_View
as 
-- 自动修改历史视图
-- 历史存储信息
declare @TableName nvarchar(100)

declare @TableType int 
-- 1 His_InOutMine 
-- 2 His_InOutStation 
-- 3 His_InOutStationHead 
declare @TableTypeName nvarchar(20) 
declare @TableYear int
declare @TableMonth int
-- 探头
declare @InOutStationHeadSql varchar(8000)
-- 基站
declare @InOutStationSql varchar(8000)
--　进出井
declare @InOutMineSql varchar(8000)
-- 历史读卡分站方向性
declare @DirectionalAntenna varchar(8000)
-- 历史进出探头
declare @InOutReceiver varchar(8000)
-- 历史进出区域
declare @InOutArea varchar(8000)
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutStationHead]'))
	begin
	   set @InOutStationHeadSql='alter View His_InOutStationHead As '
	end
else
	begin
	   set @InOutStationHeadSql='Create View His_InOutStationHead As '
	end


if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutStation]'))
	begin
	    set @InOutStationSql='alter View His_InOutStation As '
	end
else
	begin

		set @InOutStationSql='Create View His_InOutStation As '
	end

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutMine]'))
	begin
		set @InOutMineSql='alter View His_InOutMine As '
	end
else
	begin
		set @InOutMineSql='Create View His_InOutMine As '
	end
-- 历史方向性
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_Directional]'))
	begin
		set @DirectionalAntenna='alter View His_Directional As '
	end
else
	begin
		set @DirectionalAntenna='Create View His_Directional As '
	end
--历史进出探头
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutReceiver]'))
	begin
		set @InOutReceiver='alter View His_InOutReceiver As '
	end
else
	begin
		set @InOutReceiver='Create View His_InOutReceiver As '
	end

--历史进出区域
if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_AreaDirection]'))
	begin
		set @InOutArea='alter View His_AreaDirection As '
	end
else
	begin
		set @InOutArea='Create View His_AreaDirection As '
	end
declare cr CURSOR FOR 
  select HisYear,HisMonth from HisDataConfig 
open cr
fetch next from Cr into @TableYear,@TableMonth
/*
fetch  from cr into 
 @TableYear,@TableMonth
*/

while @@fetch_status=0
begin     
      -- 历史进出探头表      
      set @TableName='His_InOutStationHead_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))

       print @TableName
       if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
       begin
	  set @InOutStationHeadSql=@InOutStationHeadSql+'Select * from '+@TableName+' Union All '
       end
     
     -- 历史进出基站
      set @TableName='His_InOutStation_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
     -- 历史进出基站视图
        if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
        begin
  	   set @InOutStationSql=@InOutStationSql+'Select * from '+@TableName+' Union All '
        end
     -- 历史上下井
      set @TableName='His_InOutMine_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
     -- 历史上下井视图
	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
        begin
     		 set @InOutMineSql=@InOutMineSql+'Select * From '+@TableName +' Union All '
	end
	-- 历史方向性
	set @TableName='His_Directional_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
       	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
       	begin
		set @DirectionalAntenna=@DirectionalAntenna+'Select * from '+@TableName+' Union All '
       	end
	-- 历史进出探头
	set @TableName='His_InOutReceiver_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
       	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
       	begin
		set @InOutReceiver=@InOutReceiver+'Select * from '+@TableName+' Union All '
       	end
	-- 历史进出区域方向
	set @TableName='His_AreaDirection_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
       	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
       	begin
		set @InOutArea=@InOutArea+'Select * from '+@TableName+' Union All '
       	end
	print @TableName
     -- 移动下一条
        fetch next from cr into 
                @TableYear,@TableMonth 	
end
	set @InOutStationHeadSql=@InOutStationHeadSql+'Select * from His_InOutStationHead_1'
	set @InOutStationSql=@InOutStationSql+'Select * from His_InOutStation_1'
	set @InOutMineSql=@InOutMineSql+'Select * from His_InOutMine_1'
	set @DirectionalAntenna=@DirectionalAntenna+'Select * from His_Directional_1'
	set @InOutReceiver=@InOutReceiver+'Select * from His_InOutReceiver_1'
     	set @InOutArea=@InOutArea+'Select * from His_AreaDirection_1'
 -- Set @SqlString=@SqlString+'Select * From InOutStationHead_1'
close cr
deallocate cr
exec (@InOutStationHeadSql)
exec (@InOutStationSql)
exec (@InOutMineSql)
exec (@DirectionalAntenna)
exec (@InOutReceiver)
exec (@InOutArea)
print @InOutStationHeadSql
print @InOutStationSql
print @InOutMineSql
print @DirectionalAntenna
print @InOutReceiver



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE     proc Auto_Delete_His_View
as 
-- 自动修改历史视图
-- 历史存储信息
declare @TableName nvarchar(100)

declare @TableType int 
-- 1 His_InOutMine 
-- 2 His_InOutStation 
-- 3 His_InOutStationHead 
declare @TableTypeName nvarchar(20) 
declare @TableYear int
declare @TableMonth int
-- 探头
declare @InOutStationHeadSql nvarchar(1000)
-- 基站
declare @InOutStationSql nvarchar(1000)
--　进出井
declare @InOutMineSql nvarchar(1000)

set @InOutStationHeadSql='alter View V_His_InOutStationHead As '
set @InOutStationSql='alter View V_His_InOutStation As '
set @InOutMineSql='alter View V_His_InOutMine As '
declare cr CURSOR FOR 
  select HisYear,HisMonth from HisDataConfig 
open cr
fetch next from Cr into @TableYear,@TableMonth
/*
fetch  from cr into 
 @TableYear,@TableMonth
*/
while @@fetch_status=0
begin     
      -- 历史进出探头表      
     set @TableName='His_InOutStationHead_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))

       print @TableName
       if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
       begin
           set @InOutStationHeadSql='drop Table '+@TableName
            exec (@InOutStationHeadSql)
	 -- set @InOutStationHeadSql=@InOutStationHeadSql+'Select * from '+@TableName+' Union All '
       end
     
     -- 历史进出基站
      set @TableName='His_InOutStation_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
     -- 历史进出基站视图
        if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
        begin
                set @InOutStationSql='drop Table '+@TableName
                exec (@InOutStationSql)
  	   -- set @InOutStationSql=@InOutStationSql+'Select * from '+@TableName+' Union All '
        end
     -- 历史上下井
      set @TableName='His_InOutMine_'+cast(@TableYear as nvarchar(4))+cast(@TableMonth as nvarchar(2))
     -- 历史上下井视图
	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@TableName+']'))
        begin
     		set  @InOutMineSql='Drop Table '+@TableName
                exec (@InOutMineSql)
		--set @InOutMineSql=@InOutMineSql+'Select * From '+@TableName +' Union All '
	end
     -- 移动下一条
        fetch next from cr into 
                @TableYear,@TableMonth 	
end
	set @InOutStationHeadSql=@InOutStationHeadSql+'Select * from His_InOutStationHead_1'
	set @InOutStationSql=@InOutStationSql+'Select * from His_InOutStation_1'
	set @InOutMineSql=@InOutMineSql+'Select * from His_InOutMine_1'
     
 -- Set @SqlString=@SqlString+'Select * From InOutStationHead_1'
close cr
deallocate cr
delete from HisDataConfig



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

-- 创建单张表
create proc CreateHis_AreaDirection
     @YearValue int,
     @MoonValue int
as

--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_AreaDirection_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_AreaDirection_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end
set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'
--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)
--print @EndTime 
set @SqlString='CREATE TABLE [His_AreaDirection_'+@TableName+'] ('

set @SqlString=@SqlString+'[id] [bigint] IDENTITY (1, 1) NOT NULL ,
	[AreaName] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[AreaTypeName] [varchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderAddress] [int] NULL ,
	[EmpName] [varchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[InTime] [datetime] not NULL ,
	[InDirection] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[OutDirection] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[OutTime] [datetime] NULL ,
	[AreaWorkTime] [bigint] NULL 
) ON [PRIMARY]'
exec (@SqlString)
set @SqlString='ALTER TABLE [dbo].[His_AreaDirection_'+@TableName+'] ADD
                PRIMARY KEY  CLUSTERED 
	(
		[id],
		[InTime]
	)  ON [PRIMARY],
        CHECK (InTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and InTime < '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
--' 23:59:59.999'+
exec (@SqlString)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create proc CreateHis_Directional
     @YearValue int,
     @MoonValue int
as

--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_Directional_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_Directional_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end
set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'

--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)

--print @EndTime 


set @SqlString='CREATE TABLE [His_Directional_'+@TableName+'] ('

set @SqlString=@SqlString+'[id] [int] IDENTITY (1, 1) NOT NULL ,
		[CodeSenderAddress] [int] NULL ,
		[DirectionalTitle] [varchar] (200) COLLATE Chinese_PRC_CI_AS NULL ,
		[DirectionalInfo] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
		[NowTime] [datetime] not NULL ,
		[CsTypeID] [int] NULL ,
		[name] [varchar] (20) COLLATE Chinese_PRC_CI_AS NULL 
	) ON [PRIMARY]'



exec (@SqlString)


set @SqlString='ALTER TABLE [dbo].[His_Directional_'+@TableName+'] ADD
                PRIMARY KEY  CLUSTERED 
	(
		[id],
		[NowTime]
	)  ON [PRIMARY],
        CHECK (NowTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and NowTime < '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
--' 23:59:59.999'+
exec (@SqlString)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE          proc CreateHis_InOutMine
     @YearValue int,
     @MoonValue int
as
--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_InOutMine_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutMine_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end
set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'

--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)

--print @EndTime 

set @SqlString='CREATE TABLE [His_InOutMine_'+@TableName+'] ('

set @SqlString=@SqlString+'[HisInOutMineID] [bigint] NOT NULL ,
	[InStationAddress] [int] NULL ,
	[InStationHeadAddress] [int] NULL ,
	[InWellPlace] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserID] [int] NULL ,
	[UserName] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderAddress] [int] NULL ,
	[InTime] [datetime] Not NULL,
	[OutStationAddress] [int] NULL ,
	[OutStationHeadAddress] [int] NULL ,
	[OutWellPlace] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[OutTime] [datetime] NULL ,
	[ContinueTime] [bigint] NULL
) ON [PRIMARY]'
exec (@SqlString)

set @SqlString='ALTER TABLE [dbo].[His_InOutMine_'+@TableName+'] ADD
          PRIMARY KEY  CLUSTERED 
	(
		[HisInOutMineID],
		[InTime]
	)  ON [PRIMARY],
        CHECK (InTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and InTime< '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
--' 23:59:59.999'+
exec (@SqlString)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

-- 创建单张表
create proc CreateHis_InOutReceiver
     @YearValue int,
     @MoonValue int
as

--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_InOutReceiver_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutReceiver_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end
set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'
--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)
--print @EndTime 
set @SqlString='CREATE TABLE [His_InOutReceiver_'+@TableName+'] ('

set @SqlString=@SqlString+'[id] [int] IDENTITY (1, 1) NOT NULL ,
	[CodeSenderAddress] [int] NULL ,
	[Name] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[Station] [int] NULL ,
	[StationHead] [int] NULL ,
	[StationHeadPlace] [varchar] (50) COLLATE Chinese_PRC_CI_AS NOT NULL ,
	[InTime] [datetime] NOT NULL ,
	[OutTime] [datetime] NULL ,
	[InDirection] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[OutDirection] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL 
) ON [PRIMARY]'
exec (@SqlString)
set @SqlString='ALTER TABLE [dbo].[His_InOutReceiver_'+@TableName+'] ADD
                PRIMARY KEY  CLUSTERED 
	(
		[id],
		[InTime]
	)  ON [PRIMARY],
        CHECK (InTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and InTime < '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
--' 23:59:59.999'+
exec (@SqlString)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE                proc CreateHis_InOutStation
     @YearValue int,
     @MoonValue int
as

--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_InOutStation_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutStation_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end
set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'

--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)

--print @EndTime 


set @SqlString='CREATE TABLE [His_InOutStation_'+@TableName+'] ('

set @SqlString=@SqlString+'[HisInStationID] [bigint] NOT NULL ,
	[StationAddress] [int] NULL ,
	[StationHeadAddress] [int] NULL ,
	[StationHeadAntennaA] [bit] NULL ,
	[StationHeadAntennaB] [bit] NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserID] [int] NULL ,
	[InStationAntenna] [int] NULL ,
	[StationHeadPlace] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[StationAntennaPlace] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderID] [int] NULL ,
	[CodeSenderAddress] [int] NULL ,
        [StationHeadDetectTime] [datetime] not NULL,
        )ON [PRIMARY]'
exec (@SqlString)


set @SqlString='ALTER TABLE [dbo].[His_InOutStation_'+@TableName+'] ADD
                PRIMARY KEY  CLUSTERED 
	(
		[HisInStationID],
		[StationHeadDetectTime]
	)  ON [PRIMARY],
        CHECK (StationHeadDetectTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and StationHeadDetectTime < '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
--' 23:59:59.999'+
exec (@SqlString)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE          proc CreateHis_InOutStationHead
     @YearValue int,
     @MoonValue int
    
as
-- 创建历史进出探头信息表
--创建历史分区表
Declare @TableName nvarchar(10) -- 历史数据表的名称
declare @StartTime DateTime -- 存储数据的开始时间

declare @EndTime DateTime -- 存储数据的结束时间
Declare @SqlString nvarchar(4000) -- 需要执行的SQL语句

declare @DropSql nvarchar(100) -- 删除数据表的SQL

set @TableName=cast(@YearValue as nvarchar(4))
              +cast(@MoonValue as nvarchar(2))
set @DropSql='DROP TABLE His_InOutStationHead_'+@TableName+''

if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[His_InOutStationHead_'+@TableName+']') 
and OBJECTPROPERTY(id, N'IsUserTable') = 1)
begin
  exec (@DropSql)
end


--print @TableName

set @StartTime=cast(@YearValue as nvarchar(4))+'-'+Cast(@MoonValue as nvarchar(2))
               +'-'+'1'

--print @StartTime
set @EndTime=dateadd(Month,1,@StartTime)

--print @EndTime 




set @SqlString='CREATE TABLE [dbo].[His_InOutStationHead_'+@TableName+'] ('

set @SqlString=@SqlString+'
	[HisStationHeadID] [bigint] NOT NULL ,
	[StationAddress] [int] NULL ,
	[StationHeadAddress] [int] NULL ,
	[StationHeadPlace] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderAddress] [int] NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserName] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[UserID] [int] NULL ,
	[InStationHeadTime] [datetime] not NULL ,
	[OutStationHeadTime] [datetime] not NULL 
	) ON [PRIMARY]'
exec (@SqlString)

set @SqlString='ALTER TABLE [dbo].[His_InOutStationHead_'+@TableName+'] ADD
        PRIMARY KEY  CLUSTERED 
	(
		[HisStationHeadID],
		[InStationHeadTime]
	)  ON [PRIMARY],
        CHECK (InStationHeadTime >=  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and InStationHeadTime <'''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2)) + ''')'
--+ ' 23:59:59.999'
exec (@SqlString)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--修改创建历史表
create  proc [dbo].[CreateHistory]
--创建历史数据表
  @DetectTime datetime  
as

Declare @temYear int  -- 年
Declare @temMonth int -- 月
Declare @i int
set @i=0
set @temYear=DatePart(year,@DetectTime)
set @temMonth=datePart(Month,@DetectTime)
-- 逻辑　如果在HisDataConfig存在,则返回,不存在，则创建这一年所有的表
if not exists 
(
select DISTINCT HisYear,HisMonth from HisDataConfig
       where HisYear=@temYear and HisMonth=@temMonth)
begin
        while (@i<12)
        begin
	        set @i=@i+1
            -- 创建历史进出探头表
	        exec CreateHis_InOutStationHead @temYear,@i
            -- 创建历史下井表
			exec CreateHis_InOutMine @temYear,@i
	        -- 向HisDataConfig插入记录数
	        Insert into HisDataConfig(HisYear,HisMonth)
	        values(@temYear,@i)
        end
        -- 自动创建历史数据的视图
        exec Auto_Alter_His_View
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--***********************************************************************************************************************--

--********************************************************************************************************************--
--修改创建历史表
CREATE  proc [dbo].[CreateHistoryDataTable]
--创建历史数据表
  @DetectTime datetime  
as

Declare @temYear int  -- 年
Declare @temMonth int -- 月
Declare @i int
set @DetectTime=getDate()
set @i=0
set @temYear=DatePart(year,@DetectTime)
set @temMonth=datePart(Month,@DetectTime)
-- 逻辑　如果在HisDataConfig存在,则返回,不存在，则创建这一年所有的表
if not exists 
(
select DISTINCT HisYear,HisMonth from HisDataConfig
       where HisYear=@temYear and HisMonth=@temMonth)
begin
        while (@i<12)
        begin
	        set @i=@i+1
            -- 创建历史进出探头表
	        exec CreateHis_InOutStationHead @temYear,@i
            -- 创建历史下井表
			exec CreateHis_InOutMine @temYear,@i
	        -- 向HisDataConfig插入记录数
	        Insert into HisDataConfig(HisYear,HisMonth)
	        values(@temYear,@i)
        end
                -- 自动创建历史数据的视图
                exec Auto_Alter_His_View

end


/*
	自动删除历史数据
*/
Declare @intMonth int	--删除历史数据(月份)

Declare @DeleteDateTime datetime	--要删除的数据时间

set @intMonth=(Select EnumValue From dbo.EnumTable where FunID=50 and EnumID=1)

if(@intMonth <> -1)		-- -1：手动删除，其他表示自动删除
begin
set @DeleteDateTime=DATEADD ( mm,-@intMonth,@DetectTime )

exec zjw_DeleteHisData @DeleteDateTime
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE       proc Create_AutoAlter_BaseData
-- 创建自动执行历史视图所需的基本数据
as

-- 创建HisDataConfig 表
CREATE TABLE [dbo].[HisDataConfig] (
	[ID] [int] IDENTITY (1, 1) NOT NULL ,
	[HisYear] [int] NULL ,
	[HisMonth] [int] NULL 
) ON [PRIMARY]



-- 创建x

declare @SqlString nvarchar(1000)

declare @StartTime datetime

declare @EndTime datetime

set @StartTime='1990-10-1'
set @EndTime='1990-10-20'



set @SqlString='CREATE TABLE [His_InOutMine_1] ('

set @SqlString=@SqlString+'[HisInOutMineID] [bigint] NOT NULL ,
	[InStationAddress] [int] NULL ,
	[InStationHeadAddress] [int] NULL ,
	[InWellPlace] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserID] [int] NULL ,
	[UserName] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderAddress] [int] NULL ,
	[InTime] [datetime] Not NULL,
	[OutStationAddress] [int] NULL ,
	[OutStationHeadAddress] [int] NULL ,
	[OutWellPlace] [nvarchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[OutTime] [datetime] NULL ,
	[ContinueTime] [bigint] NULL
) ON [PRIMARY]'
exec (@SqlString)

set @SqlString='ALTER TABLE [dbo].[His_InOutMine_1] ADD
          PRIMARY KEY  CLUSTERED 
	(
		[HisInOutMineID],
		[InTime]
	)  ON [PRIMARY],
        CHECK (InTime BETWEEN  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'

exec (@SqlString)



-- 创建His_InOutStation_1


set @SqlString='CREATE TABLE [His_InOutStation_1] ('

set @SqlString=@SqlString+'[HisInStationID] [bigint] NOT NULL ,
	[StationAddress] [int] NULL ,
	[StationHeadAddress] [int] NULL ,
	[StationHeadAntennaA] [bit] NULL ,
	[StationHeadAntennaB] [bit] NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserID] [int] NULL ,
	[InStationAntenna] [int] NULL ,
	[StationHeadPlace] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[StationAntennaPlace] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderID] [int] NULL ,
	[CodeSenderAddress] [int] NULL ,
        [StationHeadDetectTime] [datetime] not NULL,
        )ON [PRIMARY]'
exec (@SqlString)


set @SqlString='ALTER TABLE [dbo].[His_InOutStation_1] ADD
                PRIMARY KEY  CLUSTERED 
	(
		[HisInStationID],
		[StationHeadDetectTime]
	)  ON [PRIMARY],
        CHECK (StationHeadDetectTime BETWEEN  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'

exec (@SqlString)



-- 创建His_InOutStationHead_1
/*
declare @SqlString nvarchar(1000)

declare @StartTime datetime

declare @EndTime datetime

set @StartTime='1990-10-1'
set @EndTime='1990-10-20'
*/
set @SqlString='CREATE TABLE [dbo].[His_InOutStationHead_1] ('

set @SqlString=@SqlString+'
        [HisStationHeadID] [bigint] NOT NULL ,
	[StationAddress] [int] NULL ,
	[StationHeadAddress] [int] NULL ,
	[StationHeadPlace] [varchar] (50) COLLATE Chinese_PRC_CI_AS NULL ,
	[CodeSenderAddress] [int] NULL ,
	[CsSetID] [int] NULL ,
	[CsTypeID] [int] NULL ,
	[UserName] [nvarchar] (20) COLLATE Chinese_PRC_CI_AS NULL ,
	[UserID] [int] NULL ,
	[InStationHeadTime] [datetime] not NULL ,
	[OutStationHeadTime] [datetime] not NULL 
	) ON [PRIMARY]'
exec (@SqlString)

set @SqlString='ALTER TABLE [dbo].[His_InOutStationHead_1] ADD
        PRIMARY KEY  CLUSTERED 
	(
		[HisStationHeadID],
		[InStationHeadTime]
	)  ON [PRIMARY],
        CHECK (InStationHeadTime BETWEEN  '''
                +cast(datepart(year,@StartTime) as nvarchar(4))+'-'
		+cast(datepart(month,@StartTime) as nvarchar(2))+'-'
                +cast(datepart(day,@StartTime) as nvarchar(2))
                +''' and '''+ cast(datepart(year,@EndTime) as nvarchar(4))+'-'
		+cast(datepart(month,@EndTime) as nvarchar(2))+'-'
                +cast(datepart(day,@EndTime) as nvarchar(2))+''')'
exec (@SqlString)








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--删除实时岗位信息
create procedure DeleteRealTimePostInfoByID

--下面还有写入历史的参数，或在存储过程里面获取

--实时表中的ID
@id int

as

--根据实时信息查找出需要插入历史的信息
--写入历史（定义多个变量 或 select 语句插入）

--删除实时
delete RT_PostInfo where RTPostID = @id


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--删除行走异常配置信息
create procedure DeleteWalkConfigInfo
@id int 
as
delete WalkConfigInfo where WalkConfigId = @id

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  Proc GetPagingRecord
(
	@tblName	VarChar(255),		--表名或视图表
	@keyField	VarChar(255),		--主键
	@fieldList	VarChar(2000) = '*',	--欲选择字段列表
	@orderField	VarChar(255),		--排序字段
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸     
	@strWhere	VarChar(8000),		--条件
	@orderType	bit = 1			--排序,1,降序,0,升序
)
As
	SET NOCOUNT ON
	Declare @strSql VarChar(8000)

	--处理SQL中危险字符,并且将条件处理成易嵌入的形式     
	set @strWhere = replace(@strWhere,'''','''''')     
	set @strWhere = replace(@strWhere,'--','')     
	set @strWhere = replace(@strWhere,';','')     
	set @strSql = 'declare @CurPageNum int;'
	set @strSql = @strSql + 'declare @nextpagenum int;'
	set @strSql = @strSql + 'set @curpagenum = ' + cast(@PageIndex as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'set @nextpagenum = ' + cast(@PageIndex + 1 as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'declare @strSql varchar(6000);'     
	If @orderType = 1
	Begin
		Set @strSql = @strSql + 'set @strSql=''select '+ @fieldList + 
			' from(select top ''+cast(@nextpagenum as varchar)+'' * from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + 
			' desc)as a where ' + @keyField + ' not in(select top '' + cast(@curpagenum as varchar) + '' ' + 
			@keyField + ' from ' + @tblName + ' where ' + @strWhere + 'order by ' + 
			@orderField + ' desc)order by ' + @orderField + ' desc'';'   
	End
	Else
	Begin
		Set @strSql = @strSql + 'Set @strSql=''select ' + @fieldList + 
			' from (select top '' + cast(@nextpagenum as varchar) + '' * from ' + @tblName + 
			' where ' + @strWhere + ' order by ' + @orderField + ' asc)as a where ' + @keyField + 
			' not in (select top '' + cast(@curpagenum as varchar)+'' ' + @keyField + ' from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + ' asc)order by ' + @orderField + ' asc'';'
	End
	Set @strSql = @strSql + 'execute(@strSql)'
	Execute(@strSql)

	If (@strWhere = '')
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + '];''execute(@strSql);'
	Else
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + ']'+' where ' + @strWhere + ';''execute(@strSql);'
	Exec (@strSQL)







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO




CREATE   Proc GetPagingRecord2
(
	@tblName	VarChar(255),		--表名或视图表
	@keyField	VarChar(255),		--主键
	@fieldList	VarChar(2000) = '*',	--欲选择字段列表
	@orderField	VarChar(255),		--排序字段
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸     
	@strWhere	VarChar(8000),		--条件
	@orderType	bit = 1			--排序,1,降序,0,升序
)
As
	SET NOCOUNT ON
	Declare @strSql VarChar(8000)

	--处理SQL中危险字符,并且将条件处理成易嵌入的形式     
	set @strWhere = replace(@strWhere,'''','''''')     
	set @strWhere = replace(@strWhere,'--','')     
	set @strWhere = replace(@strWhere,';','')     
	set @strSql = 'declare @CurPageNum int;'
	set @strSql = @strSql + 'declare @nextpagenum int;'
	set @strSql = @strSql + 'set @curpagenum = ' + cast(@PageIndex as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'set @nextpagenum = ' + cast(@PageIndex + 1 as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'declare @strSql varchar(6000);'     
	If @orderType = 1
	Begin
		Set @strSql = @strSql + 'set @strSql=''select '+ @fieldList + 
			' from(select top ''+cast(@nextpagenum as varchar)+'' * from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + 
			' desc)as a where ' + @keyField + ' not in(select top '' + cast(@curpagenum as varchar) + '' ' + 
			@keyField + ' from ' + @tblName + ' where ' + @strWhere + 'order by ' + 
			@orderField + ' desc)order by ' + @orderField + ' desc'';'   
	End
	Else
	Begin
		Set @strSql = @strSql + 'Set @strSql=''select ' + @fieldList + 
			' from (select top '' + cast(@nextpagenum as varchar) + '' * from ' + @tblName + 
			' where ' + @strWhere + ' order by ' + @orderField + ' asc)as a where ' + @keyField + 
			' not in (select top '' + cast(@curpagenum as varchar)+'' ' + @keyField + ' from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + ' asc)order by ' + @orderField + ' asc'';'
	End
	Set @strSql = @strSql + 'execute(@strSql)'
	Execute(@strSql)

	If (@strWhere = '')
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(1) as Total from [' + @tblName + '];''execute(@strSql);'
	Else
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''Select Count(1) from (select '+@fieldList+' from ['+ @tblName +'] where ' + @strWhere +') As T'+ ';''execute(@strSql);'
	Exec (@strSQL)

	




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



CREATE  Proc GetPagingRecord_Shen
(
	@tblName	VarChar(255),		--表名或视图表
	@keyField	VarChar(255),		--主键
	@fieldList	VarChar(2000) = '*',	--欲选择字段列表
	@orderField	VarChar(255),		--排序字段
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸     
	@strWhere	VarChar(8000),		--条件
	@orderType	bit = 1			--排序,1,降序,0,升序
)
As
	SET NOCOUNT ON
	Declare @strSql VarChar(8000)

	--处理SQL中危险字符,并且将条件处理成易嵌入的形式     
	set @strWhere = replace(@strWhere,'''','''''')     
	set @strWhere = replace(@strWhere,'--','')     
	set @strWhere = replace(@strWhere,';','')     
	set @strSql = 'declare @CurPageNum int;'
	set @strSql = @strSql + 'declare @nextpagenum int;'
	set @strSql = @strSql + 'set @curpagenum = ' + cast(@PageIndex as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'set @nextpagenum = ' + cast(@PageIndex + 1 as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'declare @strSql varchar(6000);'     
	If @orderType = 1
	Begin
		Set @strSql = @strSql + 'set @strSql=''select '+ @fieldList + 
			' from(select top ''+cast(@nextpagenum as varchar)+'' * from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + 
			' desc)as a where ' + @keyField + ' not in(select top '' + cast(@curpagenum as varchar) + '' ' + 
			@keyField + ' from ' + @tblName + ' where ' + @strWhere + 'order by ' + 
			@orderField + ' desc)order by ' + @orderField + ' desc'';'   
	End
	Else
	Begin
		Set @strSql = @strSql + 'Set @strSql=''select ' + @fieldList + 
			' from (select top '' + cast(@nextpagenum as varchar) + '' * from ' + @tblName + 
			' where ' + @strWhere + ' order by ' + @orderField + ' asc)as a where ' + @keyField + 
			' not in (select top '' + cast(@curpagenum as varchar)+'' ' + @keyField + ' from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + ' asc)order by EmpName asc'';'
	End
	Set @strSql = @strSql + 'execute(@strSql)'
	Execute(@strSql)

	If (@strWhere = '')
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + '];''execute(@strSql);'
	Else
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + ']'+' where ' + @strWhere + ';''execute(@strSql);'
	Exec (@strSQL)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
2008-6-23 10:50:25
李乐
*/
CREATE procedure [dbo].[InsertCodeSenderSet]
--发码器ID 流水号
@CodeSenderID int,

--人员编号
@UserID int, 

--设置类型
@CsTypeID int
as

declare @count int 
set @count =(select count(1) from CodeSender_Set where CodeSenderID = @CodeSenderID)

if(@count>0)
begin
	print '记录已经存在'
end
else
begin

	Update CodeSender_Info set IsCodeSenderUser=1 where CodeSenderID = @CodeSenderID
		
	Insert Into CodeSender_Set(CodeSenderID,CodeSenderAddress,UserID,CsTypeID)
	select @CodeSenderID,CodeSenderAddress,@UserID,@CsTypeID
	from CodeSender_Info where CodeSenderID=@CodeSenderID

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--插入历史岗位信息
create procedure InsertHistoryPostInfo
@TerritorialID int,
@EmpID int,
@EmpName nvarchar(20),
@WorkTime int,
@BeginTime datetime,
@EndTime datetime,
@FactTime int,
@IsAlarm bit,
@DeptName nvarchar(20),
@WorkName nvarchar(20),
@DutyName nvarchar(20),
@TerritorialName nvarchar(20),
@CodeSenderAddress int,
@Meansure nvarchar(100)
as 
insert into His_PostInfo 
(TerritorialID,
EmpID,
EmpName,
WorkTime,
BeginTime,
EndTime,
FactTime,
IsAlarm,
DeptName,
WorkName,
DutyName,
TerritorialName,
CodeSenderAddress,
Meansure)

values 
(@TerritorialID,
@EmpID,
@EmpName,
@WorkTime,
@BeginTime,
@EndTime,
@FactTime,
@IsAlarm,
@DeptName,
@WorkName,
@DutyName,
@TerritorialName,
@CodeSenderAddress,
@Meansure)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--添加行走异常配置信息
CREATE procedure [dbo].[InsertWalkConfigInfo]

@EmpID int,

--第一个点（分站编号，探测器编号，天线A，天线B）
@FirstStationAddress int,
@FirstStationHeadAddress int,
@FirstStationHeadAntennaA bit,
@FirstStationHeadAntennaB bit,

--中间点（分站编号，探测器编号，天线A，天线B）
@MiddleStationAddress int,
@MiddleStationHeadAddress int,
@MiddleStationHeadAntennaA bit,
@MiddleStationHeadAntennaB bit,

--最后一个点（分站编号，探测器编号，天线A，天线B）
@LastStationAddress int,
@LastStationHeadAddress int,
@LastStationHeadAntennaA bit,
@LastStationHeadAntennaB bit,

--规定行走时长(以秒计算)
@TimeValue int

as


if (not 
exists(
select * from WalkConfigInfo where EmpID=@EmpID 
and FirstStationAddress = @FirstStationAddress 
and FirstStationHeadAddress = @FirstStationHeadAddress
and FirstStationHeadAntennaA = @FirstStationHeadAntennaA 
and FirstStationHeadAntennaB = @FirstStationHeadAntennaB

and MiddleStationAddress = @MiddleStationAddress 
and MiddleStationHeadAddress = @MiddleStationHeadAddress
and MiddleStationHeadAntennaA = @MiddleStationHeadAntennaA 
and MiddleStationHeadAntennaB = @MiddleStationHeadAntennaB

and LastStationAddress = @LastStationAddress 
and LastStationHeadAddress = @LastStationHeadAddress
and LastStationHeadAntennaA = @LastStationHeadAntennaA 
and LastStationHeadAntennaB = @LastStationHeadAntennaB
)
)
begin

insert into WalkConfigInfo(EmpID,FirstStationAddress,FirstStationHeadAddress,FirstStationHeadAntennaA,FirstStationHeadAntennaB,
MiddleStationAddress,MiddleStationHeadAddress,MiddleStationHeadAntennaA,MiddleStationHeadAntennaB,
LastStationAddress,LastStationHeadAddress,LastStationHeadAntennaA,LastStationHeadAntennaB,TimeValue) 

values (@EmpID,@FirstStationAddress,@FirstStationHeadAddress,@FirstStationHeadAntennaA,@FirstStationHeadAntennaB,
@MiddleStationAddress,@MiddleStationHeadAddress,@MiddleStationHeadAntennaA,@MiddleStationHeadAntennaB,
@LastStationAddress,@LastStationHeadAddress,@LastStationHeadAntennaA,@LastStationHeadAntennaB,@TimeValue)  

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc KJ128N_AlarmSet_UpDate
(
  @AlarmSetType int,
  @EnumValue nvarchar(20),
  @AlarmWaveType int,
  @AlarmWavePath nvarchar(100)
)
as
begin
  update EnumTable set EnumValue=@EnumValue where FunID=12 and EnumID=@AlarmSetType

  if((select count(*) from AlarmSet where AlarmSetType=@AlarmSetType)>0)
    begin
	update AlarmSet
	set AlarmWaveType=@AlarmWaveType,AlarmWavePath=@AlarmWavePath
	where AlarmSetType=@AlarmSetType
  end
  else
    begin
	insert into AlarmSet
	    (AlarmSetType,AlarmWaveType,AlarmWavePath)
	values
	    (@AlarmSetType,@AlarmWaveType,@AlarmWavePath)
    end


end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE      proc KJ128N_CodeAlarmElectricity_Select
@CodeSenderStateID int
as

select Csi.CodeSenderAddress as 发码器,--AlarmElectricity,UserID,CsTypeID,
Et.Title as 发码器状态,
配置类型= case when CsTypeID=0 then '人员' when CsTypeID=1 then '设备' else '' end,
名称=case when CsTypeID=0 then EmpName when CsTypeID=1 then EquName else '' end,
部门=case when CsTypeID=0 then Di1.DeptName else '' end
from CodeSender_Info as Csi left join CodeSender_Set as Css on Csi.CodeSenderAddress =Css.CodeSenderAddress
left join Emp_Info as Ei on Ei.EmpID=Css.UserID and CsTypeID=0
left join Emp_NowCompany as Enc on Enc.EmpID=Ei.EmpID
left join Dept_Info as Di1 on Di1.DeptID=Enc.DeptID
left join Equ_BaseInfo as Ebi on Ebi.EquID=Css.UserID and Css.CsTypeID=1
left join Dept_Info as Di2 on Di2.DeptID=Ebi.DeptID
left join EnumTable as Et on Et.EnumID=Csi.CodeSenderStateID and Et.FunID=2
where Csi.CodeSenderStateID = @CodeSenderStateID





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE      proc KJ128N_CodeSender_Info_Insert
(
@CodeSender int,
@CodeSenderStateID int,
@Remark Nvarchar(200)
)
as


if  (Select Count(CodeSenderAddress) From CodeSender_Info Where CodeSenderAddress=@CodeSender) < 1
begin 
Insert Into CodeSender_Info
(CodeSenderAddress,CodeSenderStateID,IsCodeSenderUser,Remark)
values
(@CodeSender,@CodeSenderStateID,2,@Remark)
End








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE      proc KJ128N_CodeSender_Set_Insert
   @CodeSenderID int,
   @CodeSender int,
   @UserID int,
   @CsTypeID int
as
if(Select Count(CodeSenderAddress) from dbo.CodeSender_Set where CodeSenderAddress=@CodeSender)<1
begin
insert into CodeSender_Set
	(CodeSenderID,CodeSenderAddress,UserID,CsTypeID)values
	(@CodeSenderID,@CodeSender,@UserID,@CsTypeID)
Update  dbo.CodeSender_Info
	set IsCodeSenderUser=1
        where CodeSenderAddress	=@CodeSender

end







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create proc KJ128N_Delete_SpecialWorkTypeTerrial @ID int
as 

Delete SpecialWorkTypeTerrialSet where TerriAlarmID = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





--删除单个接收器
CREATE proc KJ128N_Delete_StationHead
	@StationHeadID int
as

   declare @StationAddress int
   declare @StationHeadAddress int
   -- 删除接收器信息 
begin
   delete from Station_Head_Info where StationHeadID=@StationHeadID
   -- 删除与接收器相关的实时数据信息
   select @StationAddress=StationAddress,@StationHeadAddress=StationHeadAddress 
   from Station_Head_Info where StationHeadID=@StationHeadID
   Delete From RT_InOUtStation 
   Where StationAddress = @StationAddress and StationHeadAddress = @StationHeadAddress
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE   proc KJ128N_Dept_Detail_Insert
(
  @DeptID int,
  @DeptTel1 nvarchar(20),
  @DeptTel2 nvarchar(20),
  @DeptFax nvarchar(20),
  @DeptPost nvarchar(6),
  @DeptAddress nvarchar(250),
  @DeptEmail nvarchar(100)
)
As

	
begin
Insert into [Dept_Detail]
(DeptID,DeptTel1,DeptTel2,DeptFax,DeptPost,DeptAddress,DeptEmail)
values
(@DeptID,@DeptTel1,@DeptTel2,@DeptFax,@DeptPost,@DeptAddress,@DeptEmail)


end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE    proc KJ128N_Dept_Detail_InsertAndUpdate
(
  @DeptNO nvarchar(20),
  @DeptTel1 nvarchar(20),
  @DeptTel2 nvarchar(20),
  @DeptFax nvarchar(20),
  @DeptPost nvarchar(6),
  @DeptAddress nvarchar(250),
  @DeptEmail nvarchar(100)
)
As
	
begin
declare @DeptID int
select @DeptID = DeptID from Dept_Info where DeptNO = @DeptNO

if((select count(*) from Dept_Detail where DeptID=@DeptID)>0)
	begin
		Update Dept_Detail 
		   set DeptTel1=@DeptTel1,DeptTel2=@DeptTel2,DeptFax=@DeptFax,
		       DeptPost=@DeptPost,DeptAddress=@DeptAddress,DeptEmail=@DeptEmail
		where DeptID=@DeptID
	end
else
	begin
		Insert into [Dept_Detail]
		(DeptID,DeptTel1,DeptTel2,DeptFax,DeptPost,DeptAddress,DeptEmail)
		values
		(@DeptID,@DeptTel1,@DeptTel2,@DeptFax,@DeptPost,@DeptAddress,@DeptEmail)
	end

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO











CREATE   proc KJ128N_Dept_Info_Insert
(
  @ParentDeptID int,
  @DeptLevelID int,
  @DeptNO nvarchar(20),
  @DeptName nvarchar(20),
  @Remark nvarchar(200),
  @ClassID int,
@SerialNo int
)
As

	
begin
Insert into [Dept_Info]
(ParentDeptID,DeptLevelID,DeptNO,DeptName,Remark,ClassID,SerialNo)
values
(@ParentDeptID,@DeptLevelID,@DeptNO,@DeptName,@Remark,@ClassID,@SerialNo)


end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE  proc KJ128N_Dept_Info_Select_TreeView
As
select * from Dept_Info order by DeptLevelID,DeptId






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO








CREATE         proc KJ128N_Dept_Lead_Insert
(
  @DeptNO nvarchar(20),
  @EmpID int,
  @LeadDateTime datetime
)
As

declare @DeptID int
select @DeptID = DeptID from Dept_Info where DeptNO = @DeptNO

if((select count(*) from Dept_Lead where DeptID=@DeptID)>0)
begin
	begin
		if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

	end
	update Dept_Lead 
	set EmpID=@EmpID,LeadDateTime=@LeadDateTime
	where DeptID = @DeptID
end
else
begin
	begin
		if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

	end
	begin
	Insert into [Dept_Lead]
	    (DeptID,EmpID,LeadDateTime)
	values
	    (@DeptID,@EmpID,@LeadDateTime)

end
end











GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO










CREATE   proc KJ128N_Dept_Lead_UpDate
(
  @DeptID int,
  @EmpID int,
  @LeadDateTime datetime
)
As
begin
	begin
	  if @LeadDateTime='1800-01-01' 
	  begin
	    set @LeadDateTime=null
	  end	
	end
begin
update [Dept_Lead]
set
	EmpID=@EmpID,
	LeadDateTime=@LeadDateTime
where DeptID=@DeptID
end
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO














CREATE         proc KJ128N_Display_UpDate
(
  @DisplayFun nvarchar(20),
  @PpageSum nvarchar(20),
  @Vartical nvarchar(20),
  @LeftVartical nvarchar(20),
  @TopVartical nvarchar(20),
  @DisplayType nvarchar(20),
  @HeadDisplayType nvarchar(20),
  @DisplayDept nvarchar(20),
  @DisplayDirectional nvarchar(20),
  @SizeX nvarchar(20),
  @SizeY nvarchar(20),
  @OutWellTime nvarchar(20)
)
As
begin
  update dbo.EnumTable Set EnumValue=@DisplayFun where FunID=46 and EnumID=1
  update dbo.EnumTable Set EnumValue=@PpageSum where FunID=46 and EnumID=2
  update dbo.EnumTable Set EnumValue=@Vartical where FunID=46 and EnumID=3
  update dbo.EnumTable Set EnumValue=@LeftVartical where FunID=46 and EnumID=4
  update dbo.EnumTable Set EnumValue=@TopVartical where FunID=46 and EnumID=5 
    
  update dbo.EnumTable Set EnumValue=@DisplayType where FunID=46 and EnumID=6
  update dbo.EnumTable Set EnumValue=@HeadDisplayType where FunID=46 and EnumID=7 
  update dbo.EnumTable Set EnumValue=@DisplayDept where FunID=46 and EnumID=8
  update dbo.EnumTable Set EnumValue=@DisplayDirectional where FunID=46 and EnumID=9 
  update dbo.EnumTable Set EnumValue=@SizeX where FunID=46 and EnumID=10
  update dbo.EnumTable Set EnumValue=@SizeY where FunID=46 and EnumID=11
  update dbo.EnumTable Set EnumValue=@OutWellTime where FunID=14 and EnumID=0
end












GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO










CREATE proc KJ128N_Emp_Detail_Insert
(
  @EmpID int,
  @Nation nvarchar(30),
  @WedlockID int,
  @ClanID int,
  @NativePlace nvarchar(50),
  @CensusRegister nvarchar(50),
  @SchoolRecordID int,
  @GraduateFrom nvarchar(35),
  @Specialty nvarchar(50),
  @OfficialDesignation nvarchar(50),
  @Remark nvarchar(200),
  @BirthDay datetime,
  @IDcard nvarchar(20),
  @PhotoID int

)
As
begin
  begin 
    if @BirthDay='1800-01-01'
	begin
		set @BirthDay=null
	end
    if @PhotoID=-1
	begin
		set @PhotoID=null
	end

  end
  begin
    Insert into [Emp_Detail]
      (EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,GraduateFrom,Specialty,OfficialDesignation,Remark,BirthDay,IDcard,PhotoID)
    values
      (@EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,@GraduateFrom,@Specialty,@OfficialDesignation,@Remark,@BirthDay,@IDcard,@PhotoID)
  end
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE    proc KJ128N_Emp_Detail_InsertAndUpDate
(
  @EmpNO nvarchar(10),
  @Nation nvarchar(30),
  @WedlockID int,
  @ClanID int,
  @NativePlace nvarchar(50),
  @CensusRegister nvarchar(50),
  @SchoolRecordID int,
  @GraduateFrom nvarchar(35),
  @Specialty nvarchar(50),
  @OfficialDesignation nvarchar(50),
  @Remark nvarchar(200),
  @BirthDay datetime,
  @IDcard nvarchar(20)

)
As
begin

DECLARE @EmpID int
declare @PhotoID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO
if(exists(select 1 FROM Emp_Photo WHERE EmpID = @EmpID))
begin
	select @PhotoID = PhotoID from Emp_Photo where EmpID = @EmpID
end
else
begin
	set @PhotoID=null
end

  begin 
    if @BirthDay='1800-01-01'
	begin
		set @BirthDay=null
	end
  end
  begin
    if((select count(*) from Emp_Detail ED  where EmpID=@EmpID)>0)
	begin
	update [Emp_Detail]
  	set  Nation=@Nation,WedlockID=@WedlockID,ClanID=@ClanID,NativePlace=@NativePlace,
	     CensusRegister=@CensusRegister,SchoolRecordID=@SchoolRecordID,GraduateFrom=@GraduateFrom,
	     Specialty=@Specialty,OfficialDesignation=@OfficialDesignation,Remark=@Remark,
	     BirthDay=@BirthDay,IDcard=@IDcard,PhotoID=@PhotoID
	where EmpID =@EmpID 
	end
    else
	begin
        Insert into [Emp_Detail]
          (EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,GraduateFrom,Specialty,OfficialDesignation,Remark,BirthDay,IDcard,PhotoID)
        values
          (@EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,@GraduateFrom,@Specialty,@OfficialDesignation,@Remark,@BirthDay,@IDcard,@PhotoID)
  	end
  end
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO











CREATE      proc KJ128N_Emp_Detail_UpDate
(
  @EmpID int,
  @Nation nvarchar(30),
  @WedlockID int,
  @ClanID int,
  @NativePlace nvarchar(50),
  @CensusRegister nvarchar(50),
  @SchoolRecordID int,
  @GraduateFrom nvarchar(35),
  @Specialty nvarchar(50),
  @OfficialDesignation nvarchar(50),
  @Remark nvarchar(200),
  @BirthDay datetime,
  @IDcard nvarchar(20),
  @PhotoID int

)
As
begin
  begin 
    if @BirthDay='1800-01-01'
	begin
		set @BirthDay=null
	end
    if @PhotoID=-1
	begin
		set @PhotoID=null
	end
  end
  begin
    update [Emp_Detail]
  	set  Nation=@Nation,WedlockID=@WedlockID,ClanID=@ClanID,NativePlace=@NativePlace,
	     CensusRegister=@CensusRegister,SchoolRecordID=@SchoolRecordID,GraduateFrom=@GraduateFrom,
	     Specialty=@Specialty,OfficialDesignation=@OfficialDesignation,Remark=@Remark,
	     BirthDay=@BirthDay,IDcard=@IDcard,PhotoID=@PhotoID
	where EmpID =@EmpID 
  end
end









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE    proc KJ128N_Emp_Health_InsertAndUpDate
(
  @EmpNO nvarchar(10),
  @Height int,
  @Weight int,
  @StateOfHealth nvarchar(200)
)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO

  if((select count(*) From Emp_Health Where EmpID=@EmpID)>0)
	begin
		update Emp_Health 
		set Height=@Height,Weight=@Weight,StateOfHealth=@StateOfHealth
		where EmpID = @EmpID
	end
  else
	begin
		Insert into [Emp_Health]
 		    (EmpID,Height,Weight,StateOfHealth)
		values
		    (@EmpID,@Height,@Weight,@StateOfHealth)
	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE   proc KJ128N_Emp_Home_Insert
(
  @EmpID int,
  @HomeTel1 nvarchar(20),
  @HomeTel2 nvarchar(20),
  @HomeAddress nvarchar(250),
  @Postalcode nvarchar(6),
  @Remark nvarchar(200)

)
As

	
begin
Insert into [Emp_Home]
(EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
values
(@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@Remark)


end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO










CREATE     proc KJ128N_Emp_Home_InsertAndUpDate
(
  @EmpNO NVARCHAR(10),
  @HomeTel1 nvarchar(20),
  @HomeTel2 nvarchar(20),
  @HomeAddress nvarchar(250),
  @Postalcode nvarchar(6),
  @Remark nvarchar(200)

)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO

  if(select count(*) From Emp_Home Where EmpID=@EmpID)>0
	begin
		update Emp_Home 
		set HomeTel1=@HomeTel1,HomeTel2=@HomeTel2,HomeAddress=@HomeAddress,Postalcode=@Postalcode,Remark=@Remark 
		where EmpID = @EmpID
	end
  else
	begin
		Insert into [Emp_Home]
	   	   (EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
		values
  	     	   (@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@Remark)
	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE     proc KJ128N_Emp_InCompany_Insert
(
  @EmpID int,
  @ProbationDate datetime,
  @OfficiallyDate datetime,
  @ContractExpDate datetime,
  @ContractExpAppendDate datetime,
  @IsGearShift bit,
  @HireTypeID int,
  @Archives nvarchar(100),
  @DimissionTime datetime,
  @Remark nvarchar(200)
)
As
begin
	begin
		if @ProbationDate='1800-01-01' 
			begin
				set @ProbationDate=null
			end	
		if @OfficiallyDate='1800-01-01' 
		begin
			set @OfficiallyDate=null
		end
		if @ContractExpDate='1800-01-01' 
		begin
			set @ContractExpDate=null
		end
		if @ContractExpAppendDate='1800-01-01' 
		begin
			set @ContractExpAppendDate=null
		end
		if @DimissionTime='1800-01-01' 
		begin
			set @DimissionTime=null
		end

	end
begin
Insert into [Emp_InCompany]
(EmpID,ProbationDate,OfficiallyDate,ContractExpDate,ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
values
(@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@Remark)

end
end







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE       proc KJ128N_Emp_InCompany_InsertAndUpDate
(
  @EmpNO NVARCHAR(10),
  @ProbationDate datetime,
  @OfficiallyDate datetime,
  @ContractExpDate datetime,
  @ContractExpAppendDate datetime,
  @IsGearShift bit,
  @HireTypeID int,
  @Archives nvarchar(100),
  @DimissionTime datetime,
  @Remark nvarchar(200)
)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO
	begin
		if @ProbationDate='1800-01-01' 
			begin
				set @ProbationDate=null
			end	
		if @OfficiallyDate='1800-01-01' 
		begin
			set @OfficiallyDate=null
		end
		if @ContractExpDate='1800-01-01' 
		begin
			set @ContractExpDate=null
		end
		if @ContractExpAppendDate='1800-01-01' 
		begin
			set @ContractExpAppendDate=null
		end
		if @DimissionTime='1800-01-01' 
		begin
			set @DimissionTime=null
		end

	end
if((select count(*) From Emp_InCompany Where EmpID=@EmpID)>0)
	begin
		update [Emp_InCompany]
		set  ProbationDate=@ProbationDate,OfficiallyDate=@OfficiallyDate,ContractExpDate=@ContractExpDate,
	     	     ContractExpAppendDate=@ContractExpAppendDate,IsGearShift=@IsGearShift,HireTypeID=@HireTypeID,
	    	     Archives=@Archives,DimissionTime=@DimissionTime,Remark=@Remark
		where  EmpID=@EmpID
    	end
else
	begin
	   	Insert into [Emp_InCompany]
		  (EmpID,ProbationDate,OfficiallyDate,ContractExpDate,ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
		values
		  (@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@Remark)
		end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE    proc KJ128N_Emp_InCompany_UpDate
(
  @EmpID int,
  @ProbationDate datetime,
  @OfficiallyDate datetime,
  @ContractExpDate datetime,
  @ContractExpAppendDate datetime,
  @IsGearShift bit,
  @HireTypeID int,
  @Archives nvarchar(100),
  @DimissionTime datetime,
  @Remark nvarchar(200)
)
As
begin
	begin
		if @ProbationDate='1800-01-01' 
			begin
				set @ProbationDate=null
			end	
		if @OfficiallyDate='1800-01-01' 
		begin
			set @OfficiallyDate=null
		end
		if @ContractExpDate='1800-01-01' 
		begin
			set @ContractExpDate=null
		end
		if @ContractExpAppendDate='1800-01-01' 
		begin
			set @ContractExpAppendDate=null
		end
		if @DimissionTime='1800-01-01' 
		begin
			set @DimissionTime=null
		end

	end
begin
    update [Emp_InCompany]
	set  ProbationDate=@ProbationDate,OfficiallyDate=@OfficiallyDate,ContractExpDate=@ContractExpDate,
	     ContractExpAppendDate=@ContractExpAppendDate,IsGearShift=@IsGearShift,HireTypeID=@HireTypeID,
	     Archives=@Archives,DimissionTime=@DimissionTime,Remark=@Remark
	where  EmpID=@EmpID
    end
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE      proc KJ128N_Emp_Info_Insert
(
  @EmpName nvarchar(20),
  @EmpNo nvarchar(10),
  @Sex bit,
  @Remark nvarchar(200)
)
As


begin

Insert into [Emp_Info]
(EmpName,Sex,Remark,EmpNO)
values
(@Empname,@Sex,@Remark,@EmpNO)


end











GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE  proc KJ128N_Emp_NowCompany_Insert
(
  @EmpID int,
  @DeptID int,
  @DutyID int,
  @Remark nvarchar(200)

)
As

	
begin
Insert into [Emp_NowCompany]
(EmpID,DeptID,DutyID,Remark)
values
(@EmpID,@DeptID,@DutyID,@Remark)


end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE      proc KJ128N_Emp_NowCompany_InsertAndUpDate
(
  @EmpNO nvarchar(10),
  @DeptID int,
  @DutyID int,
  @MaxSecTime int,
  @MinSecTime int,
  @Selectmode int,
  @Remark nvarchar(200),
  @ClassGroup nvarchar(50),
  @WorkPlace nvarchar(50)
)
As
Declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO

if @DeptID=0
	set @DeptID=null

if @DutyID=0
	set @DutyID=null

begin
  if((select count(*) From Emp_NowCompany Where EmpID=@EmpID)>0)
	begin
		update Emp_NowCompany 
		set DeptID=@DeptID,DutyID=@DutyID,MaxSecTime=@MaxSecTime,MinSecTime=@MinSecTime,Selectmode=@Selectmode,Remark=@Remark,
			ClassGroup=@ClassGroup, WorkPlace=@WorkPlace
		where EmpID = @EmpID
	end
  else
	begin
		Insert into [Emp_NowCompany]
 		    (EmpID,DeptID,DutyID,MaxSecTime,MinSecTime,Selectmode,Remark,ClassGroup,WorkPlace)
		values
		    (@EmpID,@DeptID,@DutyID,@MaxSecTime,@MinSecTime,@Selectmode,@Remark,@ClassGroup,@WorkPlace)
	end
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE    proc KJ128N_Emp_Photo_Insert
(
  @EmpNO nvarchar(10),
  @Photo image,
  @Remark nvarchar(100)

)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO
    Insert into [Emp_Photo]
      (EmpID,Photo,Remark)
    values
      (@EmpID,@Photo,@Remark)
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE   proc KJ128N_Emp_Photo_UpDate
(
  @PhotoID int,
  @EmpNO nvarchar(10),
  @Photo image,
  @Remark nvarchar(100)

)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO

    UpDate [Emp_Photo]
      set PhotoID=@PhotoID,EmpID=@EmpID,Photo=@Photo,Remark=@Remark
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE  proc KJ128N_Emp_Search_Insert
(
  @EmpID int,
  @EmpTel1 nvarchar(20),
  @EmpTel2 nvarchar(20),
  @EmpTel3 nvarchar(20),
  @EmpQQ nvarchar(20),
  @EmpMsn nvarchar(100),
  @HomePage nvarchar(200),
  @EmpEmail nvarchar(80),
  @EmpEmailBackup nvarchar(80),
  @Remark nvarchar(200)

)
As

	
begin
Insert into [Emp_Search]
(EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,EmpEmail,EmpEmailBackup,Remark)
values
(@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,@EmpEmail,@EmpEmailBackup,@Remark)


end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE    proc KJ128N_Emp_Search_InsertAndUpDate
(
  @EmpNO nvarchar(10),
  @EmpTel1 nvarchar(20),
  @EmpTel2 nvarchar(20),
  @EmpTel3 nvarchar(20),
  @EmpQQ nvarchar(20),
  @EmpMsn nvarchar(100),
  @HomePage nvarchar(200),
  @EmpEmail nvarchar(80),
  @EmpEmailBackup nvarchar(80),
  @Remark nvarchar(200)

)
As
begin
declare @EmpID int
select @EmpID = EmpID from Emp_Info where EmpNO = @EmpNO
  if((select count(*) From Emp_Search Where EmpID=@EmpID)>0)
	begin
		update Emp_Search 
		set EmpTel1=@EmpTel1,EmpTel2=@EmpTel2,EmpTel3=@EmpTel3,EmpQQ=@EmpQQ,EmpMsn=@EmpMsn,HomePage=@HomePage,EmpEmail=@EmpEmail,EmpEmailBackup=@EmpEmailBackup,Remark=@Remark 
		where EmpID = @EmpID
	end
  else
	begin
		Insert into [Emp_Search]
 		    (EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,EmpEmail,EmpEmailBackup,Remark)
		values
		    (@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,@EmpEmail,@EmpEmailBackup,@Remark)
	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE PROCEDURE KJ128N_Emp_SelectByDept As
Select EmpID, 员工姓名, DeptID, 部门名称 From KJ128N_Emp_Table where EmpID in (select css.UserID from RT_InOutMine RT left join CodeSender_Set css on RT.CodeSenderAddress = css.CodesenderAddress ) Order By 部门名称





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








--插入部门设置信息表
CREATE    proc KJ128N_Emp_SysSet_Insert
(
  @DeptNO NVARCHAR(20),
  @MaxTimeSec int,
  @MinTimeSec int
)
As
declare @DeptID int
select @DeptID = deptID from Dept_Info where DeptNO = @DeptNO

if(not exists(select 1 from Dept_SysSet where DeptID = @DeptID ))

begin
Insert into [Dept_SysSet]
(DeptID,MaxTimeSec,MinTimeSec)
values
(@DeptID,@MaxTimeSec,@MinTimeSec)
end	



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



-- 根据FunID ，列出某一功能项的枚举值
CREATE  proc KJ128N_EnumTable_FunID_List
(
	@FunID int

)
as
Select Title from EnumTable where FunID=@FunID order by EnumID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


-- strEquNO, strEquName, intDeptID, intEquType, intEquState, intFactoryID, strRemark

CREATE Proc KJ128N_Equ_Add
(
	@strEquNO varchar(15),
	@strEquName varchar(50),
	@intDeptID int,
	@intEquType int,
	@intEquState int,
	@intFactoryID int,
	@strRemark varchar(100)
)
AS
-- 判断 FactoryInfo 表中是否有传入的intFactoryID存在

if (select Count(1) from FactoryInfo where FactoryID =@intFactoryID)  = 0    

begin
	if (select Count(1) from FactoryInfo where FactoryNO = '无' and FactoryName ='未知'and FactoryAddress ='无') < 1
	begin
		-- 添加了在获取 FactoryID
		-- 向 FactoryInfo 加一条为 ‘无’的数据 并获得 FactoryID 
		INSERT INTO [KJ128N2].[dbo].[FactoryInfo]( [FactoryNO], [FactoryName],FactoryAddress)
VALUES('无','未知','无')
	end
 		set @intFactoryID = (select FactoryID from FactoryInfo where FactoryNO = '无' and FactoryName ='未知'and FactoryAddress ='无')
end

insert into Equ_BaseInfo(EquNO,EquName,DeptID,EquType,EquState,FactoryID,Remark) 

select @strEquNO,@strEquName,@intDeptID,@intEquType,@intEquState,@intFactoryID,@strRemark  from (select @strEquNO as EquNo ,Count(1) as iCount From Equ_BaseInfo Where EquNo = @strEquNO ) 

AS Tmp where iCount < 1 



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  Proc KJ128N_Equ_Del
(
	@EquID int
)
as
delete from dbo.Equ_BaseInfo where EquID = @EquID

delete from dbo.Equ_DetailInfo where EquID = @EquID

delete from dbo.CodeSender_Set where UserID=@EquID and CsTypeID=1



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc KJ128N_Equ_Query
(
 @strEquWhere varchar(2000) ,
 @strFactroyWhere varchar(2000)
)

AS

SELECT EquID, EquNO, EquName, 

IsNull(Dept_Info.DeptName, '未知') as DeptID, 

IsNull (enumType.Title, '未知') as EquType,

IsNull (enumState.Title,'未知') as EquState,

IsNull (factory.FactoryName,'未知') as FactoryID,

Equ_BaseInfo.Remark FROM ( select * from Equ_BaseInfo Where EquName  Like dbo.IsEmptyOrNull( '%'+@strEquWhere+'%','%')) As Equ_BaseInfo

left JOIN Dept_Info ON Equ_BaseInfo.DeptID = Dept_Info.DeptID 
left join (select * from dbo.EnumTable where FunID =9) enumType on enumType.EnumID = EquType 
left join (select * from dbo.EnumTable where FunID =10) enumState on enumState.EnumID = EquState 
left join FactoryInfo factory on factory.FactoryID = Equ_BaseInfo.FactoryID


select * from FactoryInfo where FactoryID Like dbo.IsEmptyOrNull(@strFactroyWhere ,'%') 
 and FactoryName <> '未知' and FactoryNO <>'无'






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  PROCEDURE KJ128N_GetEmployeeInfoDetail_ByEmpID @EmpID int  AS 
select * from View_EmployeeInfo_Detail where EmpID = @EmpID



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE   procedure KJ128N_GetHistoryInOutStationHead
(
@fieldList varchar(2000),		--查询类型，‘人员’或‘设备’
@PageIndex int,				--页号,从0开始
@PageSize int,				--页尺寸
@strWhere varchar(8000),		--条件（不包括时间和CsTypeID）
@TimeStation varchar(255)		--查询时间条件和CsTypeID
)
as


/*
DECLARE @fieldList varchar(2000)
DECLARE @PageIndex int
DECLARE @PageSize int
DECLARE @strWhere varchar(8000)
DECLARE @TimeStation varchar(255)

set @fieldList='设备'
set @PageIndex=1
set @PageSize=10  --Et.FunID = 4 and and Ei.EmpName like ''%李%'' Hi.CsTypeID = 0 and Hi.InStationHeadTime >= ''2007-10-03 15:43:30'' and Hi.OutStationHeadTime <= ''2007-12-03 15:43:30'' and
set @strWhere=' (Di.DeptID= 0 or Di.DeptID=21 or Di.DeptID=30 or Di.DeptID=31 or Di.DeptID=32 or Di.DeptID=33 or Di.DeptID=34 or Di.DeptID=24 or Di.DeptID=25 or Di.DeptID=26 or Di.DeptID=27 or Di.DeptID=28 or Di.DeptID=29 or Di.DeptID=35 or Di.DeptID=23 or Di.DeptID=36)'
set @TimeStation='InStationHeadTime >= ''2007-10-03 15:43:30'' and OutStationHeadTime <= ''2007-12-03 15:43:30'' and CsTypeID=1'
*/
Declare @strSql VarChar(8000)
declare @strSql1 varchar(8000)
declare @strsql2 varchar(8000)
Declare @strSql3 VarChar(8000)

	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shen_Temp_1]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
	drop table [dbo].[Shen_Temp_1]

	if (@fieldList='人员')
	begin
		set @strSql3=' select * into Shen_Temp_1 From (select DISTINCT Hi.CodeSenderAddress AS 发码器, Hi.UserName AS 姓名, Di.DeptName AS 部门, 
		      	Wi.WtName AS 工种, Hi.StationHeadPlace AS 探头安装位置, 
		      	Hi.InStationHeadTime AS 进入探头时间, Hi.OutStationHeadTime AS 离开探头时间, 
		      	dbo.FunConvertTime(DATEDIFF(ss, Hi.InStationHeadTime, Hi.OutStationHeadTime)) 
		      	AS 持续时间,HisStationHeadID   
			From (select  * from His_InOutStationHead as C where '+@TimeStation+' and CSTypeID =0 ) as Hi LEFT OUTER JOIN
		      	dbo.Emp_NowCompany En ON En.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.Dept_Info Di ON Di.DeptID = En.DeptID LEFT OUTER JOIN
		         (SELECT *
		         FROM Emp_WorkType
		         WHERE IsEnable = 1) Ew ON Ew.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.WorkType_Info Wi ON Wi.WorkTypeID = Ew.WorkTypeID LEFT OUTER JOIN  	
		      	dbo.Duty_Info Dio ON Dio.DutyID = En.DutyID 
		      	 where '+@strWhere+') as D'
		if @PageIndex = 1
			begin
				set @strSql1=' Select Top '+str(@PageSize)+' 发码器,姓名,部门,工种,探头安装位置,进入探头时间,离开探头时间,持续时间 From Shen_Temp_1 Order By  HisStationHeadID '
			end
		else
			begin
				set @strSql1=' Select Top '+str(@PageSize)+' 发码器,姓名,部门,工种,探头安装位置,进入探头时间,离开探头时间,持续时间 From Shen_Temp_1 Where HisStationHeadID >
					(Select max(HisStationHeadID) From Shen_Temp_1 as R where HisStationHeadID in (Select top  '+ str(@PageSize*(@PageIndex-1))+' HisStationHeadID From Shen_Temp_1 as Q Order By HisStationHeadID )) order by HisStationHeadID'
			end
		set @strsql2='Select count(*) from Shen_Temp_1 '
	end
	else
	begin
			
		set @strSql3=' Select * into Shen_Temp_1 From (select distinct Hi.CodeSenderAddress As 发码器,IsNull(Eb.EquName,''未知'') As 设备名称, IsNull(Di.DeptName,''未知'' ) As 部门,
					IsNull(Fi.FactoryName,''未知'') As 生产厂家,
					Hi.StationHeadPlace As 探头安装位置,  Hi.InStationHeadTime As 进入探头时间,
					Hi.OutStationHeadTime As 离开探头时间,  dbo.FunConvertTime(DateDiff(ss, Hi.InStationHeadTime, Hi.OutStationHeadTime)) As 持续时间, HisStationHeadID 
					From (select  * from His_InOutStationHead as C where '+@TimeStation+' and CSTypeID =0 ) As Hi
					left join Equ_BaseInfo As Eb on Eb.EquID = Hi.UserID
					left join Dept_Info As Di on Di.DeptID = Eb.DeptID
					left join FactoryInfo As Fi on Fi.FactoryID = Eb.FactoryID
					left join (Select * From EnumTable where FunID = 9) as Ei On Ei.EnumID = Eb.EquType where '+@strWhere+') as D'
		if @PageIndex = 1
			begin
				set @strSql1='Select Top '+str(@PageSize)+' 发码器,设备名称,部门,生产厂家,探头安装位置,进入探头时间,离开探头时间,持续时间 From Shen_Temp_1 Order By HisStationHeadID'
			end
		else
			begin
				set  @strSql1='Select Top '+str(@PageSize)+' 发码器,设备名称,部门,生产厂家,探头安装位置,进入探头时间,离开探头时间,持续时间 From Shen_Temp_1 Where HisStationHeadID >
					(Select max(HisStationHeadID) From Shen_Temp_1 as R where HisStationHeadID in (select top '+ str(@PageSize*(@PageIndex-1))+' HisStationHeadID From Shen_Temp_1 as Q Order By HisStationHeadID )) order by HisStationHeadID'
			end	
		set @strsql2='Select count(*) from Shen_Temp_1 '
	end

	--print @strSql3
	--print @strsql1
	--print @strsql2
	Execute(@strSql3)
	exec(@strsql1)
	exec(@strsql2)

	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shen_Temp_1]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
	drop table [dbo].[Shen_Temp_1]




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE    procedure KJ128N_GetHistoryInOutStationHead_Query
(
	@tblName	VarChar(255),		--表名或视图表
	@keyField	VarChar(255),		--主键
	@fieldList	VarChar(2000) = '*',	--欲选择字段列表
	@orderField	VarChar(255),		--排序字段
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸     
	@strWhere	VarChar(8000),		--条件
	@orderType	bit = 1,		--排序,1,降序,0,升序
	@TimeStation	varchar(255)		--到得时间的条件
)

as
	
	
	
	
	Declare @strSql VarChar(8000)
	declare @strSql1 varchar(8000)
	declare @strsql2 varchar(8000)
	
 
	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shen_Temp]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
	drop table [dbo].[Shen_Temp]
	
	  
	If @orderType = 0
	Begin
		if @PageIndex = 1
		begin
			if(@fieldList='人员')
				begin
			set @strsql = 'select * into Shen_Temp from (select Top '+str(@PageSize)+' * from '+@tblName+' as C where '+@TimeStation+' and CSTypeID =0 order by '+@orderField+' desc) as B'
				end
			else
				begin
			set @strsql = 'select * into Shen_Temp from (select Top '+str(@PageSize)+' * from '+@tblName+' as C where '+@TimeStation+' and CSTypeID =1 order by '+@orderField+' desc) as B'
				end
		end
		else
		begin
		set 
			if(@fieldList='人员')
				begin
			set @strsql = 'select * into Shen_Temp from 
					(select top '+str(@PageSize)+' * from '+@tblName+' as a 
					where '+@TimeStation+' and CSTypeID =0 and '+@keyField+' <(select min('+@keyField+') from 
					(select top '+str((@PageIndex - 1)*@PageSize)+' '+@keyField+' from 
					'+@tblName+' as b where '+@TimeStation+' and CSTypeID =0 order by '+@keyField+' desc) as c) 
					order by '+@keyField+' desc) as d'
				end
			else
			begin
					set @strsql = 'select * into Shen_Temp from 
					(select top '+str(@PageSize)+' * from '+@tblName+' as a 
					where '+@TimeStation+' and CSTypeID=1 and '+@keyField+' <(select min('+@keyField+') from 
					(select top '+str((@PageIndex - 1)*@PageSize)+' '+@keyField+' from 
					'+@tblName+' as b where '+@TimeStation+' and CSTypeID=1  order by '+@keyField+' desc) as c) 
					order by '+@keyField+' desc) as d'
			end
			
		end
		
	End	
	
if(@fieldList='人员')
		begin
			set @strSql1 = 'SELECT DISTINCT 
		      	Hi.CodeSenderAddress AS 发码器, Ei.EmpName AS 姓名, Di.DeptName AS 部门, 
		      	Wi.WtName AS 工种, Hi.StationHeadPlace AS 探头安装位置, 
		      	Hi.InStationHeadTime AS 进入探头时间, Hi.OutStationHeadTime AS 离开探头时间, 
		      	dbo.FunConvertTime(DATEDIFF(ss, Hi.InStationHeadTime, Hi.OutStationHeadTime)) 
		      	AS 持续时间 
			FROM Shen_Temp Hi LEFT OUTER JOIN
		      	dbo.Emp_Info Ei ON Ei.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.Emp_Detail Ed ON Ed.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.Emp_NowCompany En ON En.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.Dept_Info Di ON Di.DeptID = En.DeptID LEFT OUTER JOIN
		          (SELECT *
		         FROM Emp_WorkType
		         WHERE IsEnable = 1) Ew ON Ew.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.WorkType_Info Wi ON Wi.WorkTypeID = Ew.WorkTypeID LEFT OUTER JOIN
		      	dbo.Emp_Certificate Ec ON Ec.EmpID = Hi.UserID LEFT OUTER JOIN
		      	dbo.Certificate_Info Ci ON Ci.CerTypeID = Ec.CerTypeID LEFT OUTER JOIN
		      	dbo.Duty_Info Dio ON Dio.DutyID = En.DutyID LEFT OUTER JOIN
		      	dbo.EnumTable Et ON Et.EnumID = Dio.DutyClassID  '
			set @strsql2 = 'select count(*) from '+@tblName+' as b where '+@TimeStation+' and CSTypeID = 0'
		end
	else
		begin
			set @strSql1 = 'select distinct Hi.CodeSenderAddress As 发码器,IsNull(Eb.EquName,''未知'') As 设备名称, IsNull(Di.DeptName,''未知'' ) As 部门,
					IsNull(Fi.FactoryName,''未知'') As 生产厂家,
					Hi.StationHeadPlace As 探头安装位置,  Hi.InStationHeadTime As 进入探头时间,
					Hi.OutStationHeadTime As 离开探头时间,  dbo.FunConvertTime(DateDiff(ss, Hi.InStationHeadTime, Hi.OutStationHeadTime)) As 持续时间 
					from Shen_Temp As Hi
					left join Equ_BaseInfo As Eb on Eb.EquID = Hi.UserID
					left join Dept_Info As Di on Di.DeptID = Eb.DeptID
					left join FactoryInfo As Fi on Fi.FactoryID = Eb.FactoryID
					left join (Select * From EnumTable where FunID = 9) as Ei On Ei.EnumID = Eb.EquType '
			set @strsql2 = 'select count(*) from '+@tblName+' as b where '+@TimeStation+' and CSTypeID = 1 '
		end
	print @strsql1
	print @strsql2
	Execute(@strSql)
	exec(@strsql1)
	exec(@strsql2)

	
	
	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].[Shen_Temp]') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
	drop table [dbo].[Shen_Temp]  





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--2008-05-15  图形系统配置文件数据表
--         主键 filename       文件名称
--              ConfigFile     配置文件
--              MapFile        底图文件



--添加以上表的一条记录
--参数   filename    文件名
--       configfile  配置文件
--       mapfile     底图文件
create proc KJ128N_Graphics_AddConfigFile
@filename varchar(50),
@configfile image,
@mapfile image
as
  begin
    insert into ConfigFile_ZZHA values(@filename,@configfile,@mapfile)
  end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE proc KJ128N_Graphics_AddDConfigFile
@filename varchar(50),
@configfile image,
@fileid int
as
  begin
	if not exists (select [filename] from G_DConfigFile where [filename]=@filename)
         insert into G_DConfigFile values(@filename,@configfile,@fileid)
  end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--添加以上表的一条记录
--参数   filename    文件名
--       configfile  配置文件
--       mapfile     底图文件
create proc KJ128N_Graphics_UpdateConfigFile
@filename varchar(50),
@configfile image,
@mapfile image
as
  begin
    update ConfigFile_ZZHA set configfile=@configfile,mapfile=@mapfile where filename=@filename
  end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


--添加以上表的一条记录
--参数   filename    文件名
--       configfile  配置文件
--       fileid     底图文件id
create proc KJ128N_Graphics_UpdateDConfigFile
@filename varchar(50),
@configfile image,
@fileid int
as
  begin
    update G_DConfigFile set configfile=@configfile,mapfileid=@fileid where filename=@filename
  end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




-- 历史下井人数统计 （1,按部门统计2,按职务统计3，按工种统计）
-- 条件 必须（Where CsTypeID = 0 ）
CREATE Proc KJ128N_HisInOutTotal_Proc
(
	@intType int,
	@strWhere varchar(1000)
)
as

declare @strSQL varchar(8000)
--declare @strCount varchar(8000)
if @intType =1
Begin
set @strSQL= 'SELECT DISTINCT 
      V_Tmp_Dept_Emp.DeptID As 编号, V_Tmp_Dept_Emp.DeptName As 名称, 
      V_Tmp_Dept_Emp_Total.EmpCount As 下井人数
FROM  V_Tmp_Dept_Emp 
	INNER JOIN
      (Select DeptID, Count(1) As EmpCount From 
		(
			Select * From V_Tmp_Dept_Emp Where EmpID In
			(
				Select UserID From His_InOutMine '+@strWhere +'
			)
		) As  V_Tmp_Dept_Emp2 Group By DeptID) As V_Tmp_Dept_Emp_Total ON 

      V_Tmp_Dept_Emp.DeptID = V_Tmp_Dept_Emp_Total.DeptID'
End

else if @intType =2
Begin
	set @strSQL ='
select distinct V_Tmp_Duty_Emp.DutyID As 编号,V_Tmp_Duty_Emp.DutyName As 名称,

V_Tmp_Duty_Emp_Total.EmpCount As 下井人数 

from V_Tmp_Duty_Emp inner join 

(select DutyID,count(1) As EmpCount From 
(
	select * from V_Tmp_Duty_Emp where EmpID in
	(
		select UserID from His_InOutMine '+@strWhere+'
	)
) As V_Tmp_Duty_Emp2 Group by DutyID) As V_Tmp_Duty_Emp_Total on 

V_Tmp_Duty_Emp.DutyID = V_Tmp_Duty_Emp_Total.DutyID'
End

else
Begin 
set @strSQL ='select distinct V_Tmp_WorkType_Emp.WorkTypeID As 编号,V_Tmp_WorkType_Emp.WtName As 名称,

V_Tmp_WorkType_Emp_Total.EmpCount As 下井人数 

from V_Tmp_WorkType_Emp inner join 

(select WorkTypeID,count(1) As EmpCount From 
(
	select * from V_Tmp_WorkType_Emp where EmpID in
	(
		select UserID from His_InOutMine '+@strWhere+'
	)
) As V_Tmp_WorkType_Emp2 Group by WorkTypeID) As V_Tmp_WorkType_Emp_Total on 

V_Tmp_WorkType_Emp.WorkTypeID = V_Tmp_WorkType_Emp_Total.WorkTypeID

'

End
exec (@strSQL)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE Proc KJ128N_HisStationBad_Degree_Proc
(
	@strWhere varchar(3000)
)

As

declare @strSQL varchar(6000)

if @strWhere =''
Begin
	
	set @strSQL ='
	
	select distinct StationAddress AS 基站地址号,
	
	(select StationPlace from Station_Info where StationAddress=hs.StationAddress) As 基站安装地址,
	
	(select count(StationAddress) from HistoryBadStations where StationAddress=hs.StationAddress) as 故障次数
	
	from HistoryBadStations as hs Where StationAddress  Is Not Null 
	
	'+@strWhere
End
else
Begin
	set @strSQL ='
	
	select distinct StationAddress AS 基站地址号,
	
	(select StationPlace from Station_Info where StationAddress=hs.StationAddress) As 基站安装地址,
	
	(select count(StationAddress) from HistoryBadStations where StationAddress=hs.StationAddress) as 故障次数
	
	from HistoryBadStations as hs Where StationAddress  Is Not Null and '+@strWhere
End


Exec (@strSQL)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE Proc KJ128N_HisStationHeadBad_Degree_Proc
(
	@strWhere varchar(3000)
)

As

declare @strSQL varchar(6000)

if @strWhere =''
Begin
	
	set @strSQL ='
select distinct hs.StationHeadAddress AS 探头地址号,
	
(

select shi.StationHeadPlace from Station_Head_Info shi

left join Station_Info sh on sh.StationAddress = shi.StationAddress and sh.StationPlace = hs.StationPlace

where shi.StationHeadAddress=hs.StationHeadAddress and shi.StationAddress = hs.StationAddress

) As 探头安装地址,
	
	(select count(*) from HistoryBadStations  where StationHeadAddress =  hs.StationHeadAddress ) as 故障次数
	
	from HistoryBadStations hs Where hs.StationHeadAddress  Is Not Null
	
	'+@strWhere
End
else
Begin
	set @strSQL ='
select distinct hs.StationHeadAddress AS 探头地址号,
	
(

select shi.StationHeadPlace from Station_Head_Info shi

left join Station_Info sh on sh.StationAddress = shi.StationAddress and sh.StationPlace = hs.StationPlace

where shi.StationHeadAddress=hs.StationHeadAddress and shi.StationAddress = hs.StationAddress

) As 探头安装地址,
	
	(select count(*) from HistoryBadStations  where StationHeadAddress =  hs.StationHeadAddress ) as 故障次数
	
	from HistoryBadStations hs Where hs.StationHeadAddress  Is Not Null and '+@strWhere
End


Exec (@strSQL)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



-- 发码器， 设备名称，部门，生产厂家，探头安装位置，进入探头时间，离开探头时间，持续时间
-- 根据设备类型，生产厂家,进入探头时间，离开探头时间，部门 查询

CREATE Proc KJ128N_HisStationHead_Query_Equ
(
	@strWhere varchar(400)
)

As

declare @strSql varchar(1000)

set  @strSql = '
select Hi.CodeSenderAddress As 发码器,IsNull(Eb.EquName,'+char(39)+ '未知'+char(39)+') As 设备名称, IsNull(Di.DeptName,'+char(39)+'未知' +char(39)+') As 部门,

IsNull(Fi.FactoryName,'+char(39)+'未知'+char(39)+') As 生产厂家,

Hi.StationHeadPlace As 探头安装位置,  Hi.InStationHeadTime As 进入探头时间,

Hi.OutStationHeadTime As 离开探头时间,  dbo.FunConvertTime(DateDiff(ss, Hi.InStationHeadTime, Hi.OutStationHeadTime)) As 持续时间

from His_InOutStationHead As Hi

left join Equ_BaseInfo As Eb on Eb.EquID = Hi.UserID
left join Dept_Info As Di on Di.DeptID = Eb.DeptID
left join FactoryInfo As Fi on Fi.FactoryID = Eb.FactoryID
left join (Select * From EnumTable where FunID = 9) as Ei On Ei.EnumID = Eb.EquType
where Hi.CsTypeID = 1 '+ @strWhere

exec (@strSql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


-- 砝码器，设备名称，部门，生产厂家，下井地点，下井时间，上井地点，上井时间，下井时长
CREATE Proc KJ128N_His_InoutMine_Equ_Info
(
	@strWhere varchar(400)
)
As

Declare @strSQL varchar(5000)

set @strSQL = '

select  Hi.CodeSenderAddress As 发码器, Eb.EquName As 设备名称,Di.DeptName As 部门,  Fi.FactoryName As 生产厂家,

Hi.InWellPlace As 下井地点,  Hi.InTime As 下井时间,  Hi.OutWellPlace As 上井地点,  Hi.OutTime As 上井时间,
dbo.FunConvertTime(Hi.ContinueTime) As 下井时长

from His_InOutMine As Hi

left join Equ_BaseInfo As Eb on Eb.EquID = Hi.UserID
left join FactoryInfo As Fi on Fi.FactoryID = Eb.FactoryID
left join Dept_Info As Di on Di.DeptID = Eb.DeptID
left join (Select * From EnumTable where FunID = 9) as Ei On Ei.EnumID = Eb.EquType
where Hi.CsTypeID =1  ' + @strWhere

Exec (@strSQL)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


-- 砝码器，设备名称，部门，生产厂家，下井次数，下井时长
CREATE  Proc KJ128N_His_InoutMine_Query_Equ
(
	@strWhere varchar(400)
)
As

Declare @strSQL varchar(5000)

set @strSQL = '

select  Hi.CodeSenderAddress As 发码器, Eb.EquName As 设备名称,Di.DeptName As 部门,  Fi.FactoryName As 生产厂家,

(
	select count(*) From His_InoutMine As Hi Where Hi.UserID = Eb.EquID and Hi.CsTypeID = 1
) As 下井次数,

(
	select dbo.FunConvertTime(sum(ContinueTime)) From His_InOutMine As Hi where   Hi.UserID = Eb.EquID and Hi.CsTypeID = 1
) As 下井时长

from His_InOutMine As Hi

left join Equ_BaseInfo As Eb on Eb.EquID = Hi.UserID
left join FactoryInfo As Fi on Fi.FactoryID = Eb.FactoryID
left join Dept_Info As Di on Di.DeptID = Eb.DeptID
left join (Select * From EnumTable where FunID = 9) as Ei On Ei.EnumID = Eb.EquType
where Hi.CsTypeID =1 ' + @strWhere

Exec (@strSQL)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
declare @qw datetime
set @qw= getdate()
 exec KJ128N_Insert_HisInOutStation @qw,1,1,1,0,'113,114,23,65',1
*/
--select  dbo.FunDateBitLong(getdate())

--这个文件内的所有存储过程，都是通过Wwy_Station_InOutStation调用生成的基本数据表
CREATE     proc KJ128N_Insert_HisInOutStation
(
       /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000), --发码器集
            @InStationAntenna int -- 所在天线 0 无 1 A 2 B
)
as--dbo.FunDateString
declare @temDate dateTime
declare @temIDString nvarchar(100)
set @temDate=getdate()
--cast((@temIDString+cast(F1 as nvarchar(5))) as bigint)
-- 历史表里添加记录 HisInOutStation
Insert Into [His_InOutStation] ([HisInStationID],[StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [StationHeadDetectTime], 
		[CodeSenderID],[InStationAntenna],[StationHeadPlace],
                [StationAntennaPlace],[CsSetID],[CsTypeID],[UserID],[CodeSenderAddress])
	SELECT dbo.FunDateBigIntID(@temDate,F1), @StationAddress As StationAddress, @StationHeadAddress As StationHeadAddress, 
		@HeadA As HeadA, @HeadB As HeadB, @DetectTime As DetectTime,
	CodeSenderID,@InStationAntenna,T4.StationHeadPlace,
        StationAntennaPlace=
        case @InStationAntenna
        when 0 then '出探头'
        when 1 then T4.AntennaA
        when 2 then T4.AntennaB
        end
       ,CsSetID,CsTypeID,UserID,F1 As CodeSenderAddress 
        From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
	Left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1
        left Join Station_Head_Info as T4 
        On T4.StationAddress=@StationAddress 
        and T4.StationHeadAddress=@StationHeadAddress





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  Proc [dbo].[KJ128N_Insert_HisStationHeadInfo]
(
        /*
		实时进探头表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000),
	@InStationAntenna int
)
as
---SELECT [HisStationHeadID], [StationAddress], [StationHeadAddress], [StationHeadPlace], [CodeSenderAddress], [CsSetID], [CsTypeID], [UserName], [UserID], [InStationHeadTime], [OutStationHeadTime] FROM [KJ128N2ZJW].[dbo].[His_InOutStationHead_1]

--dbo.FunDateString
declare @temDate dateTime
declare @HisStationHeadID bigint
declare @temIDString nvarchar(100)

set @temDate=getdate()
--set @temIDString=dbo.FunDateString(@temDate)

If(@InStationAntenna=0)
Begin
	INSERT INTO [His_InOutStationHead]
	(
		[HisStationHeadID], 
		[StationAddress],
		[StationHeadAddress],
		[StationHeadPlace], 
		[CodeSenderAddress],
		[CsSetID],
		[CsTypeID],
		[UserName],
		[UserID], 
		[InStationHeadTime],
		[OutStationHeadTime]
	)
	
	Select 
            dbo.FunDateBigIntID(@temDate,F1),
	@StationAddress,
	@StationHeadAddress,
	SHI.StationHeadPlace,
	T1.F1,
	RT.CsSetID,
	RT.CsTypeID,
	KCC.EmpName,
	RT.UserID,
	--case when RT.InStationHeadTime >@DetectTime then @DetectTime else @DetectTime--RT.InStationHeadTime 
	--end,
	--case when RT.InStationHeadTime < @DetectTime then @DetectTime else @DetectTime --RT.InStationHeadTime 
	--end
	RT.InStationHeadTime,
	@DetectTime
	From (Select Distinct F1 From dbo.f_splitstr(@Cards,',') Where F1>0) As T1
	Inner Join RT_InStationHeadInfo As RT On T1.F1=RT.CodeSenderAddress
	Left Join Station_Head_Info SHI On RT.StationHeadID=SHI.StationHeadID
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where
	SHI.StationAddress = @StationAddress And
	SHI.StationHeadAddress = @StationHeadAddress



--如果发生异常事件，则写入异常处理表中
declare @CoderSenderAddress int
declare @InTime datetime	
declare StationCursor cursor for 
	Select T1.F1,RT.InStationHeadTime
	From (Select Distinct F1 From dbo.f_splitstr(@Cards,',') Where F1>0) As T1
	Inner Join RT_InStationHeadInfo As RT On T1.F1=RT.CodeSenderAddress
	Left Join Station_Head_Info SHI On RT.StationHeadID=SHI.StationHeadID
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where
	SHI.StationAddress = @StationAddress And
	SHI.StationHeadAddress = @StationHeadAddress

open StationCursor 

fetch next from StationCursor into @CoderSenderAddress,@InTime
while @@FETCH_STATUS >0
begin
exec KJ128N_Insert_UnCommanTable @CoderSenderAddress,@InTime,@DetectTime,@StationAddress,@StationHeadAddress
fetch next from StationCursor into @CoderSenderAddress,@InTime
end

CLOSE StationCursor
DEALLOCATE StationCursor


	Delete  From dbo.RT_InStationHeadInfo
	Where CodeSenderAddress In 
	(
		Select T1.F1 
		From (Select Distinct F1 From dbo.f_splitstr(@Cards,',') Where F1>0) As T1
		Inner Join RT_InStationHeadInfo As RT On T1.F1=RT.CodeSenderAddress
		Left Join Station_Head_Info SHI On RT.StationHeadID=SHI.StationHeadID
		Where 
		SHI.StationAddress = @StationAddress And
		SHI.StationHeadAddress = @StationHeadAddress
	)
End
Else If (@InStationAntenna = 1 Or @InStationAntenna = 2)
Begin
	--当出现不同探头信时
	INSERT INTO [His_InOutStationHead]
	(
		[HisStationHeadID], 
		[StationAddress],
		[StationHeadAddress],
		[StationHeadPlace], 
		[CodeSenderAddress],
		[CsSetID],
		[CsTypeID],
		[UserName],
		[UserID], 
		[InStationHeadTime],
		[OutStationHeadTime]
	)

	Select 
	 dbo.FunDateBigIntID(@temDate,F1),
	SHI.StationAddress,
	SHI.StationHeadAddress,
	SHI.StationHeadPlace,
	T1.F1,
	RT.CsSetID,
	RT.CsTypeID,
	KCC.EmpName,
	RT.UserID,
	RT.InStationHeadTime,
	DateAdd(s,3,RT.InStationHeadTime)
	From (Select Distinct F1 From dbo.f_splitstr(@Cards,',') Where F1>0) As T1
	Inner Join RT_InStationHeadInfo As RT On T1.F1=RT.CodeSenderAddress
	Left Join Station_Head_Info SHI On RT.StationHeadID=SHI.StationHeadID
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where 
	Not (SHI.StationAddress = @StationAddress And
	SHI.StationHeadAddress = @StationHeadAddress)

	print (@StationAddress)
	print (@StationHeadAddress)
    
	Delete  From dbo.RT_InStationHeadInfo
	Where CodeSenderAddress In 
	(
		Select T1.F1 
		From (Select Distinct F1 From dbo.f_splitstr(@Cards,',') Where F1>0) As T1
		Inner Join RT_InStationHeadInfo As RT On T1.F1=RT.CodeSenderAddress
		Left Join Station_Head_Info SHI On RT.StationHeadID=SHI.StationHeadID
		Where 
		Not (SHI.StationAddress = @StationAddress And
		SHI.StationHeadAddress = @StationHeadAddress)
	)
End



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  proc KJ128N_Insert_His_Directional
@CodeSenderAddress int,
@StationAddress int,			-- 基站号
@StationHeadAddress int,		-- 探头号
@DetectTime datetime,			-- 检测时间
@CodeSenderDirlID int,			-- 方向自增列
@CsTypeID int,				-- 类型
@DetectionInfo varchar(50)		-- 方向描述
as
begin
	print CONVERT(varchar(20), @DetectTime)
	--历史表不存在则创建
	declare @tabName varchar(50)
	set @tabName = 'His_Directional_'+LTRIM(RTRIM(DATEPART(year,getdate())))+LTRIM(RTRIM(DATEPART(Month,getdate())))
	if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@tabName+']') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
	begin
		--得到名称
		declare @name varchar(50)		
		if @CsTypeID = 0
		select @name=ei.EmpName from dbo.CodeSender_Set as cs
		left join dbo.Emp_Info as ei on ei.EmpID = cs.UserID
		where cs.CodeSenderAddress = @CodeSenderAddress and cs.CsTypeID=@CsTypeID
		else
		select @name=di.DeptName from dbo.CodeSender_Set as cs
		left join dbo.Dept_Info as di on di.DeptID = cs.UserID
		where cs.CodeSenderAddress = @CodeSenderAddress and cs.CsTypeID=@CsTypeID
	
		--添加历史数据
		declare @Directional varchar(50)
		select @Directional = Directional from dbo.CodeSender_DirectionalAntenna
		where CodeSenderDirlID=@CodeSenderDirlID
	
		declare @t varchar(1000)
		set @t='insert into '+@tabName+' (CodeSenderAddress,DirectionalTitle,DirectionalInfo,NowTime,CsTypeID,[name]) values('+LTRIM(RTRIM(@CodeSenderAddress))+','+
		+char(39)+@Directional+char(39)+','+char(39)+@DetectionInfo+char(39)+','+char(39)+CONVERT(varchar(20), @DetectTime,120)+char(39)+','+LTRIM(RTRIM(@CsTypeID))+','
		+char(39)+@name+char(39)+')'
		exec (@t)
	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc [dbo].[KJ128N_Insert_His_InOutMine]
(
        /*
		历史进出井表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
As
begin
/*
print '添加到历史下井表'
print @Cards
print @DetectTime
print @StationAddress
print @StationHeadAddress
*/
declare @temIDString bigint
declare @temDate dateTime
set @temDate=getdate()
--set @temIDString=dbo.FunDateString(getdate())
--select dbo.FunDateBitLong(getdate())
   INSERT INTO [His_InOutMine]
    (HisInOutMineID,[InStationAddress], [InStationHeadAddress], 
     [InWellPlace], [CsSetID], [CsTypeID], [UserID],[UserName],
     [CodeSenderAddress], [InTime], 
     [OutStationAddress], [OutStationHeadAddress], 
     [OutWellPlace], [OutTime], [ContinueTime])                     
    Select dbo.FunDateBigIntID(@temDate,RBase.CodeSenderAddress),
        RSHI.StationAddress,RSHI.StationHeadAddress,
        RSHI.StationHeadPlace,KCC.CsSetId,KCC.CsTypeID,KCC.USerID,KCC.empName,
        RBase.CodeSenderAddress,RBase.InTime,@StationAddress,
        @StationHeadAddress,HSHI.StationHeadPlace,@DetectTime,
        DATEDIFF (s ,RBase.InTime,@DetectTime)
     From (
            select * from RT_InOutMine RTI 
            where RTI.CodeSenderAddress In 
           (select Distinct F1 from f_splitStr(@Cards,',') where F1>0)
          ) As RBase                
     Left join Station_Head_Info RSHI  on RBase.StationHeadID=RSHI.StationHeadID
     Left join Station_Head_Info HSHI on HSHI.StationAddress=@StationAddress 
     and HSHI.StationHeadAddress=@StationHeadAddress
     Left Join KJ128N_Comm_CsEmpEqu KCC On KCC.CsSetID=RBase.CsSetId  




  Delete [Rt_InOutMine] Where CsSetID In 
  (
	Select Cs.CsSetID As CsSetID From 
	(Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
	Inner Join [CodeSender_Set] As Cs On Cs.CodeSenderAddress = T1.F1
  )	           
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE    proc [dbo].[KJ128N_Insert_His_OverTimeAlarm]
(
        @DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000) --发码器集
)
as
-- 历史超时记录
INSERT INTO [dbo].[His_OverTimeAlarm]
( [CodeSenderAddress], [CsSetID], [CsTypeID], 
[UserID], [UserName], [InMineTime], [DelayedStartTime], [DelayedEndTime], 
[DelayedTime],[DeptName])
Select
    CF.F1,RTOV.CsSetID,RTOV.CsTypeID,RTOV.UserID,EI.EmpName,
    RTOV.InMineTime,RTOV.StartOverTime ,@DetectTime,
    dateDiff(s,RTOV.StartOverTime,@DetectTime),DI.DeptName
from (Select F1 from f_splitstr(@Cards,',') where F1>0) as CF
Inner join dbo.RT_OverTimeInfo_View RTOV On RTOV.CodeSenderAddress=CF.F1
left Join dbo.Emp_Info EI On EI.EmpID=RTOV.UserID
left join dbo.Emp_NowCompany ENC On ENC.EmpID=RTOV.UserID
Left Join dbo.Dept_Info DI On DI.DeptID=ENC.DeptID
where RTOV.StartOverTime<@DetectTime
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc [dbo].[KJ128N_Insert_HistoryBadStations]
(
        /*
		基站 及探头 信息
	*/
	@StationAddress int,
	@StationHeadAddress int,
	@StationState int,
	@BreakTime datetime
)
as
declare @temDate dateTime
set @temDate=getdate()
declare @StationID int
set @StationID=cast((cast(@StationAddress as varchar(20))+cast(@StationHeadAddress as varchar(20))) as int)
-- 历史基站故障或探头信息故障表
-- 表示基站故障
if(@StationHeadAddress=0)
begin
   INSERT INTO [dbo].[HistoryBadStations]

   ([HistoryBadStationsID],[StationAddress], [StationHeadAddress], 

    [StationPlace], [BadBeginTime], [BadEndTime], [BadTime])
    

   Select dbo.FunDateBigIntID(@temDate,@StationID),@StationAddress,@StationHeadAddress,
          SI.StationPlace,SI.BreakTime,@BreakTime,DateDiff(s,SI.BreakTime,@BreakTime)

   from Station_Info SI 
  
   where SI.StationAddress=@StationAddress and SI.StationState=-1000
end
else
begin
    INSERT INTO [dbo].[HistoryBadStations]

   ([HistoryBadStationsID],[StationAddress], [StationHeadAddress], 

    [StationPlace], [BadBeginTime], [BadEndTime], [BadTime])

   Select dbo.FunDateBigIntID(@temDate,@StationID),@StationAddress,@StationHeadAddress,
          SHI.StationHeadPlace,ShI.BreakTime,
          @temDate,DateDiff(s,ShI.BreakTime,@temDate)
   from Station_Head_Info SHI
   where SHI.StationAddress=@StationAddress 
        and SHI.StationHeadAddress=@StationHeadAddress
        and StationHeadState=-1000
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO










-- 添加到历史区域信息表
CREATE       proc KJ128N_Insert_InOutHisTerritorial
(
        /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
as
 -- 历史　区域信息
/*
*/
INSERT INTO [His_InOutTerritorial]([TerritorialID], 
[TerritorialName], [TerritorialTypeName], [InTerritorialTime], [CodeSenderAddress], [CsSetID], 
[CsTypeID], [UserID], [UserName], [OutTerritorialTime],[IsAlarm])

Select RTT1.TerritorialID,RTT1.TerritorialName,RTT1.TerritorialTypeName,
       RTT1.InTerritorialTime,RTT1.CodeSenderAddress,RTT1.CsSetID,RTT1.CsTypeID,
       RTT1.UserID,      
       Case RTT1.CsTypeID
       when 0  then (Select EmpName from dbo.Emp_Info where EmpID=RTT1.UserID )
       when 1  then  (Select EquName from dbo.Equ_BaseInfo where EquID=RTT1.UserID )
       end as  UserName
       ,getdate()
        as OutTerritorialTime,RTT1.IsAlarm
from (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As FC
      
      inner Join RT_TerritorialInfo as RTT1 on RTT1.CodeSenderAddress=FC.F1

where
     RTT1.TerritorialID not in(
     select TI.TerritorialID from Territorial_Info TI 
     left join dbo.Station_Info As SI On SI.StationAddress=@StationAddress
     Left join dbo.Station_Head_Info as SHI On SHI.StationAddress=@StationAddress 
     and SHI.StationHeadAddress=@StationHeadAddress      
     Left Join Territorial_Set As TS On TS.StationID=SI.StationID 
     and TS.StationHeadID=SHI.StationHeadID  
      where 
     TS.TerritorialID=TI.TerritorialID
)





/*
   删除实时区域信息表中的　不在此区域的此发码器的信息
*/
delete from RT_TerritorialInfo 
where 
TerritorialID not in(
     select TI.TerritorialID from Territorial_Info TI 
     left join dbo.Station_Info As SI On SI.StationAddress=@StationAddress
     Left join dbo.Station_Head_Info as SHI On SHI.StationAddress=@StationAddress 
     and SHI.StationHeadAddress=@StationHeadAddress      
     Left Join Territorial_Set As TS On TS.StationID=SI.StationID 
     and TS.StationHeadID=SHI.StationHeadID  
      where 
     TS.TerritorialID=TI.TerritorialID
)
and CodeSenderAddress In (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0)
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE        proc KJ128N_Insert_RTInStationHeadInfo
(
        /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000),
        @InStationAntenna int
)
as

 -- 实时探头信息
 if(@InStationAntenna<>0)
 begin
 if Exists(select Count(CsSetID) from RT_InStationHeadInfo)
   begin
     INSERT INTO [RT_InStationHeadInfo]
           ([CodeSenderAddress], [StationHeadID], 
            [CsSetID], [CsTypeID], [UserID],[InStationHeadTime],[InAntennaPlace])
      SELECT T1.F1,T4.StationHeadID,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime,
             InAntennaPlace=
             case @InStationAntenna
             when 1 then T4.AntennaA
             when 2 then T4.AntennaB
             end
      From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
      Inner Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1 and T3.CsSetID 
      Not in(select CsSetID from RT_InStationHeadInfo)
      Inner Join Station_Head_Info as T4 
      On T4.StationAddress=@StationAddress 
        and T4.StationHeadAddress=@StationHeadAddress
    end
else
   begin
      INSERT INTO [RT_InStationHeadInfo]
           ([CodeSenderAddress], [StationHeadID], 
            [CsSetID], [CsTypeID], [UserID],[InStationHeadTime],[InAntennaPlace])
      SELECT T1.F1,T4.StationHeadID,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime,
             InAntennaPlace=
             case @InStationAntenna
             when 1 then T4.AntennaA
             when 2 then T4.AntennaB
             end
      From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
      Inner Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1
      Inner Join Station_Head_Info as T4 
      On T4.StationAddress=@StationAddress 
        and T4.StationHeadAddress=@StationHeadAddress
   end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE               proc KJ128N_Insert_RTTerritorialInfo
(
        /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
as
 -- 实时区域信息
 INSERT INTO [RT_TerritorialInfo]
           ([TerritorialID], [TerritorialName], 
            [InTerritorialTime], [CodeSenderAddress], [CsSetID],[CsTypeID]
             ,[UserID],[TerritorialTypeName])
      SELECT TI.TerritorialID,TerritorialName,@DetectTime,FC.F1,Css.CsSetID,
       Css.CsTypeID,Css.UserID,TTy.TypeName
      From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As FC
      left join dbo.Station_Info As SI On SI.StationAddress=@StationAddress
      Left join dbo.Station_Head_Info as SHI On SHI.StationAddress=@StationAddress 
      and SHI.StationHeadAddress=@StationHeadAddress      
      inner Join Territorial_Set As TS On TS.StationID=SI.StationID 
      and TS.StationHeadID=SHI.StationHeadID
      Left Join dbo.Territorial_Info AS TI On TS.TerritorialID=TI.TerritorialID
      Left Join dbo.Territorial_Type As TTy On TTy.TerritorialTypeID=TI.TerritorialTypeID
      Left Join dbo.CodeSender_Set As CSS On CSS.CodeSenderAddress=FC.F1
      where FC.F1 not in(
      select CodeSenderAddress from dbo.RT_TerritorialInfo
      As RTT where RTT.TerritorialID=TI.TerritorialID
        ) and ts.IsTerriorialEnter = 0 and CSS.CsTypeID is not null

/*
区域插入区域报警信息和插入实时区域超员信息(游标的嵌套)
*/
declare @OverEmpTerrialID int
declare @BlockID int
declare @Count int
declare @TerrialID int
declare  mycursor1 cursor for Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0
open mycursor1
fetch next from mycursor1 into @BlockID
WHILE @@FETCH_STATUS = 0
begin
/*
插入实时区域超员信息

declare OverEmpCursor cursor for select distinct TerritorialID from dbo.RT_TerritorialInfo where CodeSenderAddress = @BlockID 
open OverEmpCursor
fetch next from OverEmpCursor into @OverEmpTerrialID 
while @@FETCH_STATUS = 0 
begin
exec Shine_Shen_RT_TerrialOverEmp @BlockID,@OverEmpTerrialID,@DetectTime

fetch next from OverEmpCursor into @OverEmpTerrialID
end 
close OverEmpCursor 
DEALLOCATE OverEmpCursor
*/
/*
更新实时区域报警信息
*/
/*select @Count =Count(*) from View_RealTimeTerrialAlarm_Employees where CodeSenderAddress=@BlockID and StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and IsAlarm =1
if(@Count >=1 )
begin
	select @TerrialID=TerrialID from View_RealTimeTerrialAlarm_Employees where CodeSenderAddress=@BlockID and StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and IsAlarm =1
	update RT_TerritorialInfo set IsAlarm = 1 where CodeSenderAddress = @BlockID and TerritorialID=@TerrialID

print @BlockID
end*/



  --select @worktypeid=worktypeid from emp_worktype where empid in(select userid from Codesender_set where codesenderaddress=@BlockID)

 /*  declare @terriorialid int 
  select @terriorialid=Territorialid from Territorial_Set where stationid in(select stationid from station_info where stationaddress=@stationaddress)
  and stationheadid in (select stationheadid from station_head_info where stationaddress=@stationaddress and stationheadaddress=@stationheadaddress)
  and IsTerriorialEnter=0
  select @Count =Count(*) from SWorkTypeTerrialSet where worktypeid=@worktypeid and TerrialID=@terriorialid
  if(@count>0)
  begin
    update RT_TerritorialInfo set IsAlarm = 1 where CodeSenderAddress = @BlockID and TerritorialID=@terriorialid
  end*/


  update RT_TerritorialInfo set IsAlarm = 1 where CodeSenderAddress = @BlockID and TerritorialID in(
  select Territorialid from Territorial_Set where stationid in(select stationid from station_info where stationaddress=@stationaddress)
  and stationheadid in (select stationheadid from station_head_info where stationaddress=@stationaddress and stationheadaddress=@stationheadaddress)
  and IsTerriorialEnter=0 and Territorialid in (select TerrialID from SWorkTypeTerrialSet where worktypeid in (select worktypeid from emp_worktype where empid in(select userid from Codesender_set where codesenderaddress=@BlockID)))
  )


fetch next from mycursor1 into @BlockID
end 
CLOSE mycursor1
DEALLOCATE mycursor1








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE   proc KJ128N_Insert_SpecialWorkTypeTerrial @EmpID int,@AreaID int,@workTypeID int,@IsAlarm bit,@Remark nvarchar(300) 
as 

declare @Count int

select @Count = Count(1) from SpecialWorkTypeTerrialSet where EmployeeID=@EmpID and TerrialID=@AreaID 
if @Count =0
begin

insert into SpecialWorkTypeTerrialSet(EmployeeID,TerrialID,WorkTypeID,IsAlarm,Remark) values(@EmpID,@AreaID,@WorkTypeID,@IsAlarm,@Remark)

END


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE procedure KJ128N_Insert_UnCommanTable @CodeSenderAddress int,
@InTime datetime,
@OutTime datetime,
@CurrentTime datetime,
@StationAddress int,
@StationHeadAddress int


 as

insert into UnCommanTable values(@CodeSenderAddress,@InTime,@OutTime,@CurrentTime,@StationAddress,@StationHeadAddress)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE          proc KJ128N_Insert_Updata_InMineStationInfo
   	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)         
as 
-- 逻辑: 如果这一次进出上井口基站的时间,比上次晚,那么就更新

--INSERT INTO [KJ128N2].[dbo].[InMineStationInfo]([StationAddress], [StationHeadAddress],
--[CodeSenderAddress], [InMineStationTime])
--StationHeadTypeID=8  上井口基站

begin
if EXISTS (Select * from dbo.Station_Head_Info SHI
		 where SHI.StationAddress=@StationAddress and SHI.StationHeadAddress=@StationHeadAddress
                 and  SHI.StationHeadTypeID=8)
	begin
		UPDATE [dbo].[InMineStationInfo]
		SET StationAddress=@StationAddress,
		    [StationHeadID]=SHI.StationHeadID,
		    [StationHeadAddress]=@StationHeadAddress, 
	            [CodeSenderAddress]=T1.F1, 
		    [InMineStationTime]=@DetectTime
	        from (Select F1 from dbo.f_splitstr(@Cards,',')) as T1
	        Inner join  InMineStationInfo ISI On ISI.CodeSenderAddress=T1.F1
                Inner join dbo.Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
                      and SHI.StationAddress=@StationAddress
	        WHERE InMineStationTime<@DetectTime or InMineStationTime>getDate()
	        
               if(Select Count(CodeSenderAddress) from InMineStationInfo )>0
               begin
			INSERT INTO [dbo].[InMineStationInfo]([StationHeadID],[StationAddress], [StationHeadAddress],
			[CodeSenderAddress], [InMineStationTime])
			select SHI.StationHeadID, @StationAddress,@StationHeadAddress,T1.F1,@DetectTime 
			from 
			(Select F1 from dbo.f_splitstr(@Cards,',')) as T1
			 Inner join dbo.Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
                     	 and SHI.StationAddress=@StationAddress
			where
			   T1.F1 not in (Select CodeSenderAddress from InMineStationInfo)
                end
                else
                begin

			INSERT INTO [dbo].[InMineStationInfo]([StationHeadID],[StationAddress], [StationHeadAddress],
			[CodeSenderAddress], [InMineStationTime])
			select SHI.StationHeadID,@StationAddress,@StationHeadAddress,T1.F1,@DetectTime 
			from 
			(Select DISTINCT  F1 from dbo.f_splitstr(@Cards,',')) as T1	
                         Inner join dbo.Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
                     	 and SHI.StationAddress=@StationAddress	
                end
	end
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create   proc [dbo].[KJ128N_Insert_Update_His_AreaEmpOverTime]
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
As
begin
	declare crAreaEmpOverTime cursor for (select F1 as CodeSenderAddress from dbo.f_splitstr(@Cards,','))
	open crAreaEmpOverTime

	declare @CodeSenderAddress int	--发码器编号
	declare @TerritorialID_Now int	--当前区域ID
	declare @TerritorialID_Old int	--上一次所在区域ID
	declare @TerWorkTime	int	--额定工作时间
	declare @InTerritorialTime_Old datetime		--该员工在上一个区域的进入时间


	fetch next from crAreaEmpOverTime into @CodeSenderAddress
	while @@fetch_status=0
	begin
		--该发码器是员工
		if(exists(Select 1 From CodeSender_Set Where CodeSenderAddress=@CodeSenderAddress and CsTypeID=0))
		begin
			print'----------'
			print @CodeSenderAddress

			--获取当前所在区域
			Set @TerritorialID_Now=( Select Ts.TerritorialID From Territorial_Set as Ts Left Join Station_Head_Info as Shi on Ts.StationHeadID=Shi.StationHeadID 
				 Where Shi.StationAddress=@StationAddress and Shi.StationHeadAddress=@StationHeadAddress )
			
			declare @sql varchar(1000)

			set @sql = 'Select Ts.TerritorialID From Territorial_Set as Ts Left Join Station_Head_Info as Shi on Ts.StationHeadID=Shi.StationHeadID 
				 Where Shi.StationAddress='+str(@StationAddress)+' and Shi.StationHeadAddress='+str(@StationHeadAddress)+' )'
			print @sql
			print '当前所在区域'
			print @TerritorialID_Now

			--获取该发码器上一个区域
			Set @TerritorialID_Old= ( Select TerritorialID From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress )

			print '获取该发码器上一个区域'
			print @TerritorialID_Old

			--获取上一个区域的额定工作时间
			set @TerWorkTime=(Select TerWorkTime From Territorial_Config Where TerritorialID=@TerritorialID_Old)
			
			print '获取额定工作时间'
			print @TerWorkTime


			--获取该员工在上一个区域的进入时间
			set @InTerritorialTime_Old=(Select InTerritorialTime From RT_TerritorialInfo Where CodeSenderAddress =@CodeSenderAddress )
			
			print '获取该员工在上一个区域的进入时间'
			print @InTerritorialTime_Old

			--该区域存在超时设置
			if(@TerWorkTime <> -1)
			begin
				--当前探头不属于任何一个区域
				if ( @TerritorialID_Now is null )
				begin
					--该发码器经过的上一个区域不为空
					if @TerritorialID_Old is not null
					begin
						--出区域
						print '出区域'
						--该员工在上一个区域中超时
						if(DATEDIFF ( ss ,@InTerritorialTime_Old ,@DetectTime ) > @TerWorkTime)
						begin
							insert into His_TerritorialEmpOverTime(TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,TerWorkTime,OutTerritorialTime,
								CodeSenderAddress,EmpID,EmpName,DeptID,DeptName,WtName)
							select Rt.TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,Tc.TerWorkTime,@DetectTime,CodeSenderAddress,Ei.EmpID,Ei.EmpName,Enc.DeptID,Dei.DeptName,Wt.WtName 
							From RT_TerritorialInfo as Rt left join Territorial_Config as Tc on Rt.TerritorialID=Tc.TerritorialID
								left join Emp_Info as Ei on Rt.UserID=Ei.EmpID and Rt.CsTypeID=0
								left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
								left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
								left join Emp_WorkType as Ewt on Ei.EmpID=Ewt.EmpID and Ewt.IsEnable=1
								left join WorkType_Info as Wt on Ewt.WorkTypeID=Wt.WorkTypeID
							where CodeSenderAddress=@CodeSenderAddress
						end
					end
				end
				--当前探头属于某一个区域
				else
				begin
					--该发码器经过的上一个区域为空
					if (@TerritorialID_Old is null)
					begin
						--第一次进入区域
						print '第一次进入区域'
	
					end
					--当前区域与旧区域相等
					else if(@TerritorialID_Now = @TerritorialID_Old)
					begin
						--该发码器还在同一个区域
						print '该发码器还在同一个区域'
					end
					else
					begin
						--该发码器从一个区域进入到另一个区域
						print '该发码器从一个区域进入到另一个区域'
						--该员工在上一个区域中超时
						if(DATEDIFF ( ss ,@InTerritorialTime_Old ,@DetectTime ) > @TerWorkTime)
						begin
							insert into His_TerritorialEmpOverTime(TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,TerWorkTime,OutTerritorialTime,
								CodeSenderAddress,EmpID,EmpName,DeptID,DeptName,WtName)
							select Rt.TerritorialID,TerritorialName,TerritorialTypeName,InTerritorialTime,Tc.TerWorkTime,@DetectTime,CodeSenderAddress,Ei.EmpID,Ei.EmpName,Enc.DeptID,Dei.DeptName,Wt.WtName 
							From RT_TerritorialInfo as Rt left join Territorial_Config as Tc on Rt.TerritorialID=Tc.TerritorialID
								left join Emp_Info as Ei on Rt.UserID=Ei.EmpID and Rt.CsTypeID=0
								left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
								left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
								left join Emp_WorkType as Ewt on Ei.EmpID=Ewt.EmpID and Ewt.IsEnable=1
								left join WorkType_Info as Wt on Ewt.WorkTypeID=Wt.WorkTypeID
							where CodeSenderAddress=@CodeSenderAddress
						end
					end
				end
			end
		print '-------------'
		end
		fetch next from crAreaEmpOverTime into @CodeSenderAddress
	end
	close crAreaEmpOverTime
	deallocate crAreaEmpOverTime
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



/****** Object:  Stored Procedure dbo.KJ128N_Insert_Update_InOutMine    Script Date: 2007-11-13 17:12:54 ******/
CREATE  proc KJ128N_Insert_Update_InOutMine
	@InMineCards varchar(6000),
	@StationAddress int,			-- 基站号
	@StationHeadAddress int		-- 探头号
as
-- 更新实时下井表
begin

         if(select Count(RtInOutMineID) From RT_InOutMine)>0
              begin
		-- 插入新的下井时间
                print 'InMine 1'
		INSERT INTO [dbo].[RT_InOutMine]
                (
                 [CodeSenderAddress],[StationHeadID], [CsSetID], 
                 [InTime]
                 )
                Select
                  T1.F1, ISI.StationHeadID as StationHeadID,
                  Cs.CsSetID as CsSetID,
	          ISI.InMineStationTime as InTime
                 From 
                    (Select Distinct F1 From f_splitstr(@InMineCards, ',') Where F1 > 0 ) As T1
		     inner join dbo.InMineStationInfo ISI on ISI.CodeSenderAddress=T1.F1
                 Inner Join
                 [CodeSender_Set] As Cs On Cs.CodeSenderAddress = T1.F1 
                  and Cs.CsSetID Not in(select CsSetID from RT_InOutMine)
		print 'InMine 2'
             end
            else
              begin
                  Insert into RT_InOutMine
                  (
		     [CodeSenderAddress],[StationHeadID], [CsSetID], 
                     [InTime])
                  Select
                  	T1.F1,ISI.StationHeadID,
                  Cs.CsSetID as CsSetID,
	           ISI.InMineStationTime as InTime
                  from 
                  (Select Distinct F1 From f_splitstr(@InMineCards, ',') Where F1 > 0 ) As T1
		   inner join dbo.InMineStationInfo ISI on ISI.CodeSenderAddress=T1.F1
                   inner Join
                  [CodeSender_Set] As Cs On Cs.CodeSenderAddress = T1.F1 
              end
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE           proc KJ128N_Insert_Update_InOutMine_Attendance
(
        /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
As
	-- 实时下井信息 
	-- 历史下井信息
   print @DetectTime

        Declare @temIsTimeOut bit -- 0 没有超时  1 超时    
       	declare @BlockID int
	declare @InMineCards varchar(6000)
        Declare @outMineCards varchar(6000)
        Declare @InMineDate DateTime -- 下井时间
        Declare @InMineStationAddress int -- 下井基站地址
        Declare @InMineStationHeadAddress int --下井探头地址
        -- print 'OK'
	Declare @DelayTimeHour bigint
	
        -- 将入井的所有卡存入一个字符串中
        set @InMineCards=dbo.FunInMine(@DetectTime,@StationAddress,
		@StationHeadAddress,@HeadA,@HeadB,@Cards)
 	print 'OK'
        -- 将出井的所有卡存入一个字符串
        set @outMineCards=dbo.FunOutMine(@DetectTime,@StationAddress,
		@StationHeadAddress,@HeadA,@HeadB,@Cards,getDate()) 
        print '入'         
        print @InMineCards
        print '出'
        print @outMineCards
	If (@InMineCards<>'')
	Begin
                -- 下井时间
                
		--插入实时考勤表和实时下井表
		declare Curosr_BlockID cursor FOR 
               (Select F1,ISi.InMineStationTime from  dbo.f_splitstr(@InMineCards,',')
                 left join dbo.InMineStationInfo ISI on ISI.CodeSenderAddress=F1)
		open Curosr_BlockID
                --print '打开游标'
		fetch next from Curosr_BlockID into @BlockID,@InMineDate
		while @@fetch_status = 0
		begin
			--防止上井口基站漏人，引起超时，
				--如果下井时间与上一次的上井口的时间相比较，
				--时间大于4，更新下井的时间

/*	因贵州那边出现 主界面左右人数严重不相等，其原因是下井时取当前时间导致，故将其屏蔽  --赵

			set @DelayTimeHour=datediff(Minute,@InMineDate,getdate())
	       		if(@DelayTimeHour>=(select EnumValue from EnumTable where FunID = 47 and EnumID = 1))--大于或等于8
			begin
				set @InMineDate=getdate()
				Update InMineStationInfo 
			        set InMineStationTime=getdate()
				from InMineStationInfo
				where  CodeSenderAddress=@BlockID	-- 查询最后一次的每个人的在上井口基站的时间
			end
*/        
                            -- 申V2 考勤
			exec dbo.proc_insert_RealTimeAttendance_cjg @BlockID,@InMineDate
			/*
                        print @BlockID
                         print @InMineDate
                        set @InMineDate='2007-11-4 11:00:00'
			*/
			--下井查找此入的路线信息，插入路线字符串信息[李乐]
			exec insert_pathStringByEmpNo @BlockID


			fetch next from Curosr_BlockID into @BlockID,@InMineDate
		end
               
		close Curosr_BlockID
		DEALLOCATE Curosr_BlockID
		-----
                 exec KJ128N_Insert_Update_InOutMine @InMineCards,@StationAddress,@StationHeadAddress
	     
	    exec zjw_OverEmpInWell	--超员统计	
		
	    --exec zjw_RTPost_Inset @Cards	--插入实时岗位信息


	End
	
              -- print 'if(@outMineCards<>'') -- 出井'
		if(@outMineCards<>'') -- 出井
		begin
			--插入历史考勤表
                      
			declare Curosr_BlockID cursor FOR  select F1 FROM dbo.f_splitstr(@outMineCards,',')
			open Curosr_BlockID
			fetch next from Curosr_BlockID into @BlockID
			while @@fetch_status = 0
			begin
				exec dbo.proc_insert_HistoryAttendance_cjg @BlockID,@DetectTime
				
				--处理实时方向性[丁静超]2008-7-2
				if exists(select CodeSenderAddress from dbo.RT_DirectionalAntenna where CodeSenderAddress = @BlockID)
				delete from RT_DirectionalAntenna where CodeSenderAddress = @BlockID

				--上井时处理此人的路线信息[李乐]
				exec processupinfo @BlockID,@DetectTime
				--巡检上井信息处理 [李乐]
				exec process_OutCheck @BlockID,@DetectTime

				fetch next from Curosr_BlockID into @BlockID
			end
			close Curosr_BlockID
			DEALLOCATE Curosr_BlockID
			exec KJ128N_Insert_His_OverTimeAlarm @DetectTime,@StationAddress,
				@StationHeadAddress,@HeadA,@HeadB,@outMineCards           
			exec  KJ128N_Insert_His_InOutMine @DetectTime,@StationAddress,
				@StationHeadAddress,@HeadA,@HeadB,@outMineCards     
			
			exec zjw_OverEmpOutWell	--超员统计   
			
			declare @TempDate datetime	
			set @TempDate=getdate()
			
			
			--exec dbo.zjw_RTPost_Delete   @outMineCards,@TempDate  --删除实时岗位信息
			exec OverSpeed_OutWell @outMineCards		--清除超速信息

		end

		

   print @DetectTime



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE  proc KJ128N_Insert_Update_RTInOutStaion
(
	/*
	实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
as


	/*
		插入记录
		1、卡号不能重复，卡号必须大于 0，所插入的数据应该是在 RT_InOutStation 表中不存在的。
	*/
	Insert Into [RT_InOutStation] ([StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [StationHeadDetectTime], 
		[CodeSenderID], [CodeSenderAddress], [InStationHeadAntenna])
	SELECT @StationAddress As StationAddress, @StationHeadAddress As StationHeadAddress, 
		@HeadA As HeadA, @HeadB As HeadB, @DetectTime As DetectTime,
	CodeSenderID, F1 As CodeSenderAddress, @HeadA + @HeadB * 2 As InStationHeadAntenna
	From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0 And 
		F1 Not In (Select CodeSenderAddress From RT_InOutStation)) As T1 
	Left Join CodeSender_Info As T2	On T2.CodeSenderAddress = T1.F1

	/*
		更新当前状态
	*/
	If (@HeadA = 0 And @HeadB = 0) 
		Begin
			-- 检测到卡的时间比当前记录新
			Update RT_InOutStation
				Set StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB, 
				StationHeadDetectTime = @DetectTime
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > StationHeadDetectTime
			)
		End
	Else
		Begin
			-- 检测到卡的时间比当前记录新
			Update RT_InOutStation
				Set InStationHeadAntenna = @HeadA + @HeadB * 2, StationHeadDetectTime = @DetectTime 
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > StationHeadDetectTime And 
				(
					StationHeadAntennaA = @HeadA And StationHeadAntennaB = @HeadB
						Or
					@HeadA + @HeadB * 2 = InStationHeadAntenna
				)
			)
		End

	-- 检测到卡的时间比当前记录旧，比上次记录新
	Update RT_InOutStation
		-- 更新上次状态
		Set LastStationAddress = StationAddress, LastStationHeadAddress = StationHeadAddress,
		LastStationHeadAntennaA = StationHeadAntennaA, LastStationHeadAntennaB = StationHeadAntennaB,
		LastInStationHeadAntenna = InStationHeadAntenna, LastStationHeadDetectTime = StationHeadDetectTime, 

		-- 更新当前状态
		StationAddress = @StationAddress, StationHeadAddress = @StationHeadAddress, 
		StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB,
		InStationHeadAntenna = @HeadA + @HeadB * 2,	StationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime > StationHeadDetectTime
	)

	-- 比较时间是否比当前小，比上一次更新大
	Update RT_InOutStation
		Set LastStationAddress = @StationAddress, LastStationHeadAddress = @StationHeadAddress,
		LastStationHeadAntennaA = @HeadA, LastStationHeadAntennaB = @HeadB,
		LastInStationHeadAntenna = @HeadA + @HeadB * 2, LastStationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime < StationHeadDetectTime And @DetectTime > LastStationHeadDetectTime And 
		(Not (StationAddress = @StationAddress And StationHeadAddress = @StationHeadAddress) Or
		@HeadA + @HeadB * 2 <> InStationHeadAntenna)
	)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE    proc KJ128N_Insert_Update_RTInOutStaion_Zdc
(
	/*
	实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
)
as
	/*
		插入记录
		1、卡号不能重复，卡号必须大于 0，所插入的数据应该是在 RT_InOutStation 表中不存在的。
	*/
	Insert Into [RT_InOutStation] ([StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [StationHeadDetectTime], 
		[CodeSenderID], [CodeSenderAddress], [InStationHeadAntenna])
	SELECT @StationAddress As StationAddress, @StationHeadAddress As StationHeadAddress, 
		@HeadA As HeadA, @HeadB As HeadB, @DetectTime As DetectTime,
	CodeSenderID, F1 As CodeSenderAddress, @HeadA + @HeadB * 2 As InStationHeadAntenna
	From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0 And 
		F1 Not In (Select CodeSenderAddress From RT_InOutStation)) As T1 
	Left Join CodeSender_Info As T2	On T2.CodeSenderAddress = T1.F1
	/*
		更新当前状态
	*/
	If (@HeadA = 0 And @HeadB = 0) 
		Begin
			-- 检测到卡的时间比当前记录新,且是同一个基站的同一探头
			Update RT_InOutStation
				Set StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB, 
				StationHeadDetectTime = @DetectTime
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > StationHeadDetectTime
				and StationHeadAddress=@StationHeadAddress
                                and StationAddress=@StationAddress
			)
		End
	Else
		Begin
			-- 检测到卡的时间比当前记录新
			Update RT_InOutStation
				Set InStationHeadAntenna = @HeadA + @HeadB * 2, StationHeadDetectTime = @DetectTime 
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > StationHeadDetectTime And 
				(
					StationHeadAntennaA = @HeadA And StationHeadAntennaB = @HeadB
						Or
					@HeadA + @HeadB * 2 = InStationHeadAntenna
				)
                                and StationHeadAddress=@StationHeadAddress
                                and StationAddress=@StationAddress
			)
		End	
if not(@HeadA + @HeadB * 2=0) -- 去掉，超前或超后的出探头现象
begin
	-- 检测到卡的时间比当前记录新
	Update RT_InOutStation
		-- 更新上次状态
		Set LastStationAddress = StationAddress, LastStationHeadAddress = StationHeadAddress,
		LastStationHeadAntennaA = StationHeadAntennaA, LastStationHeadAntennaB = StationHeadAntennaB,
		LastInStationHeadAntenna = InStationHeadAntenna, LastStationHeadDetectTime = StationHeadDetectTime, 

		-- 更新当前状态
		StationAddress = @StationAddress, StationHeadAddress = @StationHeadAddress, 
		StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB,
		InStationHeadAntenna = @HeadA + @HeadB * 2,	StationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime > StationHeadDetectTime
	)

	-- 比较时间比当前时间旧，比上次时间新,更新上次记录
	Update RT_InOutStation
		Set LastStationAddress = @StationAddress, LastStationHeadAddress = @StationHeadAddress,
		LastStationHeadAntennaA = @HeadA, LastStationHeadAntennaB = @HeadB,
		LastInStationHeadAntenna = @HeadA + @HeadB * 2, LastStationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join RT_InOutStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime < StationHeadDetectTime And @DetectTime > LastStationHeadDetectTime And 
		(Not (StationAddress = @StationAddress And StationHeadAddress = @StationHeadAddress) Or
		@HeadA + @HeadB * 2 <> InStationHeadAntenna)
	)

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--实时表更新
CREATE   proc KJ128N_Insert_Update_RT_AreaDirectiona
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
As
begin
	declare crAreaDirectiona cursor for (select F1 as CodeSenderAddress from dbo.f_splitstr(@Cards,','))
	open crAreaDirectiona
	declare @CodeSenderAddress int
	fetch next from crAreaDirectiona into @CodeSenderAddress
	while @@fetch_status=0
	begin
		declare @CodeSenderDirlID int
		select @CodeSenderDirlID=CodeSenderDirlID from dbo.RT_DirectionalAntenna where CodeSenderAddress=@CodeSenderAddress
		if @CodeSenderDirlID>0
		begin
			declare @FStation varchar(10),@FStationHead varchar(10),@tmp varchar(20),@tmp1 varchar(20)
			declare @LStation varchar(10),@LStationHead varchar(10)
			set @tmp = dbo.GetValue((select DetectionInfo from dbo.CodeSender_DirectionalAntenna where CodeSenderDirlID = @CodeSenderDirlID),':',1)
			set @FStation = dbo.GetValue(@tmp,',',1)
			set @FStationHead = dbo.GetValue(@tmp,',',2)
			set @tmp1 = dbo.GetValue((select DetectionInfo from dbo.CodeSender_DirectionalAntenna where CodeSenderDirlID = @CodeSenderDirlID),':',2)
			set @LStation = dbo.GetValue(@tmp1,',',1)
			set @LStationHead = dbo.GetValue(@tmp1,',',2)
			-- 上个读卡不是区域内
			
			if (select count(ts.StationHeadID) from dbo.Territorial_Set as ts
			left join Station_Head_Info as shi on shi.StationAddress=@FStation and shi.StationHeadAddress=@FStationHead
			where ts.StationHeadID = shi.StationHeadID
			) = 0
			begin
				if not exists(select * from dbo.RT_AreaDirection
				where CodeSenderAddress =@CodeSenderAddress)
				-- 当前读卡分站是区域内的将数据写如表中
				insert into [RT_AreaDirection](AreaName,AreaTypeName,CodeSenderAddress,EmpName,InTime,InDirection)
				select ti.TerritorialName,tt.TypeName,@CodeSenderAddress,ei.EmpName,@DetectTime,cd.Directional from dbo.Territorial_Set as ts
				left join Station_Head_Info as shi on shi.StationAddress=@LStation and shi.StationHeadAddress=@LStationHead
				left join Territorial_Info as ti on ti.TerritorialID = ts.TerritorialID
				left join Territorial_Type as tt on tt.TerritorialTypeID = ti.TerritorialTypeID
				left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress=@CodeSenderAddress and cs.CsTypeID = 0
				left join dbo.Emp_Info as ei on ei.EmpID = cs.UserID
				left join dbo.CodeSender_DirectionalAntenna as cd on cd.CodeSenderDirlID=@CodeSenderDirlID
				where ts.StationHeadID = shi.StationHeadID
			end
			else
			begin
				if (select count(ts.StationHeadID) from dbo.Territorial_Set as ts
					left join Station_Head_Info as shi on shi.StationAddress=@LStation and shi.StationHeadAddress=@LStationHead
					where ts.StationHeadID = shi.StationHeadID) = 0
				begin
					declare @tabName varchar(50)
					set @tabName ='His_AreaDirection_'+LTRIM(RTRIM(DATEPART(year,getdate())))+LTRIM(RTRIM(DATEPART(Month,getdate())))
					exec ('INSERT INTO ['+@tabName+'](AreaName,AreaTypeName,CodeSenderAddress,EmpName
					,InTime,InDirection,OutDirection,OutTime,AreaWorkTime)
					select ra.AreaName,ra.AreaTypeName,ra.CodeSenderAddress,ra.EmpName,ra.InTime,ra.InDirection,cd.Directional,rd.NowTime
					,datediff(second,ra.InTime,rd.NowTime)
					from RT_AreaDirection as ra
					left join dbo.RT_DirectionalAntenna as rd on rd.CodeSenderAddress = ra.CodeSenderAddress
					left join dbo.CodeSender_DirectionalAntenna as cd on cd.CodeSenderDirlID='+@CodeSenderDirlID+'
					where ra.CodeSenderAddress = '+@CodeSenderAddress)
					delete from dbo.RT_AreaDirection where CodeSenderAddress= @CodeSenderAddress
				end
			end
		end
		
		fetch next from crAreaDirectiona into @CodeSenderAddress
	end
	close crAreaDirectiona
	deallocate crAreaDirectiona
end



--select * from CodeSender_DirectionalAntenna






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--实时表更新
CREATE  proc [dbo].[KJ128N_Insert_Update_RT_DirectionalAntenna]
/*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
As
begin
declare @tmp varchar(50)
set @tmp = ':'+LTRIM(RTRIM(@StationAddress))+','+LTRIM(RTRIM(@StationHeadAddress))
	declare crPROCAntenna cursor for (
			select CodeSenderAddress,
			LTRIM(RTRIM(StationAddress))+','+LTRIM(RTRIM(StationHeadAddress))+@tmp as DetectionInfo,StationHeadAntennaA,StationHeadAntennaB
			from dbo.RT_InOutStation
			where (convert(varchar(10),StationAddress)+'.'+convert(varchar(10),StationHeadAddress)) 
				<>(convert(varchar(10),@StationAddress)+'.'+convert(varchar(10),@StationHeadAddress))--去除未移动的卡
			and CodeSenderAddress in (select F1 as CodeSenderAddress from dbo.f_splitstr(@Cards,','))
			)	
	open crPROCAntenna
	declare @CodeSenderAddress int
	declare @DetectionInfo varchar(50)
	declare @A int 
	declare @B int 
	fetch next from crPROCAntenna into @CodeSenderAddress,@DetectionInfo,@A,@B
	while @@fetch_status=0
	begin
		declare @CodeSenderDirlID int
		--方向性描述
		select @CodeSenderDirlID=CodeSenderDirlID from dbo.CodeSender_DirectionalAntenna
		where DetectionInfo = @DetectionInfo
		if len(@CodeSenderDirlID) > 0
		begin
			declare @CsTypeID int
			--类型
			select @CsTypeID=css.CsTypeID from dbo.CodeSender_Info as cs	
			left join dbo.CodeSender_Set as css on css.CodeSenderID = cs.CodeSenderID
			where cs.CodeSenderAddress = @CodeSenderAddress
			if exists(select CodeSenderAddress from dbo.RT_DirectionalAntenna where CodeSenderAddress = @CodeSenderAddress)
			begin
				declare @oldCodeSenderDirlID int
				select @oldCodeSenderDirlID=CodeSenderDirlID from RT_DirectionalAntenna 
				where CodeSenderAddress = @CodeSenderAddress

				if len(@oldCodeSenderDirlID)>0 and (@CodeSenderDirlID <> @oldCodeSenderDirlID) 
				or (@CodeSenderDirlID = @oldCodeSenderDirlID and @A=0 and @B=0)
				begin
					/*历史进出读卡分站处理*/
					-- 进入下一个读卡分站时	
					-- 上次方向
					declare @oldDirectional varchar(100),@newDirectional varchar(100)
					select @oldDirectional=Directional from dbo.CodeSender_DirectionalAntenna
					where CodeSenderDirlID = @oldCodeSenderDirlID
					-- 当前方向
					select @newDirectional=Directional from dbo.CodeSender_DirectionalAntenna
					where CodeSenderDirlID = @CodeSenderDirlID
					-- 所在传输、读卡分站 进出时间
					
					declare @tabName varchar(50)
					set @tabName = 'His_InOutReceiver_'+LTRIM(RTRIM(DATEPART(year,getdate())))+LTRIM(RTRIM(DATEPART(Month,getdate())))
					if exists (select * from dbo.sysobjects where id = object_id(N'[dbo].['+@tabName+']') and OBJECTPROPERTY(id, N'IsUserTable') = 1)
					begin
						declare @t varchar(1000)
						print '--------------------------------------------'
						print @oldDirectional+':'+@newDirectional
						print '--------------------------------------------'
						set @t='insert into '+@tabName
						+' (CodeSenderAddress,Name,Station,StationHead,StationHeadPlace,InTime,OutTime,InDirection,OutDirection)
						select '+LTRIM(RTRIM(@CodeSenderAddress))+',ei.EmpName,ri.StationAddress,ri.StationHeadAddress,shi.StationHeadPlace
						,ri.StationHeadDetectTime,'+char(39)+Convert(varchar(20),@DetectTime,120)+char(39)+','+char(39)+@oldDirectional+char(39)+','+char(39)+@newDirectional+char(39)+'
						from RT_InOutStation  as ri
						left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress = '+LTRIM(RTRIM(@CodeSenderAddress))+'
						left join dbo.Emp_Info as ei on ei.EmpID = cs.UserID and CsTypeID=0
						left join dbo.Station_Head_Info as shi on shi.StationAddress = ri.StationAddress 
						and shi.StationHeadAddress = ri.StationHeadAddress
						where ri.CodeSenderAddress = '+LTRIM(RTRIM(@CodeSenderAddress))
						print (@t)
						exec (@t)
					end				
				end

				-- 修改实时数据
				update RT_DirectionalAntenna
				set CsTypeID= @CsTypeID,Antenna = @StationHeadAddress,Station=@StationAddress
				,CodeSenderDirlID=@CodeSenderDirlID,NowTime = @DetectTime 
				where CodeSenderAddress = @CodeSenderAddress
				-- 历史
				exec KJ128N_Insert_His_Directional @CodeSenderAddress,@StationAddress,@StationHeadAddress
				,@DetectTime,@CodeSenderDirlID,@CsTypeID,@DetectionInfo
			end
			else
			begin
				-- 添加实时数据
				insert into RT_DirectionalAntenna(CodeSenderAddress,CsTypeID,Antenna,Station,CodeSenderDirlID,NowTime)
				values(@CodeSenderAddress,@CsTypeID,@StationHeadAddress,@StationAddress,@CodeSenderDirlID,@DetectTime)
				-- 历史
				exec KJ128N_Insert_His_Directional @CodeSenderAddress,@StationAddress,@StationHeadAddress
				,@DetectTime,@CodeSenderDirlID,@CsTypeID,@DetectionInfo
			end
		end
		else
		begin
			--如果没有方向性，则清空该发码器的方向性
			delete from dbo.RT_DirectionalAntenna where CodeSenderAddress = @CodeSenderAddress
		end
		fetch next from crPROCAntenna into @CodeSenderAddress,@DetectionInfo,@A,@B
	end
	close crPROCAntenna
	deallocate crPROCAntenna
end




SET QUOTED_IDENTIFIER ON 



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


create  proc KJ128N_QueryEmployeeInfo_ByWorkTypeID  @WorkTypeID int as 

select EmpID,员工姓名 from KJ128N_Emp_Table where WorkTypeID = @WorkTypeID





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc KJ128N_Query_HistorySpecialWorkTypeTerrial @PageIndex int,@PageSize int,@Where varchar(2000) as

declare @sql varchar(2000)
declare @strsql varchar(3000)
declare @strsql1 varchar(3000)

set @sql = 'select HisTerritorialID,CodeSenderAddress 发码器编号,UserName 员工姓名,WtName 所属工种,TerritorialTypeName 区域类型,TerritorialName 区域名称 
,InTerritorialTime 进入区域时间,OutTerritorialTime 离开区域,StayTime 在区域滞留时长 from view_HistoryInOutTerrialAlarm where 1=1 '+@Where

set @strsql1 = 'select count(1) from ('+@sql+') as A'

if @PageIndex = 1
begin
	set @strsql = 'select top '+str(@PageSize)+' 发码器编号,员工姓名,所属工种,区域类型,区域名称,进入区域时间,离开区域,在区域滞留时长 from ('+@sql+') as A order by HisTerritorialID'
end
else
begin
	set @strsql = 'select top '+str(@PageSize)+' 发码器编号,员工姓名,所属工种,区域类型,区域名称,进入区域时间,离开区域,在区域滞留时长 
from ('+@sql+') as A 
where HisTerritorialID>(select max(HisTerritorialID) 
from (select top '+str((@PageIndex-1)*@PageSize)+' HisTerritorialID 
from ('+@sql+') as C order by HisTerritorialID) as B)
order by HisTerritorialID'

end

exec(@strsql)

PRINT @strsql
exec(@strsql1)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create proc KJ128N_Query_RealTimeTerrialAlarm @PageIndex int,@PageSize int,@Where varchar(2000) as

declare @sql varchar(2000)
declare @strsql varchar(3000)
declare @strsql1 varchar(3000)

set @sql = 'select RTTerritorialID,CodeSenderAddress 发码器编号,EmpName 员工姓名,WtName 所属工种,
TerritorialTypeName 区域类别,TerritorialName 区域名称,InTerritorialTime 进入区域时刻,
dbo.FunConvertTime(Datediff(second,InTerritorialTime,getdate())) 滞留时长  
 from View_RealTimeTerrialAlarm where IsAlarm =1 '+@Where 

set @strsql1 = 'select count(1) from ('+@sql+') as D'

if @PageIndex = 1
begin
	set @strsql = 'select top '+str(@PageSize)+' 发码器编号,员工姓名,所属工种,区域类别,区域名称,进入区域时刻,滞留时长 
from ('+@sql+') as A 
order by  RTTerritorialID'
end
else
begin
	set @strsql = 'select top '+str((@PageIndex -1)*@PageSize)+' 发码器编号,员工姓名,所属工种,区域类别,区域名称,进入区域时刻,滞留时长 
from ('+@sql+') as A where RTTerritorialID>(select max(RTTerritorialID) from (select top '+str((@PageIndex -1)*@PageSize)+' RTTerritorialID 
from ('+@sql+') as D order by RTTerritorialID) as C) Order by RTTerritorialID' 
end
 

exec(@strsql)
exec(@strsql1) 



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


create proc KJ128N_Query_SpecialWorkTypeTerrial @PageIndex int,@PageSize int, @Where varchar(2000) 
as 



declare @Sql varchar(3000)

declare @Sql1 varchar(4000)

declare @Strsql varchar(4000)


set @Sql = 'select TerriAlarmID,CodeSenderAddress 发码器编号,EmpName 员工姓名,WtName 所属工种,TerritorialName 区域名称,TypeName 区域类别,IsAlarm 是否报警 from View_SpecialWorkTypeTerrialSet where 1=1 '+@Where

set @Strsql = 'select Count(1) from ('+@Sql+') as D'
if @PageIndex = 1
begin
set @Sql1 = 'select top '+str(@PageSize)+'TerriAlarmID, 发码器编号,员工姓名,所属工种,区域名称,区域类别,是否报警 from ('+@Sql+') as A order by TerriAlarmID'


end
else
begin

set @Sql1 = 'select top '+str(@PageSize)+'TerriAlarmID, 发码器编号,员工姓名,所属工种,区域名称,区域类别,是否报警 from ('+@Sql+') as A 
where TerriAlarmID>(select max(TerriAlarmID) 
from (select top '+str((@PageIndex -1)*@PageSize)+' TerriAlarmID 
from ('+@Sql+') as A 
order by TerriAlarmID) as B) 
order by TerriAlarmID'

end

exec(@Sql1)
EXEC(@Strsql)








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



CREATE   proc KJ128N_Query_TerrialInfo  @TerrialTypeID int as 

if(@TerrialTypeID = 0)
begin

select * from dbo.Territorial_Info

end
else
begin
select * from dbo.Territorial_Info where TerritorialTypeID=@TerrialTypeID
end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create proc KJ128N_Query_TerrialType as 

select * from dbo.Territorial_Type


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



create procedure KJ128N_Query_UncommanData @PageIndex int,@PageSize int,@Where varchar(500)
as

declare @sql varchar(2000)
declare @sql1 varchar(4000)

set @sql = 'select ID,CodersonderAddress 发码器编号,StationAddress 分站编号,StaionHeadAddress 接收器编号,
InTime 进入接收器时间,OutTime 离开接收器时间,CurrentTime 接到数据的时间 from dbo.UnCommanTable where '+@Where

if @PageIndex = 1
begin
set @sql1 = 'select top '+str(@PageSize)+' 发码器编号,分站编号,接收器编号,进入接收器时间,离开接收器时间,接到数据的时间 from ('+@sql+') as A order by ID'

end
else
begin

set @sql1 = 'select top '+str((@PageIndex -1)*@PageSize)+' 发码器编号,分站编号,接收器编号,进入接收器时间,离开接收器时间,
接到数据的时间 from ('+@sql+') as A 
where ID >(select max(ID) 
from (select top '+str((@PageIndex -1)*@PageSize)+') ID 
from ('+@sql+') as B order by ID) order by ID'
end


exec(@sql1) 

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


create  proc KJ128N_Query_WorkType  as 

select * from dbo.WorkType_Info





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





CREATE    proc KJ128N_RTDirectionalAll_Select
(
  @sumType int,
  @strName nvarchar(20),
  @DeptName nvarchar(2000),
  @CodeSenderAddress nvarchar(20),
  @StationAddress int,
  @StaHeadAddress int,
  @strDirectional nvarchar(2000)
)
as

declare @Where varchar(2500)
declare @Select varchar(5000)
declare @IntervalTime int
select @IntervalTime = EnumValue From EnumTable Where FunID=14 And EnumID=0

set @Where=' CsTypeID='+str(@sumType)
if(@strName<>'')
	set @Where =@Where +' And 名称 like ''%'+@strName+'%'''
if(@DeptName<>'')
	set @Where =@Where +' And ( 部门='+@DeptName+') '
if(@CodeSenderAddress<>'')
	set @Where =@Where +' And 发码器='+@CodeSenderAddress
if(@StationAddress<>0)
	set @Where =@Where +' And 分站地址='+str(@StationAddress)
if(@StaHeadAddress<>0)
	set @Where =@Where +' And 接收器地址='+str(@StaHeadAddress)
if(@strDirectional<>'')
	set @Where =@Where +' And 方向性描述 like ''%'+@strDirectional+'%'''
set @Select ='
select *
From
(
select Rc.CodeSenderAddress as 发码器,
	名称=case when Cs.CsTypeID=0 then EmpName when Cs.CsTypeID=1 then EquName end,
	部门= case when Cs.CsTypeID=0 then Di1.DeptName when Cs.CsTypeID=1 then Di2.DeptName end,
	Rc.StationAddress as 分站地址,
	Rc.StationHeadAddress as 接收器地址,
	Cd.Directional as  方向性描述,
	StationHeadDetectTime as 监测时间,
	Cs.CsTypeID
From RealTimeCodeSender as Rc inner join CodeSender_Directional as Cd on Cd.DetectionInfo=Rc.CodeSenderDirectional  
left join CodeSender_Set as Cs on Cs.CsSetID=Rc.CsSetID  
left join Station_Head_Info as Shi on Shi.StationAddress=Rc.StationAddress and Shi.StationHeadAddress=Rc.StationHeadAddress
inner join Station_Info as Si on Si.StationAddress= Rc.StationAddress 
left join Emp_Info as Ei on Ei.EmpID=Cs.UserID and Cs.CsTypeID=0
left join Emp_NowCompany as Enc on Enc.EmpID=Ei.EmpID 
left join Dept_Info as Di1 on Di1.DeptID=Enc.DeptID 
left join Equ_BaseInfo as Eqi on Eqi.EquID=Cs.UserID and Cs.CsTypeID=1
left join Dept_Info as Di2 on Di2.DeptID=Eqi.DeptID

where StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<'+str(@IntervalTime)+' 
union
	select Rc.CodeSenderAddress as 发码器,
	名称=case when Cs.CsTypeID=0 then EmpName when Cs.CsTypeID=1 then EquName end,
	部门= case when Cs.CsTypeID=0 then Di1.DeptName when Cs.CsTypeID=1 then Di2.DeptName end,
	Rc.StationAddress as 分站地址,
	Rc.StationHeadAddress as 接收器地址,
	Cd.Directional as  方向性描述,
	StationHeadDetectTime as 监测时间,
	Cs.CsTypeID
From RealTimeCodeSender as Rc inner join CodeSender_Directional as Cd on Cd.DetectionInfo=Rc.CodeSenderDirectional  
left join CodeSender_Set as Cs on Cs.CsSetID=Rc.CsSetID  
left join Station_Head_Info as Shi on Shi.StationAddress=Rc.StationAddress and Shi.StationHeadAddress=Rc.StationHeadAddress
inner join Station_Info as Si on Si.StationAddress= Rc.StationAddress  
left join Emp_Info as Ei on Ei.EmpID=Cs.UserID and Cs.CsTypeID=0
left join Emp_NowCompany as Enc on Enc.EmpID=Ei.EmpID 
left join Dept_Info as Di1 on Di1.DeptID=Enc.DeptID 
left join Equ_BaseInfo as Eqi on Eqi.EquID=Cs.UserID and Cs.CsTypeID=1
left join Dept_Info as Di2 on Di2.DeptID=Eqi.DeptID
where  StationHeadTypeID<>8 
) as tempTable
where ' +@Where
exec(@Select)








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--declare @sumType int
CREATE  proc KJ128N_RTDirectional_Select
(
 @sumType int
)
as

declare @Where varchar(8000)
declare @IntervalTime int
select @IntervalTime = EnumValue From EnumTable Where FunID=14 And EnumID=0

begin 
Select  Directional= case when Directional is null then '未知方向' else Directional end ,  
count(*) as counts , 
StationPlace,  
StationAddress
From 
(select Rc.CodeSenderAddress,Directional,Si.StationPlace,Rc.StationAddress,CsTypeID
From RealTimeCodeSender as Rc inner join CodeSender_Directional as Cd on Cd.DetectionInfo=Rc.CodeSenderDirectional  
left join CodeSender_Set as Cs on Cs.CsSetID=Rc.CsSetID  
left join Station_Head_Info as Shi on Shi.StationAddress=Rc.StationAddress and Shi.StationHeadAddress=Rc.StationHeadAddress
inner join Station_Info as Si on Si.StationAddress= Rc.StationAddress  
where CsTypeID=@sumType and StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime 
union
	select Rc.CodeSenderAddress,Directional,Si.StationPlace,Rc.StationAddress,CsTypeID
From RealTimeCodeSender as Rc inner join CodeSender_Directional as Cd on Cd.DetectionInfo=Rc.CodeSenderDirectional  
left join CodeSender_Set as Cs on Cs.CsSetID=Rc.CsSetID  
left join Station_Head_Info as Shi on Shi.StationAddress=Rc.StationAddress and Shi.StationHeadAddress=Rc.StationHeadAddress
inner join Station_Info as Si on Si.StationAddress= Rc.StationAddress  
where CsTypeID=@sumType and StationHeadTypeID<>8
 ) As tempTable
--Where CsTypeID=0
Group By  Directional , StationPlace ,StationAddress 

end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


-- AdminName,OperateContent,OperateTime,Remark 

-- (向 OperateLog 表中的添加管理员姓名，操作内容，操作时间，备份)

create Proc KJ128N_SaveLog
(
	@AdminName varchar(30),
	@OperateContent varchar(200),
	@OperateTime datetime,
	@Remark varchar(100)
)
As
begin
	insert into OperateLog(AdminName,OperateContent,OperateTime,Remark)
values (@AdminName,@OperateContent,@OperateTime,@Remark)
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE    proc KJ128N_Station_Info_Select_TreeView
As
select * from KJ128N_Station_Head_Info order by StationID





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE  procedure KJ128N_Station_OutStationType_Query
as 
select ltrim(str(StationAddress))+','+ltrim(str(StationHeadAddress)) StationAddressAndStationHeadAddress,StationHeadPlace 
from dbo.Station_Head_Info where StationHeadTypeID = 8

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE     proc KJ128N_Update_CodeSenderLow 
		-- 探头号
	@Cards varchar(6000)

as
-- 如果天线A 天线B 都是1,1 说明发码器的电量低

begin
UPDATE [dbo].[CodeSender_Info]
SET 
	[CodeSenderStateID]=4, [CodeSenderStateTime] = getDate() --设置状态为4, 表示低电量
from (select F1 from dbo.f_splitstr(@Cards,',')) as T1
left join CodeSender_Info CSI On CSI.CodeSenderAddress=T1.F1
where T1.F1<>4

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE   proc KJ128N_Update_SpecialWorkTypeTerrial @ID int,@EmpID int,@AreaID int,@WorkTypeID int,@IsAlarm bit,@Remark nvarchar(300),@Where nvarchar(200) 
as 

declare @sql nvarchar(2000)

set @sql = 'update SpecialWorkTypeTerrialSet set EmployeeID = '+str(@EmpID)+',TerrialID = '+str(@AreaID)+',WorkTypeID = '+str(@WorkTypeID)+',IsAlarm = '+str(@IsAlarm)+',Remark = '+str(@Remark)+' where 1=1 '+@Where

exec(@sql)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE proc KJ128_EmpIO
@empid int,
@empname varchar(20),
@empno varchar(20),
@codesenderaddress varchar(20),
@home varchar(20),
@idcard varchar(50),
@deptname varchar(20),
@dutyname varchar(20),
@wtname varchar(20)
AS
BEGIN
if not exists (select * from emp_info where empno=@empno and empname=@empname)
begin
    insert into emp_info (empid,empname,sex,remark,empno) values(@empid,@empname,0,'',@empno)
end
if exists (select * from emp_home where empid =@empid)
begin
update emp_home set homeaddress=@home,postalcode='',remark='' where empid=@empid
end
else
begin
insert into emp_home (EmpHomeID,empid,homeaddress,remark) values(@empid,@empid,@home,'')
end
if exists (select * from Emp_Detail where empid=@empid)
begin
update Emp_Detail set idcard=@idcard where empid=@empid
end
else
begin
insert into Emp_Detail (EmpDetailID,empid,idcard) values(@empid,@empid,@idcard)
end
if exists (select * from Emp_NowCompany where empid=@empid)
begin
update Emp_NowCompany set deptid=(select deptid from dept_info where deptname=@deptname),dutyid=(select dutyid from Duty_Info where dutyname=@dutyname) 
where empid=@empid
end
else
begin
insert into Emp_NowCompany (EmpNowCoID,empid) values(@empid,@empid)
update Emp_NowCompany set deptid=(select deptid from dept_info where deptname=@deptname),dutyid=(select dutyid from Duty_Info where dutyname=@dutyname) 
where empid=@empid
end
if exists (select * from WorkType_Info where wtname=@wtname)
begin
if exists (select * from Emp_WorkType where empid=@empid)
begin
update Emp_WorkType set worktypeid=(select worktypeid from WorkType_Info where wtname=@wtname),IsEnable=1 where empid=@empid
end
else
begin
declare @worktypeid int
select @worktypeid=worktypeid from WorkType_Info where wtname=@wtname
insert into Emp_WorkType (EmpWorkTypeID,empid,worktypeid,IsEnable) values(@empid,@empid,@worktypeid,1)
end
end
if(@codesenderaddress<>'')
begin
if not exists (select * from CodeSender_Info where codesenderaddress=@codesenderaddress)
begin
  insert into CodeSender_Info values(@codesenderaddress,@codesenderaddress,1,1,1,null,null)
end
if exists (select * from CodeSender_Set where userid=@empid)
begin
update CodeSender_Set set codesenderaddress=@codesenderaddress,codesenderid=(select codesenderid from CodeSender_Info where codesenderaddress=@codesenderaddress)
where userid=@empid
end
else
begin
declare @codesenderid int
select @codesenderid=codesenderid from CodeSender_Info where codesenderaddress=@codesenderaddress
insert into CodeSender_Set values(@codesenderaddress,@codesenderid,@codesenderaddress,@empid,0,null)
end
end
END










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc KJ128_WorkTypeIO
@wtid int,
@wtname varchar(20)
as
begin
if exists (select top 1 CerTypeID from Certificate_Info)
begin
if not exists (select * from WorkType_Info where wtname=@wtname)
begin
declare @CerTypeID int
set @CerTypeID=(select top 1 CerTypeID from Certificate_Info)
insert into WorkType_Info values(@wtid,@wtname,@CerTypeID,null)
end
end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create  proc MenuInsert
@Pname varchar(50),
@Title varchar (50),
@name varchar (50)

as 


declare  @id int 
declare @pid int  
set @id = -1
set @pid = -1 
select  @id =id  from menus1 where name = @name
select  @pid =id from menus1 where name = @Pname


if @id =-1 
begin 
INSERT INTO [KJ128N].[dbo].[menus1]( [PMenuID], [Title],  name)
VALUES(@pid, @Title, @name)
end 
else
begin
UPDATE menus1
 SET  [PMenuID]=@pid, [Title]=@Title, [name]=@name
WHERE id =@id
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




/*
   行进测速
*/
CREATE       Proc OverSpeed_Info
(
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)			-- 标识卡号
)
As
begin

declare @FirstCounts int	--第一个测点的数量
declare @FirstCounts_Temp int	--第一个测点的数量_临时变量（用于While循环）

Declare @LastStationAddress int		--最后一个测点的基站编号
declare @LastStationHeadAddress int	--最后一个测点的探头编号
declare @WalkTime int			--规定行走时间(超速)
declare @LackWalkTime int		--规定行走时间(欠速)

Declare @sql nvarchar(3000)

Set @FirstCounts=(Select Count(1) From OverSpeed Where FirstStationAddress=@StationAddress And FirstStationHeadAddress=@StationHeadAddress )

if(@FirstCounts is not null and @FirstCounts>0)
begin

	--if(exists(Select HisOverSpeedID From His_OverSpeed Where FirstStationAddress=@StationAddress and FirstStationHeadAddress = @StationHeadAddress and IsOutWell=0))
	--begin
		update His_OverSpeed 
		Set FirstMonitoringTime=@DetectTime
		Where FirstStationAddress=@StationAddress and FirstStationHeadAddress = @StationHeadAddress and IsOutWell=0 
			and IsEnd=0 and CodeSenderAddress in(Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0)
	--end
	--else
	begin
		set @FirstCounts_Temp=1
--print @FirstCounts
		while(@FirstCounts_Temp<=@FirstCounts)
		begin
--print '------------------------'
--print @FirstCounts_Temp
			Set @sql= 'Select @LastStationAddress=LastStationAddress,@LastStationHeadAddress=LastStationHeadAddress,@WalkTime=WalkTime,@LackWalkTime=LackWalkTime
				From ( Select top 1 * From OverSpeed Where OverSpeedID>=(Select max(OverSpeedID) From ( Select top '+ str(@FirstCounts_Temp) +' * From OverSpeed 
					Where FirstStationAddress=@StationAddress and FirstStationHeadAddress = @StationHeadAddress order by OverSpeedID ) as B) And FirstStationAddress=@StationAddress and FirstStationHeadAddress = @StationHeadAddress 
				order by OverSpeedID
				) as A'
			exec sp_executesql @sql,N'@LastStationAddress int output,@LastStationHeadAddress int output,@WalkTime int output,@LackWalkTime int output,@StationAddress int,@StationHeadAddress int',@LastStationAddress output,@LastStationHeadAddress output,@WalkTime output,@LackWalkTime output,@StationAddress,@StationHeadAddress
	
			insert into His_OverSpeed(CodeSenderAddress,CsTypeID,UserID,FirstStationAddress,FirstStationHeadAddress,FirstMonitoringTime,
				LastStationAddress,LastStationHeadAddress,WalkTime,IsOverSpeed,DeptName,DutyName,WtName,IsOutWell,IsEnd,EmpName,LackWalkTime,IsLackSpeed)
			select F1 As CodeSenderAddress,Css.CsTypeID,Css.UserID,@StationAddress,@StationHeadAddress,@DetectTime,@LastStationAddress,
				@LastStationHeadAddress,@WalkTime,0,Dei.DeptName,Dui.DutyName,Wti.WtName,0,0,Ei.EmpName,@LackWalkTime,0
			From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				left join  CodeSender_Set As Css On Css.CodeSenderAddress=T1.F1
				left join Emp_Info as Ei on Css.UserID=Ei.EmpID and Css.CsTypeID=0
				Left join Emp_NowCompany as Enc on Css.UserID=Enc.EmpID and Css.CsTypeID=0
				left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
				left join Duty_Info as Dui on Enc.DutyID=Dui.DutyID
				Left Join Emp_WorkType as Ewt on Ewt.EmpID=Css.UserID and Css.CsTypeID=0
				Left Join WorkType_Info as Wti on  Ewt.WorkTypeID = Wti.WorkTypeID
			where Css.CsTypeID=0 and F1 not in(Select CodeSenderAddress From His_OverSpeed Where FirstStationAddress=@StationAddress 
				and FirstStationHeadAddress=@StationHeadAddress and LastStationAddress=@LastStationAddress and LastStationHeadAddress=@LastStationHeadAddress and IsOutWell=0 and CsTypeID=0)
			Set @FirstCounts_Temp=@FirstCounts_Temp+1
--print @LastStationAddress
--print @LastStationHeadAddress

		end
	end
end


declare @FirstMonitoringTime datetime 	--经过第一个测点的时间
declare @WalkTime_Last int	--额定行走时间(超速)
declare @IsOverSpeed_Temp bit	--是否超速

declare @LackWalkTime_Last int	--额定行走时间(欠速)
declare @IsLackSpeed_Temp bit	--是否欠速


declare @HisOverSpeedID int	--ID


--定义游标
declare HisOverSpeedLast cursor for (select HisOverSpeedID from His_OverSpeed Where LastStationAddress=@StationAddress and LastStationHeadAddress=@StationHeadAddress and
					 IsOutWell=0 and IsEnd=0 and CodeSenderAddress in (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0))
--打开游标
open HisOverSpeedLast
--移到下一行
fetch next from HisOverSpeedLast into @HisOverSpeedID
while (@@FETCH_STATUS <> -1)
begin
	if @HisOverSpeedID is not null 
	begin
		--print @HisOverSpeedID
		Select @FirstMonitoringTime=FirstMonitoringTime,@WalkTime_Last=WalkTime,@LackWalkTime_Last=LackWalkTime From His_OverSpeed Where HisOverSpeedID=@HisOverSpeedID
		if(@FirstMonitoringTime is not null)
		begin
			/****************超速****************/
			if(@WalkTime_Last<>-1)
			begin
				if(DATEDIFF(ss,@FirstMonitoringTime,@DetectTime)<@WalkTime_Last)
				begin
					Set @IsOverSpeed_Temp=1
				end
				else
				begin
					Set @IsOverSpeed_Temp=0
				end
			end

			/****************欠速****************/			
			if(@LackWalkTime_Last<>-1)
			begin
				if(DATEDIFF(ss,@FirstMonitoringTime,@DetectTime)>@LackWalkTime_Last)
				begin
					Set @IsLackSpeed_Temp=1
				end
				else
				begin
					Set @IsLackSpeed_Temp=0
				end
			end

			update His_OverSpeed 
			Set LastMonitoringTime=@DetectTime,IsOverSpeed=@IsOverSpeed_Temp,IsEnd=1,IsLackSpeed=@IsLackSpeed_Temp
			Where HisOverSpeedID=@HisOverSpeedID
		end
	end
	fetch next from HisOverSpeedLast into @HisOverSpeedID

end
--关闭游标
close HisOverSpeedLast
--释放游标
deallocate HisOverSpeedLast

end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE   proc OverSpeed_OutWell
(
	@Cards  varchar(6000)
)
as
begin

	update His_OverSpeed
	Set IsOutWell =1
	Where IsEnd=1 and CodeSenderAddress in(Select Distinct F1 FROM f_splitstr(@Cards, ',')) and IsOutWell=0

	Delete From His_OverSpeed 
	Where IsOutWell=0 and CodeSenderAddress in(Select Distinct F1 FROM f_splitstr(@Cards, ','))

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  proc PROC_GetRTDeptSmallInfo
(
@displayType int	--0人员 1设备 2所有发码器
)
as
begin
declare @where varchar(100)
if @displayType = 0
	set @where = ' csset.CsTypeID =0 and r.CsSetID = csset.CsSetID'
else if @displayType = 1
	set @where = ' csset.CsTypeID =1 and r.CsSetID = csset.CsSetID'
else if @displayType = 2
	set @where = ' r.CsSetID = csset.CsSetID'
declare @tmpString varchar(500)
	set @tmpString ='
	select di.DeptID,di.DeptName,(select count(r.CsSetID) from RealTimeCodeSender as r
	inner join Emp_NowCompany as enc on enc.DeptID = di.DeptID
	inner join CodeSender_Set as csset on csset.UserID = enc.EmpID
	where '+@where+'
	) as sumCard
	from dbo.Dept_Info as di'
exec (@tmpString)
exec ('select count(r.CsSetID) from RealTimeCodeSender as r
	left join CodeSender_Set as csset on'+@where+'
')
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
修改日期：2008-6-12
修改人：丁
功能：去除重复卡号
*/

CREATE     Proc PROC_GetRTDisplayStationHeadInfo
(
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸     
	@sumType int,
	@tblName	VarChar(255)='View_GetStation',		--表名或视图表
	@keyField	VarChar(255)='StationHeadID',		--主键
	@fieldList	VarChar(2000) = 'StationAddress,StationHeadAddress,StationHeadPlace
			,StationHeadState,AntennaA,AntennaB',	--欲选择字段列表
	@orderField	VarChar(255)='StationAddress,StationHeadAddress',		--排序字段
	@strWhere	VarChar(4000)='1=1',		--条件
	@orderType	bit =0			--排序,1,降序,0,升序

)
As
	SET NOCOUNT ON
declare @typeWhere varchar(100)
declare @where varchar(2000)
--set @sumType = 2
-- 判断条件 0人员 1设备 2所有
if @sumType = 0
	set @typeWhere = ' and css.CsTypeID = 0'
else if @sumType = 1
	set @typeWhere = ' and css.CsTypeID = 1'
else if @sumType = 2
	set @typeWhere = ' '

set @where = ',(select count(DISTINCT rtcs.CodeSenderAddress)
			from RT_InOutStation as rtcs
			inner join CodeSender_Set as css on css.CodeSenderID = rtcs.CodeSenderID
			where rtcs.StationAddress = shi.StationAddress and rtcs.StationHeadAddress = shi.StationHeadAddress
			and rtcs.InStationHeadAntenna=1'+@typeWhere+') as SumCardA,
(select count(DISTINCT rtcs.CodeSenderAddress)
			from RT_InOutStation as rtcs
			inner join CodeSender_Set as css on css.CodeSenderID = rtcs.CodeSenderID
			where rtcs.StationAddress = shi.StationAddress and rtcs.StationHeadAddress = shi.StationHeadAddress
			and rtcs.InStationHeadAntenna=2'+@typeWhere+') as SumCardB'
print @where
set @fieldList = @fieldList +@where
	Declare @strSql VarChar(6000)

	--处理SQL中危险字符,并且将条件处理成易嵌入的形式     
	set @strWhere = replace(@strWhere,'''','''''')     
	set @strWhere = replace(@strWhere,'--','')     
	set @strWhere = replace(@strWhere,';','')     
	set @strSql = 'declare @CurPageNum int;'
	set @strSql = @strSql + 'declare @nextpagenum int;'
	set @strSql = @strSql + 'set @curpagenum = ' + cast(@PageIndex as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'set @nextpagenum = ' + cast(@PageIndex + 1 as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'declare @strSql varchar(6000);'     
	If @orderType = 1
	Begin
		Set @strSql = @strSql + 'set @strSql=''select '+ @fieldList + 
			' from(select top ''+cast(@nextpagenum as varchar)+'' * from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + 
			' desc) as shi where ' + @keyField + ' not in(select top '' + cast(@curpagenum as varchar) + '' ' + 
			@keyField + ' from ' + @tblName + ' where ' + @strWhere + 'order by ' + 
			@orderField + ' desc)order by ' + @orderField + ' desc'';'   
	End
	Else
	Begin
		Set @strSql = @strSql + 'Set @strSql=''select ' + @fieldList + 
			' from (select top '' + cast(@nextpagenum as varchar) + '' * from ' + @tblName + 
			' where ' + @strWhere + ' order by ' + @orderField + ' asc) as shi where ' + @keyField + 
			' not in (select top '' + cast(@curpagenum as varchar)+'' ' + @keyField + ' from ' + 
			@tblName + ' where ' + @strWhere + ' order by ' + @orderField + ' asc)order by ' + @orderField + ' asc'';'
	End
	Set @strSql = @strSql + 'execute(@strSql)'
	Execute(@strSql)
	print @strSql
	If (@strWhere = '')
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + '];''execute(@strSql);'
	Else
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName + ']'+' where ' + @strWhere + ';''execute(@strSql);'
	Exec (@strSQL)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE       proc PROC_GetRTStaHeadCodeInfo
(
  @StationAddress int,
  @StationHeadAddress int,
  @sumType int			--sumType 0人员 1设备 2卡 
  
)
as
/*
declare  @StationAddress int
declare @StationHeadAddress int
declare @sumType int
set @StationAddress=6
set @StationHeadAddress=0
set @sumType=2

*/
declare @Where varchar(8000)
declare @IntervalTime int
select @IntervalTime = EnumValue From EnumTable Where FunID=14 And EnumID=0

begin 
   if(@sumType=2)
      begin
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime
	union
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and StationHeadTypeID<>8 --and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime
      end
   else
      begin
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime and CsTypeID=@sumType
	union
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and StationHeadTypeID<>8 and CsTypeID=@sumType
      end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE       proc PROC_GetRTStationCodeInfo
(
  @StationAddress int,
--  @StationHeadAddress int,
  @sumType int			--sumType 0人员 1设备 2卡 
  
)
as
/*
declare  @StationAddress int
declare @StationHeadAddress int
declare @sumType int
set @StationAddress=5
set @StationHeadAddress=0
set @sumType=2

*/
declare @Where varchar(8000)
declare @IntervalTime int
select @IntervalTime = EnumValue From EnumTable Where FunID=14 And EnumID=0

begin 
   if(@sumType=2)
      begin
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress  and StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime
	union
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress  and StationHeadTypeID<>8 --and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime
      end
   else
      begin
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress  and StationHeadTypeID=8 and DATEDIFF(second, StationHeadDetectTime, getdate())<@IntervalTime and CsTypeID=@sumType
	union
	select 发码器,名称,配置类型,部门,方向性,监测时间 From KJ128N_RTStaHeadCode_Info where StationAddress=@StationAddress  and StationHeadTypeID<>8 and CsTypeID=@sumType
      end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
修改日期：2007-11-11
功能： 增加如果是上井口基站，则判断时间
修改日期：2008-6-12
修改人：丁
功能：去除重复卡号
*/
CREATE           proc PROC_GetRTStationHeadInfo
(
@addressList varchar(2000),
@sumType int 			--0人员 1设备 2卡
)
as
begin 

declare @intervalTime bigint -- 获取间隔时间
select @intervalTime=EnumValue from dbo.EnumTable
where FunID=14 and EnumID=0
--print @intervalTime
--创建游标
	declare cr cursor for (
		select StationHeadState,aa.StationAddress,StationHeadAddress
			,StationHeadPlace,AntennaA,AntennaB,aa.StationHeadTypeID
		from Station_Head_Info as aa
		right join Station_Info as si on si.StationAddress = aa.StationAddress
		and si.EditBaseInfo !=-1
		where aa.StationAddress in 
		(select * from Array_Split(@addressList,','))
		)
                order by aa.StationAddress,aa.StationHeadAddress
	open cr
	declare @tmpTab table (StationHeadState int,StationAddress int,StationHeadAddress int,
          Antenna int,StationHeadPlace varchar(50),HeadAntennaName varchar(20)
	,SumCard int)
	declare @StationHeadState int
	declare @StationAddress int
	declare @StationHeadAddress int
	declare @StationHeadPlace varchar(50)
	declare @AntennaA varchar(20)
	declare @AntennaB varchar(20)
        declare @StationHeadTypeID int -- 探头类型 8 上井口基站
	declare @Sum int
--print 'ok'
	fetch next from cr into @StationHeadState,
        @StationAddress,@StationHeadAddress,@StationHeadPlace,@AntennaA,@AntennaB,@StationHeadTypeID
--print 'ok1'
	while @@fetch_status=0
	begin
               
		--@StationHeadPlace,@AntennaA,@AntennaB
		--判断显示类型
		if @sumType = 0
		begin
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress 
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID	
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=1 and css.CsTypeID = 0
                        and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp1)
                       
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=2 and css.CsTypeID = 0
			and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp2)
--print 'sumType=0'


                         
		end
		else if @sumType = 1
		begin
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=1 and css.CsTypeID = 1
			and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp1)
			
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress 
                        and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=2 and css.CsTypeID = 1
			and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp2)
--print 'sumType=1'
               
		end
		else if @sumType = 2
		begin
		        insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress
			from RealTimeCodeSender as rtcs
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=1
			and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp1)

			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,
			(select count(1) from (select DISTINCT rtcs.CodeSenderAddress
			from RealTimeCodeSender as rtcs
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.LastInStationHeadAntenna=2
			and (@StationHeadTypeID<>8 or (@StationHeadTypeID=8 
			and datediff(second,rtcs.StationHeadDetectTime,getdate())<@intervalTime))
			) as tmp2)
		end	
		fetch next from cr into @StationHeadState,@StationAddress,@StationHeadAddress,@StationHeadPlace,@AntennaA,@AntennaB,@StationHeadTypeID
	end
	close cr
	deallocate cr
	select * from @tmpTab
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



CREATE proc PROC_GetRTStationHeadInfo_Zdc
(
  @addressList varchar(2000),
  @sumType int 			--0人员 1设备 2卡
)
as
begin 
--创建游标
	declare cr cursor for (
		select StationHeadState,aa.StationAddress,StationHeadAddress
			,StationHeadPlace,AntennaA,AntennaB
		from Station_Head_Info as aa
		right join Station_Info as si on si.StationAddress = aa.StationAddress
		and si.EditBaseInfo !=-1
		where aa.StationAddress in 
		(select * from Array_Split(@addressList,','))
		group by aa.StationAddress,StationHeadAddress
		,StationHeadPlace,AntennaA,AntennaB,StationHeadState
		)
	open cr

	declare @tmpTab table (StationHeadState int,StationAddress int,StationHeadAddress int,
          Antenna int,StationHeadPlace varchar(50),HeadAntennaName varchar(20)
	,SumCard int)
         

         
          

	declare @StationHeadState int
	declare @StationAddress int
	declare @StationHeadAddress int
	declare @StationHeadPlace varchar(50)
	declare @AntennaA varchar(20)
	declare @AntennaB varchar(20)	
	fetch next from cr into @StationHeadState,@StationAddress,@StationHeadAddress,@StationHeadPlace,@AntennaA,@AntennaB
	while @@fetch_status=0
	begin
		--@StationHeadPlace,@AntennaA,@AntennaB
		--判断显示类型
		if @sumType = 0
		begin
			insert @tmpTab
                        


			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,
                               count(rtcs.InStationHeadAntenna) 
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=1 and css.CsTypeID = 0
			
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,count(rtcs.InStationHeadAntenna) 
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=2 and css.CsTypeID = 0
		end
		else if @sumType = 1
		begin
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,count(rtcs.InStationHeadAntenna) 
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=1 and css.CsTypeID = 1
			
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,count(rtcs.InStationHeadAntenna) 
			from RealTimeCodeSender as rtcs
			left join CodeSender_Set as css on css.CsSetID = rtcs.CsSetID
			where rtcs.StationAddress = @StationAddress 
                        and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=2 and css.CsTypeID = 1
		end
		else if @sumType = 2
		begin
		        insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,1,@StationHeadPlace,@AntennaA,count(rtcs.InStationHeadAntenna)
			from RealTimeCodeSender as rtcs
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=1
	
			insert @tmpTab
			select @StationHeadState,@StationAddress,@StationHeadAddress,2,@StationHeadPlace,@AntennaB,count(rtcs.InStationHeadAntenna) 
			from RealTimeCodeSender as rtcs
			where rtcs.StationAddress = @StationAddress and rtcs.StationHeadAddress = @StationHeadAddress
			and rtcs.InStationHeadAntenna=2
		end	
		fetch next from cr into @StationHeadState,@StationAddress,@StationHeadAddress,@StationHeadPlace,@AntennaA,@AntennaB
	end
	close cr
	deallocate cr
	select * from @tmpTab
end







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
   修改记录
   11.11 增加LastInStationHeadAntenna的判断，去除异常只有出的记录，从来都没有进的记录的异常
   11.11 增加EnumTable表，14.0主界面不显示上井口基站
   08.3.24 把所有分站人数都显示出来,故障的 未初始化的	
*/

--exec PROC_GetRTStationInfo 0,10,2

--获取基站信息

CREATE        proc PROC_GetRTStationInfo
(
@pageIndex int,
@pageSize int,
@sumType int			--sumType 0人员 1设备 2卡 
)
as
begin
--分页
declare @temDate dateTime
declare @tmpString varchar(2000)
declare @intervalTime bigint
set @temDate=getdate()
Select @intervalTime=EnumValue from dbo.EnumTable 
where FunID=14 and EnumID=0 
--print @intervalTime
if @pageIndex = 0
begin
	set @tmpString = 'select TOP '+str(@pageSize)+ ' StationAddress,StationState
			 from Station_Info as si where EditBaseInfo !=-1 order by StationAddress'
end
else
begin
	set @tmpString = 'select TOP '+str(@pageSize)+' StationAddress,StationState from Station_Info
		where StationAddress > (select MAX(StationAddress) from 
		(select TOP '+str(@pageIndex*@pageSize)+' StationAddress 
		from Station_Info as allTab where EditBaseInfo !=-1 order by StationAddress) as maxTab)'
end
	--判断临时表是否存在
	if exists(select * from sysobjects where name='#tab')
	drop table #tab
	--创建临时表
	create table #tab (StationAddress int,StationState int)	
	--分页后存进临时表
	set @tmpString = 'insert into #tab(StationAddress,StationState) '+@tmpString
	EXECUTE (@tmpString)

	--创建游标
	declare cr cursor for (select StationState,StationAddress 
		from #tab)	
	open cr
	declare @tmpTab table (StationState int,StationAddress int,StationPlace varchar(30)
	,SumCard int)
	
	declare @State int
	declare @Address int
	fetch next from cr into @State,@Address
	while @@fetch_status=0
	begin
		insert @tmpTab
		select tab.StationState,tab.StationAddress,sInfo.StationPlace
			,dbo.StationSumCard(@sumType,@Address,@temDate)	
		from #tab as tab
		left join Station_Info as sInfo on sInfo.StationAddress = tab.StationAddress
		where sInfo.StationAddress = @Address
		
		fetch next from cr into @State,@Address
	end
	close cr
	deallocate cr
	select * from @tmpTab
	select count(StationAddress) from Station_Info

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE      proc PROC_GetStation_Info
@pageIndex int,
@pageSize int
as
begin
declare @str varchar(2000)
declare @strHead varchar(4000)
declare @where varchar(1000)
if @pageIndex = 0
	begin
	set @str = 'select Top '+str(@pageSize)+' StationAddress,StationPlace from Station_Info 
	where EditBaseInfo != -1
	order by StationAddress'
	set @strHead = 'select StationHeadID,StationAddress,StationHeadAddress,StationHeadPlace
	from Station_Head_Info where EditBaseInfo != -1 and StationAddress in (select Top '+str(@pageSize)+' StationAddress from Station_Info 
	where EditBaseInfo != -1
	order by StationAddress) order by StationHeadAddress'
	end
else
	begin
	set @str = 'select top '+str(@pageSize)+' StationAddress,StationPlace 
	from (select StationAddress,StationPlace from Station_Info
		 where EditBaseInfo != -1) as t2 
	where StationAddress > (select max(StationAddress) 
	from (select Top '+str(@pageIndex*@pageSize)+' StationAddress,StationPlace 
	from (select StationAddress,StationPlace from Station_Info
		 where EditBaseInfo != -1) as t1 order by StationAddress) as temp)'
	
	set @strHead = 'select StationHeadID,StationAddress,StationHeadAddress,StationHeadPlace
	from Station_Head_Info where StationAddress in (select top '+str(@pageSize)+' StationAddress
	from (select StationAddress from Station_Info
		 where EditBaseInfo != -1) as t2 
	where StationAddress > (select max(StationAddress) 
	from (select Top '+str(@pageIndex*@pageSize)+' StationAddress 
	from (select StationAddress from Station_Info
		 where EditBaseInfo != -1) as t1 order by StationAddress) as temp) order by StationHeadAddress)'
	end
	print @strHead
	exec(@str)
	exec(@strHead)
	exec('select count(StationAddress) from Station_Info where EditBaseInfo != -1')
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--css.CsTypeID=0时执行人员查询 否则设备
--hi.CodeSenderAddress，hi.UserName人员ei.DeptID ei.DutyID ew.EmpWorkTypeID
--hi.CodeSenderAddress，ei.EquName设备di.DeptID ei.EquType
CREATE  PROCEDURE PROC_HisInWellCount
    @PageSize     int,           -- 页尺寸
    @PageIndex    int,            -- 页码
    @strWhere     varchar(8000) = ''  -- 查询条件 (注意: 不要加 where)
AS
begin
declare @strSelect varchar(3000)
declare @str varchar(5000)
	--无条件时按开始时间和结束查询
	if @strWhere <> ''
	begin
		set @strWhere = ' where ' + @strWhere
		if PATINDEX('%CsTypeID%',@strWhere) > 0
		if PATINDEX('%css.CsTypeID = 0%',@strWhere) > 0
		begin
			set @strSelect = 'select hi.CodeSenderAddress,css.UserID,hi.UserName,count(hi.CodeSenderAddress) as InWellCount
			,di.DeptName,duty.DutyName,wti.WtName
			,dbo.FunConvertTime(sum(ContinueTime)) as sumTime
			from His_InOutMine as hi 
			left join CodeSender_Set as css on css.CsSetID=hi.CsSetID
			left join Emp_NowCompany as ei on ei.EmpID=css.UserID
			left join Dept_Info as di on di.DeptID = ei.DeptID
			left join Duty_Info as duty on duty.DutyID = ei.DutyID 
			left join Emp_WorkType as ew on ew.EmpID=css.UserID and ew.IsEnable = 1
			left join WorkType_Info as wti on wti.WorkTypeID=ew.WorkTypeID
			'+@strWhere+'
			 group by hi.CodeSenderAddress,css.UserID,hi.CsSetID,hi.UserName,DeptName,DutyName,WtName'
			if @pageIndex=0
			begin
				set @str='select top '+str(@pageSize)+' CodeSenderAddress,UserID,UserName,
				DeptName,DutyName,WtName,InWellCount,sumTime
				 from ('+@strSelect+') as H order by CodeSenderAddress asc'
			end
			else
			begin
				set @str = 'select Top '+str(@pageSize)+' CodeSenderAddress,UserID,UserName,
				DeptName,DutyName,WtName,InWellCount,sumTime
				 from ('+@strSelect+') as H where CodeSenderAddress > (select Max(CodeSenderAddress) from ('+@strSelect+') as H where  CodeSenderAddress
				 in ( select top '+str(@pageSize*@pageIndex)+' CodeSenderAddress from ('+@strSelect+') as H order by CodeSenderAddress asc)) order by CodeSenderAddress asc'
			end
		end 
		else
		begin
			set @strSelect='select css.CodeSenderAddress,css.UserID
			,ei.EquName,count(hi.CodeSenderAddress) as InWellCount
			,di.DeptName,dbo.FunConvertTime(sum(ContinueTime)) as sumTime
			from His_InOutMine as hi 
			left join CodeSender_Set as css on css.CsSetID=hi.CsSetID	
			left join Equ_BaseInfo as ei on ei.EquID=css.UserID
			left join Dept_Info as di on di.DeptID = ei.DeptID
			'+@strWhere+'
			 group by css.CodeSenderAddress,css.UserID,hi.CsSetID,ei.EquName,di.DeptName'
				if @pageIndex=0
				begin
					set @str='select top '+str(@pageSize)+' CodeSenderAddress,UserID,EquName,DeptName,InWellCount,sumTime
					 from ('+@strSelect+') as H order by CodeSenderAddress asc'
				end
				else
				begin
					set @str = 'select Top '+str(@pageSize)+' CodeSenderAddress,UserID,EquName,DeptName,InWellCount,sumTime
					 from ('+@strSelect+') as H where CodeSenderAddress > (select Max(CodeSenderAddress) from ('+@strSelect+') as H where  CodeSenderAddress
					 in ( select top '+str(@pageSize*@pageIndex)+' CodeSenderAddress from ('+@strSelect+') as H order by CodeSenderAddress asc)) order by CodeSenderAddress asc'
				end	
		end
			
	end
	
	print (@strSelect)
		print (@str)
		exec (@str)
		declare @temp varchar(3000) 
		set @temp = 'select count(*) from ('+@strSelect+') as X'
		exec (@temp)
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE proc PROC_RTAlarmInfo
(
	@type int
)
as
begin
	-- 基站
	if @type = 1
	select StationAddress as 基站地址,StationPlace as 基站位置
	,StationType as 基站类型,BreakTime as 故障开始时间
	,dbo.FunConvertTime((select DATEDIFF(ss, BreakTime, getdate()))) as 持续时间
	from Station_Info
	where StationState = -1000

	-- 超时
	if @type = 2
	select CodeSenderAddress as 发码器,ei.EmpName as 名称,di.DeptName as 部门
	,CsTypeID as 类型,StartOverTime 超时开始时间
	,dbo.FunConvertTime((select DATEDIFF(ss, StartOverTime, getdate()))) as 持续时间
	from dbo.RT_OverTimeInfo as ro
	left join Emp_Info as ei on ei.EmpID = ro.UserID
	left join Emp_NowCompany as en on en.EmpID = ei.EmpID
	left join Dept_Info as di on di.DeptID = en.DeptID
	where CsTypeID=0
	union all
	select CodeSenderAddress as 发码器,ei.EquName as 名称,di.DeptName as 部门
	,CsTypeID as 类型,StartOverTime 超时开始时间
	,dbo.FunConvertTime((select DATEDIFF(ss, StartOverTime, getdate()))) as 持续时间
	from dbo.RT_OverTimeInfo as ro
	left join Equ_BaseInfo as ei on ei.EquID = ro.UserID
	left join Dept_Info as di on di.DeptID = ei.DeptID
	where CsTypeID=1

	-- 区域报警
	if @type = 3
	select rt.CodeSenderAddress as 发码器,ei.EmpName as 名称,di.DeptName as 部门
	,rt.CsTypeID as 类型,rt.InTerritorialTime as 开始时间
	,dbo.FunConvertTime((select DATEDIFF(ss, rt.InTerritorialTime, getdate()))) as 持续时间
	from RT_TerritorialInfo as rt
	left join Territorial_Info as ti on ti.TerritorialID = rt.TerritorialID
	left join Territorial_Type as tt on tt.TerritorialTypeID=ti.TerritorialTypeID
	left join Emp_Info as ei on ei.EmpID = rt.UserID
	left join Emp_NowCompany as en on en.EmpID = ei.EmpID
	left join Dept_Info as di on di.DeptID = en.DeptID
	where rt.CsTypeID=0 and tt.IsAlarm = 1 and ti.IsEnable = 1
	union all
	select rt.CodeSenderAddress as 发码器,ei.EquName as 名称,di.DeptName as 部门
	,rt.CsTypeID as 类型,rt.InTerritorialTime as 开始时间
	,dbo.FunConvertTime((select DATEDIFF(ss, rt.InTerritorialTime, getdate()))) as 持续时间
	from RT_TerritorialInfo as rt
	left join Territorial_Info as ti on ti.TerritorialID = rt.TerritorialID
	left join Territorial_Type as tt on tt.TerritorialTypeID=ti.TerritorialTypeID
	left join Equ_BaseInfo as ei on ei.EquID = rt.UserID
	left join Dept_Info as di on di.DeptID = ei.DeptID
	where rt.CsTypeID=1 and tt.IsAlarm = 1 and ti.IsEnable = 1
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE procedure PROC_loginLogs
@p_AdminID int,			--用户ID
			--当前登入时间 得到当前系统时间
@p_LoginIP int, 		--当前登入IP
@p_LoginState int,  		--当前登入状态
@p_Remark nvarchar(200) = null	--默认为null 
as
begin
declare @LoginNO int			--最后登入编号
	-- 判断是不是用户名错误
	if not(@p_AdminID=0)
	begin
		-- 得到最近登陆日志的ID	
		select @LoginNO=LoginTotal from Admins where [ID] = @p_AdminID
		-- 插入log数据
		insert into LoginLogs(AdminID,LoginDate,LoginIP,LoginState,LoginNO,Remark)
		values(@p_AdminID,getDate(),@p_LoginIP,@p_LoginState,@LoginNO ,@p_Remark)	
	end
	else
		insert into LoginLogs(AdminID,LoginDate,LoginIP,LoginState,LoginNO,Remark)
		values(0,getDate(),@p_LoginIP,@p_LoginState,0,@p_Remark)		
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  procedure PROC_userLogin
@d_name varchar(20),
@d_pwd varchar(20),
@p_Remark nvarchar(200) = null		--默认为null 
as
begin
declare @d_AdminID int		--用户ID
declare @d_IsEnable bit
	-- 判断用户名密码与是否启用
	if exists(select * from Admins where Account = @d_name and [Password]=@d_pwd and IsEnable=1)
	begin
	select @d_AdminID=[ID],@d_IsEnable=IsEnable from Admins where Account=@d_name
	-- 登录成功
		begin
		update Admins set LoginTotal=LoginTotal+1 where Account=@d_name
		select ''
		return
		end
	end
	if exists(select * from Admins where Account=@d_name and [Password]=@d_pwd)
		begin	
		-- 判断用户是否启用
		select '用户未启用'
		return
		end
	-- 判断用户名和密码哪个不正确
	if exists(select * from Admins where Account=@d_name)
		begin
			select '用户密码错误'
			return
		end
	else
		begin	
		-- 用户名错误 ：AdminID为0 Remark为输入的用户名
		select '用户名错误'
		end
		
end









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE  procedure PROC_userLogin_ForWeb 
@d_name varchar(20),
@d_pwd varchar(20),
@p_TmpLoginIP int, 			--当前登入IP
@p_Remark nvarchar(200) = null		--默认为null 
as
begin
declare @d_AdminID int		--用户ID
declare @d_IsEnable bit
declare @d_IsUseEndDate bit
declare @d_UseEndDate smalldatetime
declare @d_Logintotal int
	-- 判断用户名密码与是否启用
	if exists(select * from Admins where Account = @d_name and [Password]=@d_pwd and IsEnable=1)
	begin
	select @d_AdminID=[ID],@d_IsEnable=IsEnable,@d_IsUseEndDate=IsUseEndDate,@d_UseEndDate=UseEndDate from Admins where Account=@d_name
		-- 判断是否启用截止日期
		if(@d_IsUseEndDate=1)
		begin
			-- 验证用户是否过期
			if (DATEDIFF(day,@d_UseEndDate,getdate()) > 0)
			begin	
				exec PROC_loginLogs @d_AdminID,@p_TmpLoginIP,4,@p_Remark
				raiserror('帐户过期',16,4)
				return
			end
			else
				-- 登录成功
				begin
				update Admins set LoginTotal=LoginTotal+1 where Account=@d_name
				exec PROC_loginLogs @d_AdminID,@p_TmpLoginIP,0,@p_Remark
				return
				end
		end
		else
			-- 登录成功
			begin
			--修改登陆次数
			update Admins set LoginTotal=LoginTotal+1 where Account=@d_name
			exec PROC_loginLogs @d_AdminID,@p_TmpLoginIP,0,@p_Remark
			return
			end
	end
	if exists(select * from Admins where Account=@d_name and [Password]=@d_pwd)
		begin	
		-- 判断用户是否启用
		exec PROC_loginLogs @d_AdminID,@p_TmpLoginIP,3,@p_Remark
		raiserror('帐户未启用',16,1)
		return
		end
	-- 判断用户名和密码哪个不正确
	if exists(select * from Admins where Account=@d_name)
		begin
			exec PROC_loginLogs @d_AdminID,@p_TmpLoginIP,2,@p_Remark
			raiserror('帐户密码错误',16,1)
			return
		end
	else
		begin	
		-- 用户名错误 ：AdminID为0 Remark为输入的用户名
		exec PROC_loginLogs 0,@p_TmpLoginIP,1,@d_name
		raiserror('帐户名错误',16,1)
		end
		
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO







CREATE proc Proc_DbackPic_AddFile
@filename varchar(50),
@fileimg  image,
@success int output,
@ID int
as
  begin
    declare @num int
    select @num=count(*) from G_DpicFile where [Filename]=@filename
    if(@num>0)
      begin
        set @success=-1
      end
    else
      begin
        insert into G_DpicFile values(@ID,@filename,@fileimg)
        set @success=1
      end
  end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--exec Proc_His_Area 40,0,''

CREATE procedure Proc_His_Area
@PageSize int,			--页大小
@PageIndex int,			--页索引
@strWhere varchar(1000)		--条件
as 
declare @strsql1  varchar(1000)
declare @strsql2  varchar(4000)
declare @strsql3  varchar(3000)
begin
	if len(@strWhere)>0
		set @strWhere = ' and '+@strWhere
	--得到符合条件的数据集
	set @strsql1='select AreaName,AreaTypeName,CodeSenderAddress,EmpName,InTime,InDirection,OutDirection
	,OutTime,dbo.FunConvertTime(AreaWorkTime) as AreaWorkTime,(id+InTime) as id from dbo.His_AreaDirection where EmpName is not null'+@strWhere
	set @strsql3 = 'select Count(1) from ('+@strsql1+') AS X'
	if @PageIndex = 0
    		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' AreaName,AreaTypeName,CodeSenderAddress,EmpName,InTime,InDirection,OutDirection
					,OutTime,AreaWorkTime from ('+@strsql1+') 
					as X order by CodeSenderAddress asc'
		end
	else
		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' AreaName,AreaTypeName,CodeSenderAddress,EmpName,InTime,InDirection,OutDirection
						,OutTime,AreaWorkTime
					from ('+@strsql1+') as C 
					where id>(select Max(id) from ('+@strsql1+') as B where 
					id in (select top  '+str(@PageSize*@PageIndex)+' id 
					from  ('+@strsql1+') as A order by CodeSenderAddress asc)) order by CodeSenderAddress,
					InTime'
		end
		print (@strsql2)
		EXEC(@strsql2)
		EXEC(@strsql3)
		declare @tmp varchar(2000)
		set @tmp='select Count(DISTINCT CodeSenderAddress) from dbo.His_AreaDirection where EmpName is not null'+@strWhere
		set @strsql3 = 'select Count(1) from ('+@strsql1+') AS X'
		exec(@tmp)
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询历史活动轨迹
CREATE procedure Proc_His_DirectionalAntenna
@PageSize int,			--页大小
@PageIndex int,			--页索引
@strWhere varchar(1000)		--条件
as 
declare @strsql1  varchar(1000)
declare @strsql2  varchar(4000)
declare @strsql3  varchar(3000)
begin
	if len(@strWhere)>0
		set @strWhere = ' where '+@strWhere
	--得到符合条件的数据集
	set @strsql1='select 
rd.CodeSenderAddress as CodeSenderAddress,ei.EmpName as EmpName,di.DeptName as DeptName
,rd.DirectionalTitle as DirectionalTitle,dbo.FunDisplayAntennaInfo(rd.DirectionalInfo) as DirectionalInfo
,rd.NowTime as NowTime
from His_Directional as rd
left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress = rd.CodeSenderAddress and cs.CsTypeID=0
left join Emp_Info as ei on ei.EmpID = cs.UserID
left join dbo.Emp_WorkType as ew on ew.EmpID=ei.EmpID and IsEnable=1
left join dbo.Emp_NowCompany as enc on enc.EmpID = ei.EmpID 
left join dbo.Dept_Info as di on di.DeptID = enc.DeptID'+@strWhere
	set @strsql3 = 'select Count(*) from ('+@strsql1+') AS X'
	if @PageIndex = 0
    		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,EmpName,DeptName,DirectionalTitle
					,DirectionalInfo,NowTime from ('+@strsql1+') 
					as X order by CodeSenderAddress,NowTime asc'
		end
	else
		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,EmpName,DeptName,DirectionalTitle
					,DirectionalInfo,NowTime   
					from ('+@strsql1+') as C 
					where CodeSenderAddress>(select Max(CodeSenderAddress) from ('+@strsql1+') as B where 
					CodeSenderAddress in (select top  '+str(@PageSize*@PageIndex)+' CodeSenderAddress 
					from  ('+@strsql1+') as A order by CodeSenderAddress asc)) order by CodeSenderAddress,
					NowTime'
		end
		EXEC(@strsql2)
		EXEC(@strsql3)
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create  procedure Proc_His_InOutReceiver
@PageSize int,			--页大小
@PageIndex int,			--页索引
@strWhere varchar(1000)		--条件
as 
declare @strsql1  varchar(1000)
declare @strsql2  varchar(4000)
declare @strsql3  varchar(3000)
begin
	if len(@strWhere)>0
		set @strWhere = ' where '+@strWhere
	--得到符合条件的数据集
	set @strsql1='select hi.CodeSenderAddress,Name,Station,StationHead,StationHeadPlace,InTime,OutTime,dbo.FunConvertTime(datediff(second,InTime,OutTime)) as tmptime
	,InDirection,OutDirection,id+InTime as [TmpID] from His_InOutReceiver as hi
	left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress = hi.CodeSenderAddress and cs.CsTypeID=0
	left join Emp_Info as ei on ei.EmpID = cs.UserID
	left join dbo.Emp_WorkType as ew on ew.EmpID=ei.EmpID and IsEnable=1
	left join dbo.Emp_NowCompany as enc on enc.EmpID = ei.EmpID
	left join dbo.Dept_Info as di on di.DeptID = enc.DeptID
'+@strWhere
	set @strsql3 = 'select Count(1) from ('+@strsql1+') AS X'
	if @PageIndex = 0
    		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,Name,Station
					,StationHead,StationHeadPlace,InTime,OutTime,tmptime,InDirection,OutDirection from ('+@strsql1+') 
					as X order by CodeSenderAddress,InTime asc'
		end
	else
		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,Name,Station
					,StationHead,StationHeadPlace,InTime,OutTime,tmptime,InDirection,OutDirection
					from ('+@strsql1+') as C 
					where TmpID>(select Max(TmpID) from ('+@strsql1+') as B where 
					TmpID in (select top  '+str(@PageSize*@PageIndex)+' TmpID 
					from  ('+@strsql1+') as A order by CodeSenderAddress asc)) order by CodeSenderAddress,
					InTime'
		end
		EXEC(@strsql2)
		EXEC(@strsql3)
		declare @tmp varchar(2000)
		set @tmp='select Count(1) from (select DISTINCT hi.CodeSenderAddress from His_InOutReceiver as hi
	left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress = hi.CodeSenderAddress and cs.CsTypeID=0
	left join Emp_Info as ei on ei.EmpID = cs.UserID
	left join dbo.Emp_WorkType as ew on ew.EmpID=ei.EmpID and IsEnable=1
	left join dbo.Emp_NowCompany as enc on enc.EmpID = ei.EmpID
	left join dbo.Dept_Info as di on di.DeptID = enc.DeptID'+@strWhere+') as a' 
		exec(@tmp)
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE procedure Proc_RT_DirectionalAntenna
@PageSize int,			--页大小
@PageIndex int,			--页索引
@strWhere varchar(1000)		--条件
as 
declare @strsql1  varchar(1000)
declare @strsql2  varchar(4000)
declare @strsql3  varchar(3000)
begin
	if len(@strWhere)>0
		set @strWhere = ' where '+@strWhere
	--得到符合条件的数据集
	set @strsql1='select 
	rd.CodeSenderAddress as CodeSenderAddress,ei.EmpName as EmpName,di.DeptName as DeptName
	,cd.Directional as Directional,dbo.FunDisplayAntennaInfo(cd.DetectionInfo) as DetectionInfo
	,rd.Station as Station,rd.Antenna as Antenna,rd.NowTime as NowTime
	from dbo.RT_DirectionalAntenna as rd
	left join dbo.CodeSender_Set as cs on cs.CodeSenderAddress = rd.CodeSenderAddress and cs.CsTypeID=0
	left join Emp_Info as ei on ei.EmpID = cs.UserID 
	left join dbo.Emp_WorkType as ew on ew.EmpID=ei.EmpID and IsEnable=1
	left join dbo.CodeSender_DirectionalAntenna as cd on cd.CodeSenderDirlID = rd.CodeSenderDirlID
	left join dbo.Emp_NowCompany as enc on enc.EmpID = ei.EmpID
	left join dbo.Dept_Info as di on di.DeptID = enc.DeptID'+@strWhere
	set @strsql3 = 'select Count(*) from ('+@strsql1+') AS X'
	if @PageIndex = 0
    		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,EmpName,DeptName,Directional
					,DetectionInfo
					,Station,Antenna,NowTime from ('+@strsql1+') 
					as X order by CodeSenderAddress,NowTime asc'
		end
	else
		begin
			set @strsql2 = 'select Top '+str(@PageSize)+' CodeSenderAddress,EmpName,DeptName,Directional
					,DetectionInfo
					,Station,Antenna,NowTime   
					from ('+@strsql1+') as C 
					where CodeSenderAddress>(select Max(CodeSenderAddress) from ('+@strsql1+') as B where 
					CodeSenderAddress in (select top  '+str(@PageSize*@PageIndex)+' CodeSenderAddress 
					from  ('+@strsql1+') as A order by CodeSenderAddress asc)) order by CodeSenderAddress,
					NowTime'
		end
		EXEC(@strsql2)
		EXEC(@strsql3)
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

CREATE proc SSZY_QueryByTime_DJC
@strWhere varchar(200)
as 
declare @tmp1 varchar(8000)
set @tmp1='select hi.CodeSenderAddress,ei.EmpName
-- 下井时间
,case (select count(1) from RT_InOutMine where CodeSenderAddress = hi.CodeSenderAddress)
when 1 then ri.InTime 
else 
	(select top 1 InTime from His_InOutMine where OutTime >=hi.InStationHeadTime 
	and CodeSenderAddress = hi.CodeSenderAddress order by InTime DESC) 
end as InMineTime
-- 上井时间
,case (select count(1) from RT_InOutMine where CodeSenderAddress = hi.CodeSenderAddress)
when 1 then null 
else 
	(select OutTime from (select top 1 OutTime as OutTime,InTime from His_InOutMine where OutTime >=hi.InStationHeadTime 
	and CodeSenderAddress = hi.CodeSenderAddress order by InTime DESC) as a)
end as OutMineTime
--井下工作时间
,case (select count(1) from RT_InOutMine where CodeSenderAddress = hi.CodeSenderAddress)
when 1 then dbo.FunConvertTime(datediff(second,ri.InTime ,getdate())) 
else (select d from (select top 1 dbo.FunConvertTime(datediff(second,InTime,OutTime)) as d,InTime from His_InOutMine where OutTime >=hi.InStationHeadTime 
	and CodeSenderAddress = hi.CodeSenderAddress order by InTime DESC) as b)
end as dtime
,hi.StationHeadPlace 
,hi.InStationHeadTime,hr.InDirection,hr.OutTime as OutTime,hr.OutDirection,dbo.FunConvertTime(datediff(second,hr.InTime,hr.OutTime)) as tmptime
from His_InOutStationHead as hi
left join His_InOutReceiver as hr on hr.InTime = hi.InStationHeadTime and hr.CodeSenderAddress=hi.CodeSenderAddress
left join CodeSender_Set as cs on cs.CodeSenderAddress = hi.CodeSenderAddress and cs.CsTypeID= 0
left join Emp_Info as ei on ei.EmpID = cs.UserID 
left join RT_InOutMine as ri on ri.CodeSenderAddress = hi.CodeSenderAddress
-- 插入当前所在读卡分站
UNION all
select ri.CodeSenderAddress,ei.EmpName,rim.InTime as InMineTime,null  as OutMineTime
,dbo.FunConvertTime(datediff(second,rim.InTime ,getdate())) as dtime,shi.StationHeadPlace,ri.InStationHeadTime
,(select Directional from dbo.CodeSender_DirectionalAntenna where CodeSenderDirlID=rd.CodeSenderDirlID) as InDirection
,null  as OutTime,null  as OutDirection
,dbo.FunConvertTime(datediff(second,ri.InStationHeadTime,getdate())) as tmptime
from dbo.RT_InStationHeadInfo as ri
left join dbo.Station_Head_Info as shi on shi.StationHeadID = ri.StationHeadID
left join RT_InOutMine as rim on rim.CodeSenderAddress = ri.CodeSenderAddress
left join CodeSender_Set as cs on cs.CodeSenderAddress = ri.CodeSenderAddress and cs.CsTypeID=0
left join Emp_Info as ei on ei.EmpID = cs.UserID 
left join dbo.RT_DirectionalAntenna as rd on rd.CodeSenderAddress=ri.CodeSenderAddress 
and rd.Station=shi.StationAddress and rd.Antenna = shi.StationHeadAddress
where rim.CodeSenderAddress >0'
print @tmp1
if len(@strWhere)>0
	set @strWhere = ' where '+@strWhere
declare @tmp2 varchar(8000),@tmp3 varchar(8000),@tmp4 varchar(8000)
set @tmp2='select CodeSenderAddress,EmpName,InMineTime
,OutMineTime,dtime,StationHeadPlace,InStationHeadTime,InDirection,OutTime,OutDirection,tmptime
from ('+@tmp1+') as t1'+@strWhere+' order by CodeSenderAddress,InStationHeadTime'
--记录数
set @tmp3='select count(1) from ('+@tmp1+') as t3 '+@strWhere
--总人数
set @tmp4='select count(DISTINCT CodeSenderAddress) from ('+@tmp1+') as t4 '+@strWhere
exec (@tmp2)
exec(@tmp3)
exec(@tmp4)
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询历史岗位信息存储过程
create procedure SelectHistoryPostInfo
--查询条件
@condition varchar(1000)
as 

declare @sqlStr varchar(2000)

set @sqlStr = 'select * from View_SelectHistoryPostInfo'

if ((@condition is null) or (@condition=''))
begin 
	exec(@sqlStr)
end
else
begin
	set @sqlStr = @sqlStr + ' where ' + @condition
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查询历史行走异常措施
CREATE procedure [dbo].[SelectHistoryWalkInfo]

@condition varchar(1000)

as

if ((@condition='') or (@condition is null))
begin
	select * from View_HistoryWalkInfo
end
else
begin
    
	declare @sqlStr varchar(1200) 
	set @sqlStr = 'select * from View_HistoryWalkInfo where '+@condition

	exec(@sqlStr)
  
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查询出入限制区域时刻(存储过程)
CREATE procedure SelectInOutConfineAreaTimeInfo
@condition varchar(1000)
as 
declare @strSQL varchar(5000)

if ((@condition is null) or (@condition=''))
begin
 	Set @strSQL=' select * from RT_TerritorialInfo '
end

else
begin
	Set @strSQL='Select CodeSenderAddress as 标识卡编号 ,EmpName as 姓名 ,DeptName as 部门 ,TerritorialName as 区域名称 , 
			InTerritorialTime as 进入限制域时刻 ,dbo.FunConvertTime(DATEDIFF (ss,InTerritorialTime,Getdate())) as 滞留时间  
		     From RT_TerritorialInfo as Rti left join Emp_Info as Ei on Rti.UserID=Ei.EmpID and Rti.CsTypeID=0 
			left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
			left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
		     Where TerritorialTypeName = ''限制区域'' and CsTypeID is not null and '+@condition
end

exec (@strSQL)

 

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查询出入重点区域时刻(存储过程)
CREATE  procedure SelectInOutKeyAreaTimeInfo
@condition varchar(1000)
as 

declare @strSQL varchar(5000)

if ((@condition is null) or (@condition=''))
begin
 	Set @strSQL=' select * from RT_TerritorialInfo '
end

else
begin
	Set @strSQL='Select CodeSenderAddress as 标识卡编号 ,EmpName as 姓名 ,DeptName as 部门 ,TerritorialName as 区域名称 , 
			InTerritorialTime as 进入重点区域时刻 ,dbo.FunConvertTime(DATEDIFF (ss,InTerritorialTime,Getdate())) as 工作时间  
		     From RT_TerritorialInfo as Rti left join Emp_Info as Ei on Rti.UserID=Ei.EmpID and Rti.CsTypeID=0 
			left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
			left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
		     Where TerritorialTypeName = ''重点区域'' and CsTypeID is not null and '+@condition
end

exec (@strSQL)




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--查询实时岗位报警信息存储过程（执行过）
CREATE procedure SelectRealTimeAlarmPostInfo
@condition varchar(1000)
as
declare @sqlstr varchar(2000)

set @sqlstr = 'select * from View_SelectRealTimePostInfo where IsArrive = 0'

if((@condition is null) or (@condition=''))
begin
	exec(@sqlstr)
end
else
begin
	set @sqlstr = @sqlstr + ' and ' + @condition
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--查询实时地域信息
CREATE procedure SelectRealTimeClimeInfo
@condition varchar(1000)
as
declare @strSQL varchar(5000)

if ((@condition is null) or (@condition=''))
begin
 	Set @strSQL=' select * from RT_TerritorialInfo '
end

else
begin
	Set @strSQL='Select CodeSenderAddress as 标识卡 ,EmpName as 姓名 ,DeptName as 部门 ,TerritorialName as 区域名称 , 
			InTerritorialTime as 进入地域时刻 ,dbo.FunConvertTime(DATEDIFF (ss,InTerritorialTime,Getdate())) as 工作时间  
		     From RT_TerritorialInfo as Rti left join Emp_Info as Ei on Rti.UserID=Ei.EmpID and Rti.CsTypeID=0 
			left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID 
			left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID 
		     Where TerritorialTypeName = ''地域'' and CsTypeID is not null and '+@condition
end

exec (@strSQL)




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查询实时行走异常报警
CREATE procedure [dbo].[SelectRealTimeWalkAlarmInfo]
@condition varchar(1000)
as

declare @selectstr varchar(2000)

set @selectstr = 'select * from View_RealTimeWalkAlarmInfo '

if ((@condition is null) or (@condition=''))
begin
	exec(@selectstr)
end

else
begin
	set @selectstr = @selectstr + ' where ' + @condition
	exec(@selectstr)
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询实时行走异常报警
create procedure SelectRealTimeWalkInfo
as
select * from RealTimeWalkInfo


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE procedure [dbo].[SelectWalkConfigInfo]
@condition varchar(1000)
as

declare @sqlstr varchar(2000)

set @sqlstr = ' select * from View_WalkConfigInfo ' 

if (@condition is null) or (@condition='')
begin
	exec (@sqlstr)
end

else
begin
	set @sqlstr = @sqlstr + ' where '+ @condition
	exec(@sqlstr)
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create proc Shine_AddGraphicsBackGroudFile
@filename varchar(50),
@fileimage image
as
begin
  insert into A_GraphicsMapFile ([FileName],FileImg) values (@filename,@fileimage)
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create    PROCEDURE Shine_Admin_GetUGPLevelID
	@Account varchar(20),
	@id int

AS
declare @level1 int
declare @level2 int
set @level1=1000000
set @level2 = 100000
declare @result nvarchar (20)

 select @level2= UGPLevelID  From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID
where a.id = @id
  select @level1 = UGPLevelID  From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID
where a.Account = @Account

if @level1<@level2
 
select 1
else
select 2


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



CREATE  PROCEDURE Shine_Admin_GetUGPLevelID_ByAccount
(
	@Account varchar(20)
)
AS

Select * From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID

where

a.Account = @Account




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO




CREATE   proc Shine_Admin_lastLoard 
(
 @ID INT
)
as

select top 2 L.*,A.Account ,a.CreateDate from dbo.LoginLogs  L left join admins A on L.adminID = A.ID   where L.AdminID = @ID order by   loginNo DESC





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE PROCEDURE Shine_Admins_Add
(
@ID int,
@Account varchar (20),
@Password varchar (16),
@IsEnable bit,
@IsUseEndDate bit,
@UseEndDate smalldatetime,
@UserGroupID int,
@LoginTotal int,
@CreateID int,
@CreateDate smalldatetime,
@CreateIP bigint,
@FlagTag bit,
@Style varchar (20),
@Remark varchar (200)
)
AS
INSERT INTO Admins(
[Account], [Password], [IsEnable], [IsUseEndDate], [UseEndDate], [UserGroupID], [LoginTotal], [CreateID], [CreateDate], [CreateIP], [FlagTag], [Style], [Remark]
)VALUES(
@Account, @Password, @IsEnable, @IsUseEndDate, @UseEndDate, @UserGroupID, @LoginTotal, @CreateID, @CreateDate, @CreateIP, @FlagTag, @Style, @Remark 	
)










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE PROCEDURE Shine_Admins_DeleteByPrimaryKey
(
@ID int

)
AS
	DELETE Admins 
	WHERE [ID] = @ID









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



CREATE Proc Shine_Admins_GetID_ByAccount
(
	@Account varchar(20)
)
As
	Select [ID] From Admins Where Account = @Account



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_Admins_GetModelByPrimaryKey
(
@ID int
)
As
Select [ID], [Account], [Password], [IsEnable], [IsUseEndDate], [UseEndDate], [UserGroupID], [LoginTotal], [CreateID], [CreateDate], [CreateIP], [FlagTag], [Style], [Remark]
	From Admins
	Where [ID] = @ID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/****** Object:  Stored Procedure dbo.Shine_Admins_Update    Script Date: 2007-6-13 15:33:20 ******/








CREATE PROCEDURE Shine_Admins_Update
(
@ID int,
@Account varchar (20),
@Password varchar (16),
@IsEnable bit,
@IsUseEndDate bit,
@UseEndDate smalldatetime,
@UserGroupID int,
@LoginTotal int,
@CreateID int,
@CreateDate smalldatetime,
@CreateIP bigint,
@FlagTag bit,
@Style varchar (20),
@Remark varchar (200)
)
AS
	UPDATE Admins Set 
	[Account] = @Account, [Password] = @Password, [IsEnable] = @IsEnable, [IsUseEndDate] = @IsUseEndDate, [UseEndDate] = @UseEndDate, [UserGroupID] = @UserGroupID, [LoginTotal] = @LoginTotal, [CreateID] = @CreateID, [CreateDate] = @CreateDate, [CreateIP] = @CreateIP, [FlagTag] = @FlagTag, [Style] = @Style, [Remark] = @Remark
	Where [ID] = @ID












GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








CREATE PROCEDURE Shine_AlarmSetting_Add
(
@id int,
@AdminID int,
@AlarmName varchar (20),
@Condition int,
@isMusic bit,
@isAlarm bit,
@SetDate datetime,
@Remark varchar (200)
)
AS
INSERT INTO AlarmSetting(
[AdminID], [AlarmName], [Condition], [isMusic], [isAlarm], [SetDate], [Remark]
)VALUES(
@AdminID, @AlarmName, @Condition, @isMusic, @isAlarm, @SetDate, @Remark 	
)









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE PROCEDURE Shine_AlarmSetting_DeleteByPrimaryKey
(
@id int

)
AS
	DELETE AlarmSetting 
	WHERE [id] = @id










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE  PROCEDURE Shine_AlarmSetting_UpdateA
(
@id int,
@AdminID int,
@AlarmName varchar (20),
@Condition int,
@isMusic bit,
@isAlarm bit,
@SetDate datetime ,
@Remark varchar (200)
)
AS
	
if(exists (select * from AlarmSetting where [id] = @id ))
begin 
UPDATE AlarmSetting Set 
	[AdminID] = @AdminID, [AlarmName] = @AlarmName, [Condition] = @Condition, [isMusic] = @isMusic, [isAlarm] = @isAlarm, [SetDate] = @SetDate, [Remark] = @Remark
	Where [id] = @id
end 
else
begin 
	
INSERT INTO AlarmSetting(
[AdminID], [AlarmName], [Condition], [isMusic], [isAlarm], [SetDate], [Remark]
)VALUES(
@AdminID, @AlarmName, @Condition, @isMusic, @isAlarm, @SetDate, @Remark 	
)

end 












GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_Customer_GetList
AS
	SELECT 
ID,CustomerNO,CustomerName,CityCode,CustomerTel,CustomerFax,CustomerAddress,IsUseEndDate,UseEndDate,StartTime,	Remark
	 FROM Customer




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE PROCEDURE Shine_Customer_ID_Delete

@ID int
 AS 
	DELETE Customer
	 WHERE [ID] = @ID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_Customer_ID_GetEntity

@ID int
 AS 
	Select
[ID],[CustomerNO],[CustomerName],[CityCode],[CustomerTel],[CustomerFax],[CustomerAddress],[IsUseEndDate],[UseEndDate],[StartTime],	[Remark]

	From Customer
	WHERE [ID] = @ID



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_Customer_Update
(
@ID int ,@CustomerNO varchar (20),@CustomerName varchar (50),@CityCode int ,@CustomerTel varchar (50),@CustomerFax varchar (16),@CustomerAddress varchar (255),@IsUseEndDate bit ,@UseEndDate smalldatetime ,@StartTime smalldatetime ,@Remark varchar (200)
)
AS 
	UPDATE Customer SET
[CustomerNO] = @CustomerNO,[CustomerName] = @CustomerName,[CityCode] = @CityCode,[CustomerTel] = @CustomerTel,[CustomerFax] = @CustomerFax,[CustomerAddress] = @CustomerAddress,[IsUseEndDate] = @IsUseEndDate,[UseEndDate] = @UseEndDate,[StartTime] = @StartTime,	[Remark] = @Remark
	WHERE 
		[ID] = @ID



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE PROCEDURE Shine_Departments_GetClassInfoByDeptID
(
	@intDept int
)
AS

select ti.id, ti.IntervalName, ti.StartWorkTime, ti.EndWorkTime from dbo.Dept_Info as dt
inner join InfoClass as ic on ic.id = dt.ClassID
inner join TimerInterval as ti on ti.ClassID = ic.id
where dt.Deptid = @intDept



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE   PROCEDURE Shine_GetDropDownListData
(
	@valueField varchar(50),
	@textField varchar(50),
	@strWhere varchar(1000) = ''  -- 查询条件 (注意: 不要加 where) 
)
As
	Declare @StrSql varchar(1000)
	If @strWhere!=''
		Set @StrSql = 'Select EN.' + @valueField + ', EI.' + @textField + ' From dbo.Emp_NowCompany EN left join dbo.Emp_Info EI on EN.EmpID = EI.EmpID Where ' + @strWhere
	Else
		Set @StrSql = 'Select EN.' + @valueField + ', Ei.' + @textField + ' From dbo.Emp_NowCompany EN left join dbo.Emp_Info EI on EN.EmpID = EI.EmpID '
	Exec (@StrSql)










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE   PROCEDURE Shine_GetList_StationsInfoAndEnumInfo
AS

select 
StationHeadID id,
stationAddress,
stationHeadAddress,
StationHeadID stationNo,
StationHeadPlace Place,
StationHeadType Type,
(select title from EnumTable where EnumID = StationHeadState AND  funID = 7) as state,
StationHeadX StationX,
StationHeadY StationY from 

station_Head_Info

SET QUOTED_IDENTIFIER OFF



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE        PROCEDURE Shine_GetRecordByPage
    @tblName      varchar(255),       -- 表名
    @fldName      varchar(255),       -- 主键字段名
    @PageSize     int = 10,           -- 页尺寸
    @PageIndex    int = 1,            -- 页码
    @IsReCount    bit = 0,            -- 返回记录总数, 非 0 值则返回
    @OrderType    bit = 0,            -- 设置排序类型, 非 0 值则降序
    @strWhere     varchar(1000) = ''  -- 查询条件 (注意: 不要加 where)
AS

declare @strSQL   varchar(6000)       -- 主语句
declare @strTmp   varchar(1000)        -- 临时变量
declare @strOrder varchar(400)        -- 排序类型

if @OrderType != 0
begin
    set @strTmp = '<(select min'
    set @strOrder = ' order by ' + @fldName +' desc'
end
else
begin
    set @strTmp = '>(select max'
    set @strOrder = ' order by ' + @fldName +' asc'
end

set @strSQL = 'select top ' + str(@PageSize) + ' * from ['
    + @tblName + '] where ' + @fldName + '' + @strTmp + '('
    + @fldName + ') from (select top ' + str((@PageIndex-1)*@PageSize) + ' '
    + @fldName + ' from [' + @tblName + ']' + @strOrder + ') as tblTmp)'
    + @strOrder

if @strWhere != ''
    set @strSQL = 'select top ' + str(@PageSize) + ' * from ['
        + @tblName + '] where ' + @fldName + '' + @strTmp + '('
        + @fldName + ') from (select top ' + str((@PageIndex-1)*@PageSize) + ' '
        + @fldName + ' from [' + @tblName + '] where ' + @strWhere + ' '
        + @strOrder + ') as tblTmp) and ' + @strWhere + ' ' + @strOrder

if @PageIndex = 1
begin
    set @strTmp =''
    if @strWhere != ''
        set @strTmp = ' where ' + @strWhere

    set @strSQL = 'select top ' + str(@PageSize) + ' * from ['
        + @tblName + ']' + @strTmp + ' ' + @strOrder
end
print(@strSql)
	exec (@strSql)


if @IsReCount != 0
begin
    if (@strWhere = '')
	set @strSQL = 'select count(*) as Total from [' + @tblName + ']'
    else
	set @strSQL = 'select count(*) as Total from [' + @tblName + ']'+' where ' + @strWhere    
    exec (@strSQL)

print @strSQL
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE PROCEDURE Shine_HistoryAttendance_GetEmpInfoByTimerIntervalID
(
	@dtBeginWorkTimest datetime,
	@dtBeginWorkTimeed datetime,
	@intDeptId int,
	@intTimerIntervalID int
)
AS

select EmployeeId, EmployeeName, DeptId, TimerIntervalID from HistoryAttendance
where
BeginWorkTime >= @dtBeginWorkTimest and
BeginWorkTime <= @dtBeginWorkTimeed and
DeptId = @intDeptId and
TimerIntervalID = @intTimerIntervalID

select StartWorkTime, EndWorkTime from TimerInterval where id = @intTimerIntervalID

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加请假信息
CREATE  procedure [dbo].[Shine_HistoryHolidays_Add] 
(@BlockID int,
@EmployeeName varchar(20),
@DeptID int,
@BeginWorkDate varchar(20),
@HolidayName varchar(20),
@OperatorID int
)
as 
declare @temDate dateTime
	set @temDate=getdate()
declare @EmployeeID int 
declare @strsql varchar(500)

select @EmployeeID = EmpID from dbo.Emp_InCompany left join dbo.CodeSender_Set on UserID = EmpID where CodeSenderAddress = @BlockID and csTypeID=0
if not exists(select * from HistoryAttendance where employeeid=@EmployeeID and DataAttendance=@BeginWorkDate and IsHoliday=1)
begin
insert HistoryAttendance (ID,BlockID,EmployeeID,EmployeeName,DeptID,DataAttendance,ClassShortName,OperatorID,OperatorTime,IsHoliday)
values(dbo.FunDateBigIntID(@temDate,@BlockID),@BlockID,@EmployeeID,@EmployeeName,@DeptID,@BeginWorkDate,@HolidayName,@OperatorID,substring(convert(char,getdate(),120),1,10),1)
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_HistoryHolidays_Delete    Script Date: 2007-6-13 15:33:27 ******/



CREATE  procedure [dbo].[Shine_HistoryHolidays_Delete]
(@ID bigint
)

as 

Delete HistoryAttendance 


where [ID] = @ID 









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO







/****** Object:  Stored Procedure dbo.Shine_HistoryHolidays_Query    Script Date: 2007-6-13 15:33:27 ******/








CREATE         procedure Shine_HistoryHolidays_Query

(@PageIndex int,@PageSize int,@strWhere varchar(300))

as 

declare @strsql varchar(2000)
declare @strsql1 varchar(5000)
declare @strsql2 varchar(3000)


set @strsql = 'select h.ID,h.BlockID 发码器,h.EmployeeName 员工姓名,h.deptID,h.ClassShortName 
		假别名称,di.DeptName 部门名称,h.DataAttendance 请假日期 from HistoryAttendance h 
		left join CodeSender_Set c on h.BlockID = c.CodeSenderAddress 
		left join dbo.Dept_Info di on h.DeptID = di.DeptID where h.IsHoliday = 1 '+@strWhere
set @strsql2 = 'select Count(ID) from ('+@strsql+') as A'

if(@PageIndex =1)
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' ID,发码器,员工姓名,deptID,假别名称,
				部门名称,请假日期 from ('+@strsql+') as A'
	end
else
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' ID,发码器,员工姓名,deptID,假别名称,
				部门名称,请假日期 from ('+@strsql+') as A where ID > 
				(select max(ID) from (select top '+str((@PageIndex-1)*@PageSize)+' ID from 
				('+@strsql+') as B order by ID) as D) order by ID'
	end


exec(@strsql1)
exec(@strsql2)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_HistoryHolidays_Update    Script Date: 2007-6-13 15:33:27 ******/





create procedure [dbo].[Shine_HistoryHolidays_Update] 
(@ID bigint,
@BlockID int,
@EmployeeName varchar(20),
@DeptID int,
@BeginWorkDate varchar(20),
@HolidayName varchar(20),
@OperatorID int
)

as 

Update HistoryAttendance
set BlockID = @BlockID,
EmployeeName=@EmployeeName,
DeptID=@DeptID,
DataAttendance=@BeginWorkDate,
ClassShortName=@HolidayName,
OperatorID = @OperatorID
where [ID] = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








--创建历史进行基站表查询
CREATE      PROCEDURE Shine_HistoryInOutStation_QueryView
(
	@strTableName	varchar(50),
	@intBlock int,
	@strName varchar(20),
	@intUserType int,
	@strStartDateTime varchar(50),
	@strEndDateTime varchar(50) 
)
AS


	declare @strsql varchar(1000)
	if (@intBlock <> 0 and @strName <> '')
	begin
		set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, ' +
			' StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + 
			' where BlockID = ' + CONVERT(varchar, @intBlock) + ' and UserName = ' 
			+ char(39) + @strName + char(39) + ' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
	end
	else 
		if (@intBlock = 0)
		begin
			set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + ' as h  where UserName = ' + char(39) + @strName + char(39) + ' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
		end
		else
			set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + ' as h  where UserId = ' + CONVERT(varchar, @intBlock) + ' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
		
	exec (@strsql)









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--创建历史进行基站表查询
CREATE      PROCEDURE Shine_HistoryInOutStation_QueryView_ZZHA
(
	@strTableName	varchar(50),
	@intBlock int,
	@strName varchar(20),
	@intUserType int,
	@strStartDateTime varchar(50),
	@strEndDateTime varchar(50),
	@FileID int 
)
AS


	declare @strsql varchar(1000)
	if (@intBlock <> 0 and @strName <> '')
	begin
		set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, ' +
			' StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + 
			' where BlockID = ' + CONVERT(varchar, @intBlock) + ' and UserName = ' 
			+ char(39) + @strName + char(39) + ' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and StationPlace in (select stationheadplace from Station_Head_Info where stationheadid in(select stationheadid from G_File_Station where fileid='+CONVERT(varchar, @FileID)+')) '+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
	end
	else 
		if (@intBlock = 0)
		begin
			set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + ' as h  where UserName = ' + char(39) + @strName + char(39) +' and StationPlace in (select stationheadplace from Station_Head_Info where stationheadid in(select stationheadid from G_File_Station where fileid='+CONVERT(varchar, @FileID)+')) '+ ' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
		end
		else
			set @strsql =  'select BlockID, UserId, UserName, UserType, StationAddress,StationHeadAddress, StationPlace, InStationTime, OutStationTime,StationX,StationY,StationTime, DeptName from ' + @strTableName + ' as h  where UserId = ' + CONVERT(varchar, @intBlock) + ' and StationPlace in (select stationheadplace from Station_Head_Info where stationheadid in(select stationheadid from G_File_Station where fileid='+CONVERT(varchar, @FileID)+')) '+' and UserType = ' + CONVERT(varchar, @intUserType)+
			' and InStationTime >= '+char(39)+@strStartDateTime+char(39)+' and InStationTime <='+char(39)+@strEndDateTime+char(39)+' order by InStationTime '
		
	exec (@strsql)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加假别设置
CREATE procedure [dbo].[Shine_HolidayType_Add] 
@HolidayCode varchar(20),
@HolidayName varchar(20),
@HolidayAcronym varchar(10),
@remark varchar(200),
@ID int
as 
insert into HolidayType ([ID],HolidayCode,HolidayName,HolidayAcronym,remark) 
values(@ID,@HolidayCode,@HolidayName,@HolidayAcronym,@remark)
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_HolidayType_Delete    Script Date: 2007-6-13 15:33:31 ******/


CREATE procedure Shine_HolidayType_Delete
(@ID int)


as 

delete HolidayType 

where [ID] = @ID








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_HolidayType_Query    Script Date: 2007-6-13 15:33:31 ******/


CREATE procedure Shine_HolidayType_Query

@strWhere varchar(300)
as 

declare @strsql varchar(1000)

if @strWhere = ''


begin

set @strsql = 'select * from HolidayType' 

end

else

begin
set @strsql= 'select * from HolidayType where '+ @strWhere
end

exec(@strsql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--修改假别设置
CREATE procedure [dbo].[Shine_HolidayType_Update]
(@ID int,
@HolidayCode varchar(20),
@HolidayName varchar(20),
@HolidayAcronym varchar(10),
@remark varchar(200))
as 
update HolidayType 
set HolidayCode=@HolidayCode,
HolidayName=@HolidayName,
HolidayAcronym=@HolidayAcronym,
remark=@remark
where [ID] = @ID

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--添加班制信息
CREATE procedure [dbo].[Shine_InfoClass_Add] 
(
@ClassName varchar(20),
@ShortName varchar(20),
@Remark varchar(200),
@ID int
)

as
declare @count int
select @count=count(className) from InfoClass where className=@ClassName
if(@count=0)
begin
insert into InfoClass 
([ID],ClassName,ShortName,Remark)
values(@ID,@ClassName,@ShortName,@Remark)
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--删除班制
CREATE procedure [dbo].[Shine_InfoClass_Delete] 
(
@ID int
)
as
delete TimerInterval where classid=@id

delete InfoClass 
where [ID] = @ID

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_InfoClass_Query    Script Date: 2007-6-13 15:33:32 ******/


CREATE procedure Shine_InfoClass_Query 

@strWhere varchar(200)

as

declare @strsql varchar(1000)

if @strWhere = ''
begin

set @strsql= 'select * from InfoClass'

end

else

begin
set @strsql = 'select * from infoClass where '+ @strWhere
end

exec (@strsql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--修改班制信息
CREATE procedure [dbo].[Shine_InfoClass_Update] 
(
@ID int,
@ClassName varchar(20),
@ShortName varchar(20),
@Remark varchar(200)
)
as
declare @count int
select @count=count(className) from InfoClass where className=@ClassName
if(@count=0)
begin
Update InfoClass 
set ClassName = @ClassName,ShortName = @ShortName,Remark = @Remark
where [ID] = @ID
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




/****** Object:  Stored Procedure dbo.Shine_Menus_Add    Script Date: 2007-6-13 15:33:33 ******/









CREATE  PROCEDURE Shine_Menus_Add
(
@ID int,
@PMenuID int,
@StrewImage varchar (255)='',
@Title varchar (50),
@HrefID varchar (20),
@Href varchar (255),
@IsEnable bit,
@Tip varchar (100),
@Target varchar (20),
@OrderID int,
@Remark varchar (200)
)
AS
INSERT INTO Menus(
[PMenuID], [StrewImage], [Title], [HrefID], [Href], [IsEnable], [Tip], [Target], [OrderID], [Remark]
)VALUES(
@PMenuID, @StrewImage, @Title, @HrefID, @Href, @IsEnable, @Tip, @Target, @OrderID, @Remark 	
)












GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO


CREATE    Proc Shine_Menus_Edit
as
select M1.ID 编号,M1.title 菜单名称,M2.Title 父菜单 from Menus M1 
LEFT join Menus M2 on M1.PMenuID = M2.ID
Order By M1.PmenuID, M1.OrderID Desc

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_Menus_GetModelByPrimaryKey
(
@ID int
)
As
Select [ID], [PMenuID], [StrewImage], [Title], [HrefID], [Href], [IsEnable], [Tip], [Target], [OrderID], [Remark]
	From Menus
	Where [ID] = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE  proc Shine_Menus_GetParentMenu
As
	Select ID,PMenuID,Title FROM Menus Where PMenuID = '0'

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO




/****** Object:  Stored Procedure dbo.Shine_Menus_ID_DeleteA    Script Date: 2007-6-13 15:33:34 ******/








/****** Object:  Stored Procedure dbo.Shine_Menus_ID_DeleteA    Script Date: 2007-1-26 16:36:56 ******/

/****** Object:  Stored Procedure dbo.Shine_Menus_ID_DeleteA    Script Date: 2007-1-25 12:54:54 ******/

CREATE   PROCEDURE Shine_Menus_ID_DeleteA
(
	@ID	int
)
AS 
	Declare @IsPMenu	int
	Select @IsPMenu = Count(*) From Menus Where ID = @ID And PMenuID = 0
	if @IsPMenu =1
		Begin
			DELETE Menus WHERE [ID] = @ID
			Delete Menus Where PMenuID = @ID
		End
	Else
		Begin
			Delete Menus Where [ID] = @ID
		End














GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




/****** Object:  Stored Procedure dbo.Shine_Menus_Update    Script Date: 2007-6-13 15:33:34 ******/










CREATE   PROCEDURE Shine_Menus_Update
(
@ID int,
@PMenuID int,
@StrewImage varchar (255) = '',
@Title varchar (50),
@HrefID varchar (20),
@Href varchar (255),
@IsEnable bit,
@Tip varchar (100),
@Target varchar (20),
@OrderID int,
@Remark varchar (200)
)
AS
	UPDATE Menus Set 
	[PMenuID] = @PMenuID, [Title] = @Title, [HrefID] = @HrefID, [Href] = @Href, [IsEnable] = @IsEnable, [Tip] = @Tip, [Target] = @Target, [OrderID] = @OrderID, [Remark] = @Remark
	Where [ID] = @ID














GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_Points_Add
(
@id int,
@PointId varchar (20),
@x float (8),
@y float (8)
)
AS
INSERT INTO Points(
[PointId], [x], [y]
)VALUES(
@PointId, @x, @y 	
)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO





CREATE PROCEDURE Shine_Points_DeleteByPointId
(
	@strPointId varchar(20)
)
AS
delete Points where PointId = @strPointId


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO




CREATE PROCEDURE Shine_Points_GetList
As
Select [id], [PointId], [x], [y]
	From [Points]


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_Points_GetListByPointId
(
	@strPointId varchar(20)
)
AS

select PointId, x, y from Points where PointId = @strPointId



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO





CREATE PROCEDURE Shine_Points_GetListDistinct AS

select distinct pointid from points order by pointid


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  PROCEDURE Shine_RealTimeInStation_GetListShowAll
(
	@intDeptID int
)
AS

if @intDeptID = 0
begin
	select BlockID, UserName,UserType, DeptID ID, DeptName, State, StationTime, StationAddress,StationHeadAddress, Place, UserID,Directional, LastInStationHeadAntenna, StationHeadID from 
	Shine_RealTimeInStation_All
end
else
	select BlockID, UserName,UserType, DeptID ID, DeptName, State, StationTime, StationAddress,StationHeadAddress, Place, UserID,Directional, LastInStationHeadAntenna, StationHeadID from 
	Shine_RealTimeInStation_All
	where DeptID = @intDeptID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE PROCEDURE Shine_RealTimeInStation_GetListShowAllByUserId 
(
	@UserId int
)
AS
select 
BlockID,
UserName,
UserType, 
DeptID,
DeptName, 
State, 
StationTime, 
StationAddress,
StationHeadAddress, 
Place, 
UserID,
Directional, 
LastInStationHeadAntenna, 
StationHeadID
from 
Shine_RealTimeInStation_All
Where
UserID = @UserId


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



-- 补勤存储过程
CREATE  proc Shine_Shen_AddHistoryOutStation_DeleteRealTimeInStation
   @CodeSenderAddress int, -- 发码器地址
   @DetectTime dateTime, --出井时间
   @StationAddress int, --出井基站地址号
   @StationHeadAddress int -- 出井探头地址号
as
declare @Cards nvarchar(1000)
declare @HeadA int
declare @HeadB int 
set @HeadA=0
set @HeadB=0
set @Cards=cast(@CodeSenderAddress as nvarchar(10))
  exec  dbo.Wwy_Station_InOutStation @DetectTime,@StationAddress,@StationHeadAddress,1,0,0,@Cards
  exec  dbo.Wwy_Station_InOutStation @DetectTime,@StationAddress,@StationHeadAddress,0,0,0,@Cards
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE    procedure [dbo].[Shine_Shen_AttendanceInitialData] @strWhere varchar(500),@strWhereInner varchar(100),@pageIndex int,@PageSize int

as 

declare @sql nvarchar(4000)

declare @tab1 nvarchar(4000)

set @tab1 =  'select Sum(BlocksUM) 合计,sum(早) 早,sum(中) 中,sum(晚) 晚,BlockID 卡号  
from (select distinct BlockID,COUNT(BlockID) BlocksUM,
case ClassShortName when ''早'' then Count(ClassShortName) end ''早'',
case ClassShortName when ''中'' then Count(ClassShortName) end ''中'',
case ClassShortName when ''晚'' then Count(ClassShortName) end ''晚'' 
from (select distinct BlockID,ClassShortName,DataAttendance from HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID '+@strWhere+') as B 
group by BlockID,ClassShortName)as A 
group by BlockID'

set @sql = 'select distinct H.BlockID 卡号,H.EmployeeName 姓名,D.DeptName 部门 '

select @sql = @sql+',max(case str(day(DataAttendance)) when '+str(1)+' then H. ClassShortName  end) [一],
		     max(case str(day(DataAttendance)) when '+str(2)+' then H. ClassShortName  end) [二],
			max(case str(day(DataAttendance)) when '+str(3)+' then H. ClassShortName  end) [三],
			max(case str(day(DataAttendance)) when '+str(4)+' then H. ClassShortName  end) [四],
			max(case str(day(DataAttendance)) when '+str(5)+' then H. ClassShortName  end) [五],
			max(case str(day(DataAttendance)) when '+str(6)+' then H. ClassShortName  end) [六],
			max(case str(day(DataAttendance)) when '+str(7)+' then H. ClassShortName  end) [七],
			max(case str(day(DataAttendance)) when '+str(8)+' then H. ClassShortName  end) [八],
			max(case str(day(DataAttendance)) when '+str(9)+' then H. ClassShortName  end) [九],
max(case str(day(DataAttendance)) when '+str(10)+' then H. ClassShortName  end) [十],
max(case str(day(DataAttendance)) when '+str(11)+' then H. ClassShortName  end) [十一],
max(case str(day(DataAttendance)) when '+str(12)+' then H. ClassShortName  end) [十二],
max(case str(day(DataAttendance)) when '+str(13)+' then H. ClassShortName  end) [十三],
max(case str(day(DataAttendance)) when '+str(14)+' then H. ClassShortName  end) [十四],
max(case str(day(DataAttendance)) when '+str(15)+' then H. ClassShortName  end) [十五],
max(case str(day(DataAttendance)) when '+str(16)+' then H. ClassShortName  end) [十六],
max(case str(day(DataAttendance)) when '+str(17)+' then H. ClassShortName  end) [十七],
max(case str(day(DataAttendance)) when '+str(18)+' then H. ClassShortName  end) [十八],
max(case str(day(DataAttendance)) when '+str(19)+' then H. ClassShortName  end) [十九],
max(case str(day(DataAttendance)) when '+str(20)+' then H. ClassShortName  end) [二十],
max(case str(day(DataAttendance)) when '+str(21)+' then H. ClassShortName  end) [二一],
max(case str(day(DataAttendance)) when '+str(22)+' then H. ClassShortName  end) [二二],
max(case str(day(DataAttendance)) when '+str(23)+' then H. ClassShortName  end) [二三],
max(case str(day(DataAttendance)) when '+str(24)+' then H. ClassShortName  end) [二四],
max(case str(day(DataAttendance)) when '+str(25)+' then H. ClassShortName  end) [二五],
max(case str(day(DataAttendance)) when '+str(26)+' then H. ClassShortName  end) [二六],
max(case str(day(DataAttendance)) when '+str(27)+' then H. ClassShortName  end) [二七],
max(case str(day(DataAttendance)) when '+str(28)+' then H. ClassShortName  end) [二八],
max(case str(day(DataAttendance)) when '+str(29)+' then H. ClassShortName  end) [二九],
max(case str(day(DataAttendance)) when '+str(30)+' then H. ClassShortName  end) [三十],
max(case str(day(DataAttendance)) when '+str(31)+' then H. ClassShortName  end) [三一]
 ' 


print @sql 

select @sql = @sql + 'from HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID  '+@strWhere +'  group by D.DeptName,H.EmployeeName,H.BlockID,D.DeptID ' 



declare @strsql1 varchar(8000)
declare @strsql2 varchar(8000)


set @strsql2 = 'select count(*) from ('+@sql+') as M'

set @strsql1 = 'select A.*,B.合计,B.早,B.中,B.晚 from ('+@sql+') as A left join ('+@tab1+') as B on A.卡号=B.卡号'

print @sql
exec (@strsql1)
exec (@strsql2)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO
















CREATE      procedure Shine_Shen_AttendanceParticulars  

@strWhere varchar(500),@PageIndex int,@PageSize int 
as

declare @strsql varchar(3000)

declare @strsql1 varchar(3000)
declare @strsql2 varchar(3000)
set @strsql = 'select H.ID,H.BlockID,H.EmployeeName,D.DeptName,
T.NameShort ClassShortName,DI.DutyName,H.BeginWorkTime,
H.EndWorkTime,H.WorkTime,
H.Worktime/H.Worktime ManHourNumber,Substring(Convert(char,H.DataAttendance,120),1,10) as RecordDate
from HistoryAttendance H 
left join Dept_Info D on H.DeptID = D.DeptID
left join Emp_NowCompany E on H.EmployeeID = E.EmpID 
left join TimerInterval T on H.TimerIntervalID = T.ID 
left join dbo.Duty_Info DI ON E.DutyID = DI.DutyID where IsHoliday = 0 and worktime>30 
 '+ @strWhere
  
print @strsql

set @strsql2='select count(*) from ('+@strsql+') as X'

if @PageIndex = 1

begin

	set @strsql1 = 'select top '+str(@PageSize)+' BlockID,EmployeeName,DeptName,ClassShortName,DutyName,BeginWorkTime,EndWorkTime,WorkTime,ManHourNumber,RecordDate from ('+@strsql+') as Y order by ID'

end
else

begin

	set @strsql1 = 'select top '+str(@PageSize)+' BlockID,EmployeeName,DeptName,ClassShortName,DutyName,BeginWorkTime,EndWorkTime,WorkTime,ManHourNumber,RecordDate from ('+@strsql+') as R where ID > (select Max(ID) from ('+@strsql+') as P where ID in (select Top '+str(@PageSize*(@PageIndex - 1))+' ID from ('+@strsql+') as Q order by ID)) order by ID'

end
exec(@strsql1)
exec(@strsql2)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

CREATE  procedure Shine_Shen_AttendanceStatisticByDuty 
(@strWhere varchar(1000), --具体的查询条件 不为空的时候要加Where
@strTime varchar(300) --时间的查询条件 不用加where
)
as
declare @strsql varchar(2000)
declare @strsql1 varchar(3000)
set @strsql = 'select Sum(BlocksUM) 出勤合计,dbo.FunConvertTime(sum(工作时间合计)) 工作时间合计,sum(早) 早,sum(白) 白,sum(晚) 晚,BlockID 卡号,EmpID,DeptName 部门
from (select  DeptID,DeptName,EmpID,BlockID,COUNT(BlockID) BlocksUM,
case ClassShortName when ''早'' then Count(ClassShortName) end ''早'',
case ClassShortName when ''白'' then Count(ClassShortName) end ''白'',
case ClassShortName when ''晚'' then Count(ClassShortName) end ''晚'' ,sum(SumWorkTime) 工作时间合计 
from (select distinct d.dEPTid,D.DeptName,EmployeeID EmpID,BlockID,ClassShortName,DataAttendance,datediff(second,BeginWorkTime,EndWorkTime) SumWorkTime  from HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID where IsHoliday = 0 '+@strWhere+') as B 
group by DePTId,BlockID,ClassShortName,empID,DeptName)as A 
group by deptid,BlockID,EmpID,DeptName'
set @strsql1 = 'select A.部门,A.卡号,ei.EmpName 姓名,di.DutyName 职务,A.出勤合计,A.工作时间合计,A.早,A.白,A.晚 from ('+@strsql+') as A left join Emp_Info ei  on ei.EmpID = A.EmpID left join Emp_NowCompany en on ei.EmpID = en.EmpID left join Duty_Info di on en.DutyID = di.DutyID  '+@strTime
print @strsql
print @strsql1

exec(@strsql1)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  procedure Shine_Shen_AttendanceStatisticSalary @strWhere varchar(2000),@StandardWorkTime int
as

declare @strsql varchar(5000)

set @strsql='select DI.DeptName 所属部门,HA.EmployeeName 员工姓名,BlockID 员工卡号,WorkDayCount 下井次数,
round(convert(float,sumworktime)/60,0) 工时合计,round(convert(float,sumWorkTime*UnitPrice/60),0) 工资合计 
from 
(select sum(WorkTime) sumWorkTime,count(BlockID) WorkDayCount,DeptID,BlockID,EmployeeName from (select BlockID,DeptID,EmployeeName,worktime = case  when worktime>'+str(@StandardWorkTime*60)+' then '+str(@StandardWorkTime*60)+' when worktime<='+str(@StandardWorkTime*60)+' then worktime end 
from HistoryAttendance where  WorkTime>0 '+@strWhere+') as x
group by DeptID,BlockID,EmployeeName) as HA left join UnitPrice UP on HA.DeptID = UP.DeptID 
left join Dept_Info DI on HA.DeptID = DI.DeptID order by HA.DeptID,BlocKID'

print @strsql

exec(@strsql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO














CREATE                  procedure Shine_Shen_EmployeeAttendanceDayByDayStatistic @BeginTime varchar(20),@EndTime varchar(20),@strWhere varchar(200),@PageIndex int,@PageSize int 

as


DECLARE @sql nvarchar(4000)



	
set @sql = 'select DeptName 所属部门,Sdate 日期,sum(EMCount) 合计 '
		
select @sql = @sql+',max(case NS when '''+begindate+'''  then  EMCount  end) ['+begindate+']
		,max(case NS  when '''+begindate+''' then  sumWorkTime  end) ['+begindate+'合计工时(分)] 
		,max(case NS  when '''+begindate+''' then  AVGWorkTime  end) ['+begindate+'平均工时(分)] ' 
from (select distinct T.IntervalName  begindate  
FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID LEFT JOIN TimerInterval T on H.TimerIntervalID = T.ID 
Where IsHoliday = 0 and workTime>30 and substring(convert(char,DataAttendance,120),1,10)>=@BeginTime and substring(convert(char,DataAttendance,120),1,10)<=@EndTime  group by D.DeptName,T.IntervalName) as a order by begindate 
		
		
		
select @sql = @sql + 'from (select sdate,sum(EMCount) EMCount,DeptName,DeptID,NS,sum(sumWorkTime)/sum(EMCount) AVGWorkTime,sum(sumWorkTime) sumWorkTime from  (select  substring(convert(char,DataAttendance,120),1,10) Sdate,Count(*) EMCount,DeptName,DeptID,IntervalName NS,Sum(WorkTime)/Count(*) AVGWorkTime,sum(WorkTime) sumWorkTime from (select distinct BlockID,D.DeptName,D.DeptID,datediff(minute,min(H.BeginWorkTime),max(H.endWorkTime)) workTime,T.IntervalName,dataAttendance   
		FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID left Join TimerInterval T on H.TimerIntervalID = T.ID 
		Where IsHoliday = 0 and WorkTime>30 and substring(convert(char,DataAttendance,120),1,10)>='+char(39)+@BeginTime+char(39)+@strWhere+' and substring(convert(char,DataAttendance,120),1,10)<='+char(39)+@EndTime+char(39)+' group by D.DeptName,D.DeptID,BlockID,T.IntervalName,DataAttendance) as OP group by DeptName,IntervalName,DataAttendance,DeptID) as Z group by DeptID,sdate,DeptName,NS) as Y  group by DeptID,Sdate,DeptName' 


print @sql 
declare @sql1 nvarchar(4000)
declare @sql2 nvarchar(4000)

set @sql1 = 'select Count(*) from ('+@sql+') as Z'

exec(@sql)
exec(@sql1)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO










CREATE procedure Shine_Shen_EmployeeAttendanceDelete @ID int

as 

delete HistoryAttendance where ID = @ID










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create procedure [dbo].[Shine_Shen_EmployeeAttendancePersonelStatistic] 
@BeginTime varchar(20),
@EndTime varchar(20),
@strWhere varchar(500),
@PageIndex int,
@PageSize int  
as
DECLARE @sql varchar(6000)
declare @sql1 varchar(6000)
declare @sql2 varchar(6000)
set @sql = 'select BlockID 卡号,EmployeeName 人员姓名,DeptName 所属部门,sum(EMCount) 出勤合计'
select @sql = @sql+',max(case NS when '''+begindate+'''  then  EMCount  end) ['+begindate+']
		,max(case NS  when '''+begindate+''' then  sumWorkTime  end) ['+begindate+'工时合计(分)] 
		,max(case NS  when '''+begindate+''' then  AVGWorkTime  end) ['+begindate+'平均工时数(分)] ' 
from (select distinct NS as begindate from (select Count(*) EMCount,D.DeptName,T.IntervalName NS,Sum(H.WorkTime)/Count(*) AVGWorkTime,sum(H.WorkTime) sumWorkTime  
FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID left join TimerInterval T on H.TimerIntervalID = T.ID 
Where IsHoliday = 0 and WorkTime>30 and substring(convert(char,DataAttendance,120),1,10)>=@BeginTime and substring(convert(char,DataAttendance,120),1,10)<=@EndTime group by D.DeptName,T.IntervalName) as X ) as a order by begindate 

select @sql = @sql + ' from (select BlockID,EmployeeName, Count(*) EMCount,DeptName,IntervalName NS,Sum(WorkTime)/Count(*) AVGWorkTime,sum(WorkTime) sumWorkTime from (select distinct BlockID,EmployeeName,D.DeptName,H.workTime,T.IntervalName,DataAttendance    
FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID left join TimerInterval T on H.TimerIntervalID = T.ID 
Where IsHoliday = 0 and WorkTime>30 and DataAttendance>='+char(39)+@BeginTime+char(39)+' and DataAttendance<='+char(39)+@EndTime+char(39)+' '+@strWhere+' group by D.DeptName,T.IntervalName,BlockID,EmployeeName,DataAttendance,H.workTime) as OP group by DeptName,IntervalName,EmployeeName,BlockID ) as Y  group by DeptName,BlockID,EmployeeName ' 

print @sql
print '---------------------1'
set @sql2 = 'select Count(*) from ('+@sql+') as X'

print @sql2
print '---------------------2'
if @PageIndex = 1
	begin
		SET @sql1 = 'select top '+str(@PageSize)+' * from ('+@sql+') as Y order by 卡号'		
	end
else

	begin
		SET @sql1 = 'select top '+str(@PageSize)+' * from ('+@sql+') as Y where 卡号 > (select Max(卡号) from ('+@sql+') as Q 
			where 卡号 in (select top '+str((@PageIndex - 1)*@PageSize)+' 卡号 from ('+@sql+') as R 
			order by 卡号)) order by 卡号'	
	end
exec(@sql1)
exec(@sql2)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO














CREATE     procedure Shine_Shen_EmployeeAttendanceQuery @strWhere varchar(500),@PageIndex int,
@PageSize int 

as

declare @strsql varchar(4000)

declare @strsql1 varchar(4000)

declare @sql varchar(1000)

set @sql = 'select H.ID,BlockID,EmployeeName,D.DeptID,H.ClassID,D.DeptName,T.NameShort ClassShortName,H.BeginWorkTime,H.EndWorkTime,H.Remark,TimerIntervalID,DataAttendance
	  from HistoryAttendance H left join Dept_Info D on H.deptID = D.DeptID left join TimerInterval T on H.TimerIntervalID = T.ID   where H.IsHoliday = 0 and workTime>30 '+@strWhere 


set @strsql = 'select Count(*) from ('+@sql+') as X'
print @sql
print '*********1'
if @PageIndex = 1
begin

	SET @strsql1 = 'select top '+str(@PageSize)+' ID,BlockID,EmployeeName,DeptID,ClassID,DeptName,ClassShortName,BeginWorkTime,EndWorkTime,Remark,TimerIntervalID,DataAttendance  
			from ('+@sql+') as Z ORDER BY ID DESC'	
end

else
begin

	SET @strsql1 = 'select top '+str(@PageSize)+' ID,BlockID,EmployeeName,DeptID,ClassID,DeptName,ClassShortName,BeginWorkTime,EndWorkTime,Remark,TimerIntervalID,DataAttendance from 
	('+@sql+') as P where ID < (select MIN(ID) from ('+@sql+') as Q where ID in (select top '+str(@PageSize*(@PageIndex - 1))+
	' ID from ('+@sql+') as R order by ID DESC)) order by ID DESC'
end

print @strsql1

EXEC(@strsql1)
print '**************'
print @strsql
exec(@strsql)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO












CREATE             procedure Shine_Shen_EmployeeAttendanceRateStatistic @BeginTime varchar(20),@EndTime varchar(20)

as


DECLARE @sql nvarchar(4000)
declare @strsql nvarchar(4000)

set @sql = 'select DeptName 所属部门,sum(EMCount) 出勤人次合计 '

select @sql = @sql+',max(case ClassShortName when '''+begindate+'''  then  EMCount  end) ['+begindate+']
		,max(case ClassShortName  when '''+begindate+''' then  AVGWorkTime  end) ['+begindate+'平均工时数(时)] ' 
from (select distinct ClassShortName as begindate from (select Count(*) EMCount,D.DeptName,T.IntervalName ClassShortName,Sum(H.WorkTime)/Count(*) AVGWorkTime  
FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID left join TimerInterval T on H.TimerIntervalID = T.ID 
Where IsHoliday = 0 and WorkTime>30 and substring(convert(char,DataAttendance,120),1,10)>=@BeginTime and substring(convert(char,DataAttendance,120),1,10)<=@EndTime group by D.DeptName,T.IntervalName ) as X ) as a order by begindate 



select @sql = @sql + 'from (select Count(*) EMCount,DeptName,IntervalName ClassShortName,Sum(WorkTime)/Count(*)/60 AVGWorkTime from (select distinct EmployeeName,BlockID,D.DeptName,datediff(minute,min(H.BeginWorkTime),max(H.endWorkTime)) workTime,DataAttendance,T.IntervalName   
FROM HistoryAttendance H left join Dept_Info D on H.DeptID = D.DeptID left Join TimerInterval T on H.TimerIntervalID = T.ID 
Where IsHoliday = 0 and WorkTime>30 and substring(convert(char,DataAttendance,120),1,10)>='+char(39)+@BeginTime+char(39)+' and substring(convert(char,DataAttendance,120),1,10)<='+char(39)+@EndTime+char(39)+' group by EmployeeName,BlockID,D.DeptName,T.IntervalName,DataAttendance) as OP group by DeptName,IntervalName ) as Y  group by DeptName' 

print @sql

set @strsql = 'select count(*) from ('+@sql+') as O'

exec(@sql)
exec(@strsql)









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE        procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeDelete] 
@BlockID int
as



delete RealTimeAttendance where BlockID = @BlockID
delete dbo.RT_InOutMine where CodeSenderAddress = @BlockID
delete dbo.RT_OverTimeInfo where CodeSenderAddress = @BlockID
delete dbo.RT_TerritorialInfo where CodeSenderAddress = @BlockID
--delete dbo.RT_InOutStation where CodeSenderAddress = @BlockID
delete dbo.RT_InStationHeadInfo where CodeSenderAddress=@BlockID
delete dbo.RTInstationHeadTmep where CodeSenderAddress=@BlockID 



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO









CREATE  procedure Shine_Shen_EmployeeAttendanceRealTimeDeleteAndInsert 
@BlockID int,@EmployeeName varchar(10),@DeptID int,@ClassID int,
@ClassShortName varchar(20),@BeginWorkTime varchar(20),@EndWorkTime varchar(20),
@OperatorID int,@Remark varchar(200),@TimerIntervalID int,@DataAttendance varchar(20) 
as 

declare @BookWorkTime int
declare @EmployeeID int

select @EmployeeID = MAX(UserID)  from Shine_Shen_AttendanceClass where BlockID = @BlockID  

insert HistoryAttendance (BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,
BeginWorkTime,EndWorkTime,WorkTime,BookWorkTime,IsAddAttendance,OperatorID,OperatorTime,
Remark,TimerIntervalID,DataAttendance) values(@BlockID,@EmployeeID,@EmployeeName,@DeptID,@ClassID,@ClassShortName,
@BeginWorkTime,@EndWorkTime,datediff(minute,@BeginWorkTime,@EndWorkTime),@BookWorkTime,
1,@OperatorID,Convert(char,getdate(),120),@Remark,@TimerIntervalID,@DataAttendance)

delete RealTimeAttendance where BlockID = @BlockID






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO













CREATE    procedure Shine_Shen_EmployeeAttendanceRealTimeErrorDelete 
@ID int
as

delete RealTimeAttendanceError where ID = @ID 













GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO












CREATE   procedure Shine_Shen_EmployeeAttendanceRealTimeErrorDeleteAndInsert 
@ID int,@BlockID int,@EmployeeName varchar(10),@EmployeeID int,@DeptID int,@ClassID int,
@ClassShortName varchar(20),@BeginWorkTime varchar(20),@EndWorkTime varchar(20),
@OperatorID int,@Remark varchar(200),@TimerIntervalID int,@DataAttendance varchar(20)  
as 

declare @BookWorkTime int


insert HistoryAttendance (BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,
BeginWorkTime,EndWorkTime,WorkTime,BookWorkTime,IsAddAttendance,OperatorID,OperatorTime,
Remark,TimerIntervalID,DataAttendance) values(@BlockID,@EmployeeID,@EmployeeName,@DeptID,@ClassID,@ClassShortName,
@BeginWorkTime,@EndWorkTime,datediff(minute,@BeginWorkTime,@EndWorkTime),@BookWorkTime,
1,@OperatorID,Convert(char,getdate(),120),@Remark,@TimerIntervalID,@DataAttendance)

delete RealTimeAttendanceError where ID = @ID






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO












CREATE   procedure Shine_Shen_EmployeeAttendanceRealTimeErrorQuery @strWhere varchar(300),@PageIndex int,
@PageSize int 

as 


declare @sql varchar(3000)
declare @strsql varchar(4000)
declare @strsql1 varchar(4000)


set @sql = 'select R.ID,BlockID,R.EmployeeID,EmployeeName,D.DeptID,DeptName,R.ClassID,T.NameShort ClassShortName,BeginWorkTime,IsLate,TimerIntervalID from 
	    RealTimeAttendanceError R left join Dept_Info D on R.DeptID = D.DeptID left join TimerInterval T on R.TimerIntervalID = T.ID  where '+@strWhere 


set @strsql = 'select Count(*) from ('+@sql+') as X'
if @PageIndex = 1
Begin
set @strsql1 = 'select Top '+str(@PageSize)+' ID,BlockID,EmployeeID,EmployeeName,DeptID,DeptName,ClassID,ClassShortName,BeginWorkTime,IsLate,TimerIntervalID  
		from ('+@sql+') as Y'
	
End
else
Begin
SET @strsql1 = 'select top '+str(@PageSize)+' ID,BlockID,EmployeeID,EmployeeName,DeptID,DeptName,ClassID,ClassShortName,BeginWorkTime,IsLate,TimerIntervalID  
		from ('+@sql+') as A where ID > (select max(ID) from ('+@sql+') as B where ID in (select top 
		'+str(@PageSize*(@PageIndex - 1))+' ID from ('+@sql+') as C order by ID)) order by ID'

End



exec(@strsql1)
exec(@strsql)








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create procedure [dbo].[Shine_Shen_EmployeeAttendanceRealTimeQuery] @strWhere varchar(500),@PageIndex int,@PageSize int   

as 

declare @strsql varchar(3000)
declare @strsql1 varchar(3000)
declare @strsql2 varchar(3000)

set @strsql = 'select RTI.CodeSenderAddress as BlockID,D.DeptID,KCC.empName as EmployeeName,DeptName,T.NameShort ClassShortName,RTI.InTime as BeginWorkTime,
IsLate,TimerIntervalID  
from RT_InOutMine RTI left join RealTimeAttendance RT on RTI.CodeSenderAddress=RT.BlockID
left join TimerInterval T on RT.TimerIntervalID = T.ID 
Left Join KJ128N_Comm_CsEmpEqu KCC On RTI.CsSetID=KCC.CsSetID
left join Emp_NowCompany eNow on eNow.EmpID=KCC.UserID
left join Dept_Info D on eNow.DeptID = D.DeptID
where 1=1 '+ @strWhere


set @strsql2 = 'select Count(*) from ('+@strsql+') as Z'
if @PageIndex = 1
begin
	set @strsql1 = 'select top '+str(@PageSize)+' * from ('+@strsql+') as X '
end
else
begin
	set @strsql1 = 'select top '+str(@PageSize)+' * from ('+@strsql+') as Y where BlockID >
			(select max(BlockID) from ('+@strsql+') as R where BlockID in (select top   
			'+str(@PageSize*(@PageIndex - 1))+' BlockID from ('+@strsql+') as Q order by BlockID)) 
			order by BlockID'
end


exec (@strsql1)
EXEC (@strsql2)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



CREATE Procedure Shine_Shen_GetEmployeeInfoByDeptID @DeptID int,@BlockID int 
as 
select EI.EmpName,deptID from dbo.Emp_Info EI 
left join dbo.Emp_InCompany EIC on EI.EmpID = EIC.EmpID 
left join  dbo.CodeSender_Set CSS on EI.EmpID = UserID 
left join dbo.Emp_NowCompany DL on EI.EmpID = DL.EmpID 
where CSS.csTypeID = 0 and DL.DeptID = @DeptID and CSS.CodeSenderAddress=@BlockID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO














CREATE    procedure [dbo].[Shine_Shen_HistoryAttendanceAdd] @BlockID int,@EmployeeName varchar(10),
@DeptID int,@ClassID int,@ClassShortName varchar(10),@BeginWorkTime varchar(20),
@EndWorkTime varchar(20),@OperatorID int,@Remark varchar(200),@TimerIntervalID int,@DataAttendance varchar(20) 
as 
declare @temDate dateTime
set @temDate=getdate()
declare @BookWorkTime int
declare @EmployeeID int

select @EmployeeID = max(userID)  from Shine_Shen_AttendanceClass where BlockID = @BlockID

insert into HistoryAttendance (id,BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,
BeginWorkTime,EndWorkTime,WorkTime,IsAddAttendance,OperatorID,OperatorTime,Remark,TimerIntervalID,DataAttendance) 

values(dbo.FunDateBigIntID(@temDate,@BlockID),@BlockID,@EmployeeID,@EmployeeName,@DeptID,@ClassID,@ClassShortName,@BeginWorkTime,
@EndWorkTime,datediff(minute,@BeginWorkTime,@EndWorkTime),1,@OperatorID,Convert(char,getdate(),120),@Remark,@TimerIntervalID,@DataAttendance) 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO











create procedure [dbo].[Shine_Shen_HistoryAttendanceUpdate] 
@ID bigint,@BlockID int,@EmployeeName varchar(10),
@DeptID int,@ClassID int,@ClassShortName varchar(10),@BeginWorkTime varchar(20),
@EndWorkTime varchar(20),@OperatorID int,@Remark varchar(200),@TimerIntervalID int,@DataAttendance varchar(20)  
as 
declare @EmployeeID int
declare @BookWorkTime int
select @EmployeeID = max(UserID) from Shine_Shen_AttendanceClass where BlockID = @BloCkID 
update HistoryAttendance set BlockID = @BlockID,EmployeeID = @EmployeeID,EmployeeName = @EmployeeName,
DeptID = @DeptID,ClassID = @ClassID,ClassShortName = @ClassShortName,BeginWorkTime = @BeginWorkTime,
EndWorkTime = @EndWorkTime,WorkTime = datediff(minute,@BeginWorkTime,@EndWorkTime),BookWorkTime = @BookWorkTime,
IsAddAttendance= 1,OperatorID = @OperatorID,OperatorTime = Convert(char,getdate(),120),remark=@Remark,TimerIntervalID = @TimerIntervalID,DataAttendance=@DataAttendance  where ID = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
向历史区域超员表中插入数据，并删除实时区域超员表中的数据
*/

create procedure Shine_Shen_InsertHisTerrialOverEmp @Cards varchar(6000)

as 

declare @CodeSenderAddress int 
declare @TerrialID int
declare CodeSender cursor for Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0
open CodeSender
fetch next from CodeSender into @CodeSenderAddress
WHILE @@FETCH_STATUS = 0
begin
if not exists(select * from dbo.RT_TerritorialInfo where TerritorialID in 
(select TerrialID from dbo.RT_TerrialOverEmp where CodeSenderAddress=@CodeSenderAddress))
begin
	IF EXISTS(select TerrialID from dbo.RT_TerrialOverEmp where CodeSenderAddress=@CodeSenderAddress)
	BEGIN
		insert into dbo.His_TerrialOverEmp(CodeSenderAddress,TerrialID,OverEmpBeginTime,OverEmpEndTime,OverTime) 
		select RTTOE.CodeSenderAddress,RTTOE.TerrialID,RTTOE.OverEmpTime,getdate(),datediff(second,RTTOE.OverEmpTime,getdate()) 
		from dbo.RT_TerrialOverEmp as RTTOE where RTTOE.CodeSenderAddress=@CodeSenderAddress

		DELETE dbo.RT_TerrialOverEmp WHERE CodeSenderAddress=@CodeSenderAddress
	END

end



fetch next from CodeSender into @CodeSenderAddress
end
close CodeSender
DEALLOCATE CodeSender

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
本存储过程的作用是插入或更新额定工时或额定人数，@bIsEmpCount为是1时，则表示要插入或更新额定工时，否则表示要插入或更新额定人数
*/

CREATE procedure Shine_Shen_InsertTerritorial_Config @TerrialID int,@EmpCount int,@AreaTime int,@bIsEmpCount bit
as
if exists(select 1 from dbo.Territorial_Config where TerritorialID=@TerrialID)
	begin
		if(@bIsEmpCount=1)
		begin
			update dbo.Territorial_Config set TerWorkTime=@AreaTime where TerritorialID=@TerrialID
		end
	else
		begin
		update dbo.Territorial_Config set TerEmpCount=@EmpCount where TerritorialID=@TerrialID
		end
	end
else
	begin
		if(@bIsEmpCount=1)
		begin
			insert dbo.Territorial_Config(TerritorialID,TerWorkTime) values(@TerrialID,@AreaTime)
		end
	else
		begin
			insert dbo.Territorial_Config(TerritorialID,TerEmpCount) values(@TerrialID,@EmpCount)
		end
	end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
插入实时区域超员信息，本存储过程由插入实时进出区域存储过程调用
*/

CREATE PROCEDURE Shine_Shen_RT_TerrialOverEmp @CodeSenderAddress int,@TerrialID int,@BeginTime datetime 
 
as
/*
区域规定人数
*/
declare @ProvisionEmployeeCount int 
/*
区域实际人数
*/
declare @FactEmployeeCount int

select @ProvisionEmployeeCount=TerEmpCount from dbo.Territorial_Config where TerritorialID=@TerrialID 

select @FactEmployeeCount=Count(1) from dbo.RT_TerritorialInfo where TerritorialID=@TerrialID

/*
如果人数为-1则表示当前区域没有设置超员人数，则直接返回，否则用实际的区域人数和区域设置人数进行比较，若实际人数超出设置人数，则插入实时区域
超员表中，否则返回，什么也不作
*/
if @ProvisionEmployeeCount = -1
begin 
return
end
else
begin
	if @FactEmployeeCount>@ProvisionEmployeeCount
	begin
		insert into dbo.RT_TerrialOverEmp (CodeSenderAddress,TerrialID,OverEmpTime) values(@CodeSenderAddress,@TerrialID,@BeginTime)
	end
	else
	begin
	return
	end
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE  procedure Shine_Shen_UnitPrice_Add @DeptID int,@UnitPrice float,@Remark varchar(200)
as 
delete UnitPrice where deptID = @deptID
insert into UnitPrice(DeptID,UnitPrice,Remark) values(@DeptID,@UnitPrice,@Remark)




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE procedure Shine_Shen_UnitPrice_Delete @DeptID int
as 
delete UnitPrice where DeptID =@DeptID



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE  procedure Shine_Shen_UnitPrice_Modify @DeptID int,@UnitPrice float,@Remark varchar(200)
as 
update UnitPrice set UnitPrice =@UnitPrice,Remark = @Remark where DeptID =@DeptID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE  procedure Shine_Shen_UnitPrice_Query @strWhere varchar(200)
as

declare @strsql varchar(2000)

set @strsql = 'select upc.DeptID,di.DeptName 部门名称,Convert(real,upc.UnitPrice) 工时单价, upc.Remark 备注 from UnitPrice Upc left join Dept_Info di on upc.DeptID = di.DeptID '+ @strwhere

exec(@strsql)




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create procedure Shine_Shen_Update_CodeSender_Common @Cards varchar(8000)
as

begin
UPDATE [dbo].[CodeSender_Info]
SET 
	[CodeSenderStateID]=1, [CodeSenderStateTime] = null --设置状态为4, 表示低电量
from (select F1 from dbo.f_splitstr(@Cards,',')) as T1
left join CodeSender_Info CSI On CSI.CodeSenderAddress=T1.F1

end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_StationsInfo_GetListAndEnumInfo AS
select * from shine_StationInfo_GetList


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE PROCEDURE Shine_StationsInfo_GetListStationInfoByAddress
(
	@intStationAddress int,
	@intStationHeadAddress int 
)
AS

select 
StationHeadID id,
StationAddress,
StationHeadAddress,
StationHeadPlace Place, 
(select title from enumTable where EnumID= StationHeadTypeID and FunID =1)  type, 
(select title from enumTable where EnumID = StationHeadState and FunID = 7)  State,
StationHeadX StationX, 
StationHeadY StationY from dbo.Station_Head_Info where StationAddress = @intStationAddress and StationHeadAddress=@intStationHeadAddress 






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_StationsInfo_UpdateHeadAntenna 
(
	@intStationAddress int,
	@intHeadAntennaX float(8),
	@intHeadAntennaY float(8),
	@UpdateABAntenna int
)
AS

If @UpdateABAntenna = 1
Begin
	Update Station_Head_Info Set AntennaAX = @intHeadAntennaX, AntennaAY = @intHeadAntennaY Where StationHeadID = @intStationAddress
End
Else
Begin
	Update Station_Head_Info Set AntennaBX = @intHeadAntennaX, AntennaBY = @intHeadAntennaY Where StationHeadID = @intStationAddress
End


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_StationsInfo_UpdateXY
(
	@intStationAddress int,
	@intScreenX float(8),
	@intScreenY float(8)
)
AS

update Station_Head_Info set StationHeadX = @intScreenX, StationHeadY = @intScreenY where StationHeadID = @intStationAddress


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO





/****** Object:  Stored Procedure dbo.Shine_TastTime_Add    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TastTime_Add 
(@HourNumber bigint,@MinuteNumber bigint,@Remark varchar(100))

as 

insert into TaskTime  (HourNumber ,MinuteNumber,Remark) 
values(@HourNumber,@MinuteNumber,@Remark)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TastTime_Delete    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TastTime_Delete
(@ID int)

as 
Delete TaskTime 
where [ID] = @ID






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TastTime_Query    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TastTime_Query

@strWhere varchar(200)
as 

declare @strsql varchar(1000)

if @strWhere = ''
begin

set @strsql = 'select * FROM dbo.TaskTime'

end

else

begin
set @strsql = 'select * from dbo.TaskTime where '+@strWhere
end

exec(@strsql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TastTime_Update    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TastTime_Update 
(@ID int,@HourNumber bigint,@MinuteNumber bigint,@Remark varchar(100))

as 

update TaskTime  set HourNumber = @HourNumber,MinuteNumber = @MinuteNumber,Remark = @Remark 
where [ID] = @ID








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加班次信息
CREATE procedure [dbo].[Shine_TimerInterval_Add] 
(@IntervalName varchar(50),
@NameShort varchar(8),
@StartWorkTime varchar(20),
@EndWorkTime varchar(20),
@SWDateType int,
@EWDateType int,
@SWFrontTime int,
@SWAfterTime int,
@EWFrontTime int,
@EWAfterTime int,
@ClassID int,
@DataAttendanceType int,
@ID int
)
as
declare @count int
select @count=count(IntervalName) from TimerInterval where IntervalName=@IntervalName
if(@count=0)
begin
insert into TimerInterval 
([ID],IntervalName,NameShort,StartWorkTime,EndWorkTime,SWDateType,EWDateType,SWFrontTime,SWAfterTime,EWFrontTime,EWAfterTime,ClassID,DataAttendanceType) 
values(@ID,@IntervalName,@NameShort,@StartWorkTime,@EndWorkTime,@SWDateType,@EWDateType,@SWFrontTime,@SWAfterTime,@EWFrontTime,@EWAfterTime,@ClassID,@DataAttendanceType)
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TimerInterval_Delete    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TimerInterval_Delete
(@ID int 

)

as

Delete TimerInterval 
Where [ID] = @ID








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TimerInterval_Query    Script Date: 2007-6-13 15:33:41 ******/


CREATE procedure Shine_TimerInterval_Query
(
@strWhere varchar(200)
)

as

declare @strsql varchar(2000)

if @strWhere = ''

begin

	set @strsql = 'select T.ID,T.IntervalName,T.NameShort,Convert(char,T.StartWorkTime,120) StartWorkTime,Convert(char,T.EndWorkTime,120) EndWorkTime,T.SWDateType,T.EWDateType,T.SWFrontTime,T.SWAfterTime,T.EWFrontTime,T.EWAfterTime,T.ClassID,I.ClassName,T.DataAttendanceType from TimerInterval T left join infoClass I on T.ClassID = I.ID '

end

else

begin
	set @strsql = 'select T.ID,T.IntervalName,T.NameShort,Convert(char,T.StartWorkTime,120) StartWorkTime,Convert(char,T.EndWorkTime,120) EndWorkTime,T.SWDateType,T.EWDateType,T.SWFrontTime,T.SWAfterTime,T.EWFrontTime,T.EWAfterTime,T.ClassID,I.ClassName,T.DataAttendanceType from TimerInterval T left join infoClass I on T.ClassID = I.ID where '+@strWhere

end

exec(@strsql)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/****** Object:  Stored Procedure dbo.Shine_TimerInterval_Update    Script Date: 2007-6-13 15:33:42 ******/


CREATE procedure Shine_TimerInterval_Update
(@ID int ,
@IntervalName varchar(50),
@NameShort varchar(8),
@StartWorkTime varchar(20),
@EndWorkTime varchar(20),
@SWDateType int,
@EWDateType int,
@SWFrontTime int,
@SWAfterTime int,
@EWFrontTime int,
@EWAfterTime int,
@ClassID int,
@DataAttendanceType int
)

as

Update TimerInterval set  
IntervalName = @IntervalName,
NameShort = @NameShort,
StartWorkTime = @StartWorkTime,
EndWorkTime = @EndWorkTime,
SWDateType = @SWDateType,
EWDateType = @EWDateType,
SWFrontTime = @SWFrontTime,
SWAfterTime = @SWAfterTime,
EWFrontTime = @EWFrontTime,
EWAfterTime = @EWAfterTime,
ClassID = @ClassID,
DataAttendanceType =  @DataAttendanceType 

Where [ID] = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE  procedure Shine_UserGroupMenu_Delete_DeleteMenu @UserGroupID int

as 

begin


delete dbo.UserGroupMenu where UserGroupID = @UserGroupID

end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO


CREATE    Proc Shine_UserGroupMenu_GetSingeUserGroupMenu
(
	@UserGroupID	int
)
As
	Select U.MenuID,M.ID, M.PMenuID, M.StrewImage, M.Title, M.HrefID, M.Href, M.IsEnable, M.Tip As Tip,  
M.OrderID, M.Remark,E.Title As Target  From UserGroupMenu U
	Left Join Menus M On U.MenuID = M.ID Left Join EnumInfo E On M.Target = E.ID Where U.UserGroupID = @UserGroupID



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO


CREATE  procedure Shine_UserGroupMenu_Insert_InsertMenu @UserGroupID int,@MenuID int 

as 

begin


insert into dbo.UserGroupMenu (UserGroupID,MenuID) values(@UserGroupID,@MenuID)

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE PROCEDURE Shine_UserGroupPower_GetList
AS
	SELECT 
ID,UGPLevelID,	UGPowerName
	 FROM UserGroupPower


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create   PROCEDURE Shine_UserGroup_GetUGPLevelID
	@Account varchar(20),
	@id int

AS
declare @level1 int
declare @level2 int
set @level1=1000000
set @level2 = 100000
set 
 select @level2= UGPLevelID  From  UserGroups UG 
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID
where UG.id = @id
  select @level1 = UGPLevelID  From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID
where a.Account = @Account

if @level1<@level2
 
select 1
else
select 2


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO


CREATE PROCEDURE Shine_UserGroups_Add
(
@ID int ,@UGName varchar (20),@IsEnable bit ,@IsUseEndDate bit ,@UseEndDate smalldatetime ,@UGPowerID int ,@Remark varchar (200)
)
AS 
	INSERT INTO UserGroups(
UGName,IsEnable,IsUseEndDate,UseEndDate,UGPowerID,	Remark
	)VALUES(
@UGName,@IsEnable,@IsUseEndDate,@UseEndDate,@UGPowerID,	@Remark
	)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE   PROCEDURE Shine_UserGroups_Add1
(
@UGName varchar (20),
@IsEnable bit ,@IsUseEndDate bit ,
@UseEndDate smalldatetime ,
@Remark varchar (200)
)
AS 
	INSERT INTO UserGroups(
UGName,IsEnable,IsUseEndDate,UseEndDate,Remark
	)VALUES(
@UGName,@IsEnable,@IsUseEndDate,@UseEndDate,@Remark
	)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE PROCEDURE Shine_UserGroups_GetList
AS
	SELECT 
ID,UGName,IsEnable,IsUseEndDate,UseEndDate,UGPowerID,	Remark
	 FROM UserGroups


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE PROCEDURE Shine_UserGroups_ID_Delete

@ID int
 AS 
	delete Admins where UserGroupID = @ID
	delete UserGroups where [ID] = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO


CREATE PROCEDURE Shine_UserGroups_ID_GetEntity

@ID int
 AS 
	Select
[ID],[UGName],[IsEnable],[IsUseEndDate],[UseEndDate],[UGPowerID],	[Remark]

	From UserGroups
	WHERE [ID] = @ID

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE  PROCEDURE Shine_UserGroups_Update
(
@ID int ,@UGName varchar (20),@IsEnable bit ,@IsUseEndDate bit ,@UseEndDate smalldatetime ,@Remark varchar (200)
)
AS 
	UPDATE UserGroups SET
[UGName] = @UGName,[IsEnable] = @IsEnable,[IsUseEndDate] = @IsUseEndDate,[UseEndDate] = @UseEndDate,	[Remark] = @Remark
	WHERE 
		[ID] = @ID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE PROCEDURE Shine_UserGroups_Update_ForWeb
(
@ID int ,@UGName varchar (20),@IsEnable bit ,@IsUseEndDate bit ,@UseEndDate smalldatetime ,@UGPowerID int ,@Remark varchar (200)
)
AS 
	UPDATE UserGroups SET
[UGName] = @UGName,[IsEnable] = @IsEnable,[IsUseEndDate] = @IsUseEndDate,[UseEndDate] = @UseEndDate,[UGPowerID] = @UGPowerID,	[Remark] = @Remark
	WHERE 
		[ID] = @ID

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE procedure Shine_djc_HisInMineEmpTotal

(@PageIndex int,@PageSize int,@strWhere varchar(300))

as 

declare @strsql varchar(2000)
declare @strsql1 varchar(5000)
declare @strsql2 varchar(3000)
if len(@strWhere)>0
	set @strWhere = ' and '+@strWhere
set @strsql = 'select distinct his.UserID,CodeSenderAddress,ei.EmpName
,(select count(UserID) from His_InOutMine where UserID = his.UserID) as Total
from His_InOutMine as his
left join Emp_Info as ei on ei.EmpID = his.UserID
left join Emp_NowCompany as enc on enc.EmpID = ei.EmpID
where his.CsTypeID = 0'+@strWhere

set @strsql2 = 'select count(1) from ('+@strsql+') as q'

if(@PageIndex =1)
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' CodeSenderAddress,EmpName,Total
			 from ('+@strsql+') as A'
	end
else
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' CodeSenderAddress,EmpName,Total
				 from ('+@strsql+') as A where CodeSenderAddress > 
				(select max(CodeSenderAddress) from (select top '+str((@PageIndex-1)*@PageSize)+' CodeSenderAddress from 
				('+@strsql+') as B order by CodeSenderAddress) as D) order by CodeSenderAddress'
	end

exec(@strsql1)
exec(@strsql2)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create procedure Shine_djc_HisSpecialEmpAlarm

(@PageIndex int,@PageSize int,@strWhere varchar(300))

as 

declare @strsql varchar(2000)
declare @strsql1 varchar(5000)
declare @strsql2 varchar(3000)
if len(@strWhere)>0
	set @strWhere = ' and '+@strWhere
set @strsql = 'select distinct hio.CodeSenderAddress,ei.EmpName,(select count(1) from His_InOutTerritorial where UserID = hio.UserID) as Total
from His_InOutTerritorial as hio
left join Emp_Info as ei on ei.EmpID = hio.UserID
left join Emp_WorkType as ewt on ewt.EmpID = ei.EmpID and ewt.IsEnable = 1 
left join Territorial_Info as t on t.TerritorialID = hio.TerritorialID
where hio.IsAlarm=1 and hio.CsTypeID = 0'+@strWhere
set @strsql2 = 'select count(1) from ('+@strsql+') as q'

if(@PageIndex =1)
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' CodeSenderAddress,EmpName,Total
			 from ('+@strsql+') as A'
	end
else
	begin
		set @strsql1 = 'select top '+str(@PageSize)+' CodeSenderAddress,EmpName,Total
				 from ('+@strsql+') as A where CodeSenderAddress > 
				(select max(CodeSenderAddress) from (select top '+str((@PageIndex-1)*@PageSize)+' CodeSenderAddress from 
				('+@strsql+') as B order by CodeSenderAddress) as D) order by CodeSenderAddress'
	end
exec(@strsql1)
exec(@strsql2)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE  procedure Shine_djc_StatMonthEmp
@year int,
@PageIndex int,
@PageSize int,
@strwhere varchar(2000),
@IsLead int -- 统计类型0为次数 1时间
as
begin
declare @strsql varchar(2000)
if @strwhere <> ''
	begin
		set @strwhere = ' where '+@strwhere
	end
set @strsql='select a.EmpName,a.EmpID from Emp_Info as a 
left join Emp_NowCompany as enc on enc.EmpID = a.EmpID 
left join CodeSender_Set as cs on cs.UserID = enc.EmpID and cs.CsTypeID=0 
left join Emp_Info as ei on ei.EmpID = enc.EmpID 
left join Emp_WorkType as ew on ew.EmpID = enc.EmpID 
left join Duty_Info as di on di.DutyID=enc.DutyID 
'+@strwhere

declare @strsql1 varchar(7000)
if(@PageIndex =1)
begin
	set @strsql1 = 'select top '+str(@PageSize)+' w.EmpName,w.EmpID 
	from ('+@strsql+') as w order by w.EmpID'
end
else
begin
SET @strsql1 = 'select top '+str(@PageSize)+' EmpID,EmpName from 
	('+@strsql+') as P where EmpID < (select MIN(EmpID) from ('+@strsql+') as 
Q where EmpID in (select top '+str(@PageSize*(@PageIndex - 1))+
	' EmpID from ('+@strsql+') as R order by EmpID DESC)) order by EmpID DESC'
end
print @strsql1
if @IsLead = 0
begin
set @strsql1 = 'select w.EmpName
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',1)) as c1
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',2)) as c2
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',3)) as c3
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',4)) as c4
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',5)) as c5
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',6)) as c6
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',7)) as c7
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',8)) as c8
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',9)) as c9
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',10)) as c10
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',11)) as c11
,(dbo.EmpMonthStat(w.EmpID,'+str(@year)+',12)) as c12
,(select count(UserID) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year)+'-1-1'+char(39)+' and InTime<'+char(39)+str(@year+1)+'-1-1'+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID
from ('+@strsql1+') as w'
exec (@strsql1)
end
else
begin
set @strsql1 = 'select w.EmpName
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',1)) as d1
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',2)) as d2
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',3)) as d3
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',4)) as d4
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',5)) as d5
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',6)) as d6
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',7)) as d7
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',8)) as d8
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',9)) as d9
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',10)) as d10
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',11)) as d11
,(dbo.EmpTimeMonthStat(w.EmpID,'+str(@year)+',12)) as d12
,(select dbo.FunConvertTime(ISnull(sum(ContinueTime),0)) as d13 from dbo.His_InOutMine
	where InTime >'+char(39)+str(@year)+'-1-1'+char(39)+' and InTime<'+char(39)+str(@year+1)+'-1-1'+char(39)+
	' and UserID =w.EmpID) as c13 
,w.EmpID 
from ('+@strsql1+') as w'
exec (@strsql1)
end
exec ('select count(1) from ('+@strsql+') as r')
print @strsql1
end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

-- 统计探测器的进出人数状态
CREATE procedure [dbo].[StatCount]
@beginTime datetime,
@endTime datetime

as
begin
	--创建临时表
	create table #UTable
	(
		stationAddress int,
		stationHeadAddress int,
		inA int,
		inB int,
		out int,
		inall int 
	) 

	--分站地址
	declare @stationAddress int
	--探测器地址
	declare @stationHeadAddress int
	--进A人数
	declare @inA int
	--进B人数
	declare @inB int
	--出人数
	declare @out int
	--进人数
	declare @inall int 

	--定义分站游标
	declare stationCursor cursor for (select distinct StationAddress from RT_InOutStation)
	--打开分站游标
	open stationCursor
	--移到下一行
	fetch next from stationCursor into @stationAddress
	while (@@FETCH_STATUS <> -1)
		
	begin
		
		--定义探测器游标
		declare stationHeadCursor cursor for (select distinct StationHeadAddress from RT_InOutStation  where StationAddress = @stationAddress)
		--打开探测器游标
		open stationHeadCursor
		--移到下一行
		fetch next from stationHeadCursor into @stationHeadAddress
		while (@@FETCH_STATUS <> -1)
			
		begin
			--print cast(@stationAddress as nvarchar(10))+'-'+cast(@stationHeadAddress as nvarchar(10))
			set @inA = (select count(InStationHeadAntenna) as 进A from dbo.RT_InOutStation where 
			StationHeadAntennaA =1 and StationAddress = @stationAddress and StationHeadAddress = @stationHeadAddress
			 and StationHeadDetectTime>=@beginTime and StationHeadDetectTime<=@endTime)

			set @inB = (select count(InStationHeadAntenna) as 进B from dbo.RT_InOutStation where 
			StationHeadAntennaB =1 and StationAddress = @stationAddress and StationHeadAddress = @stationHeadAddress
			 and StationHeadDetectTime>=@beginTime and StationHeadDetectTime<=@endTime)

			set @out = (select count(InStationHeadAntenna) as 出 from dbo.RT_InOutStation where 
			StationHeadAntennaA =0 and StationHeadAntennaB = 0 and  StationAddress = @stationAddress and StationHeadAddress = @stationHeadAddress
			 and StationHeadDetectTime>=@beginTime and StationHeadDetectTime<=@endTime)

			set @inall = @inA + @inB + @out

			---插入查询到的当前信息
			insert into #UTable values(@stationAddress,@stationHeadAddress,@inA,@inB,@out,@inall)
			
			fetch next from stationHeadCursor into @stationHeadAddress
		end
						
		--关闭探测器游标
		close stationHeadCursor
		--释放探测器游标
		deallocate stationHeadCursor

		fetch next from stationCursor into @stationAddress
	end
					
	--关闭分站游标
	close stationCursor
	--释放分站游标
	deallocate stationCursor	

	--查询出记录
	select u.stationAddress as 分站地址,u.stationHeadAddress as 探测器地址,shi.StationHeadPlace as 探测器安装地址,
	u.inA as 进天线A发码器数,u.inB as 进天线B发码器数,
    u.out as 出探测器发码器数,u.inall as 进出探测器砝码器总数 from #UTable u
	left join Station_Head_Info shi on shi.stationAddress = u.stationAddress and shi.stationHeadAddress = u.stationHeadAddress
	
	--删除临时表
	drop table #UTable
end
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

--更新实时岗位措施
create procedure UpdateRealTimePostMeasure
@id int,
@meansure varchar(100)
as
update RT_PostInfo set Meansure = @meansure where RTPostID = @id


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--修改行走异常配置信息
CREATE procedure [dbo].[UpdateWalkConfigInfo]

--行走配置信息流水号
@WalkConfigId int,
--人员ID
@EmpID int,

--第一个点（分站编号，探测器编号，天线A，天线B）
@FirstStationAddress int,
@FirstStationHeadAddress int,
@FirstStationHeadAntennaA bit,
@FirstStationHeadAntennaB bit,

--中间点（分站编号，探测器编号，天线A，天线B）
@MiddleStationAddress int,
@MiddleStationHeadAddress int,
@MiddleStationHeadAntennaA bit,
@MiddleStationHeadAntennaB bit,

--最后一个点（分站编号，探测器编号，天线A，天线B）
@LastStationAddress int,
@LastStationHeadAddress int,
@LastStationHeadAntennaA bit,
@LastStationHeadAntennaB bit,

--规定行走时长(以秒计算)
@TimeValue int

as

if (not 
exists(
select * from WalkConfigInfo where EmpID=@EmpID 
and FirstStationAddress = @FirstStationAddress 
and FirstStationHeadAddress = @FirstStationHeadAddress
and FirstStationHeadAntennaA = @FirstStationHeadAntennaA 
and FirstStationHeadAntennaB = @FirstStationHeadAntennaB

and MiddleStationAddress = @MiddleStationAddress 
and MiddleStationHeadAddress = @MiddleStationHeadAddress
and MiddleStationHeadAntennaA = @MiddleStationHeadAntennaA 
and MiddleStationHeadAntennaB = @MiddleStationHeadAntennaB

and LastStationAddress = @LastStationAddress 
and LastStationHeadAddress = @LastStationHeadAddress
and LastStationHeadAntennaA = @LastStationHeadAntennaA 
and LastStationHeadAntennaB = @LastStationHeadAntennaB and WalkConfigId <> @WalkConfigId
)
)

begin

update WalkConfigInfo set 
FirstStationAddress=@FirstStationAddress,FirstStationHeadAddress=@FirstStationHeadAddress,
FirstStationHeadAntennaA=@FirstStationHeadAntennaA,FirstStationHeadAntennaB=@FirstStationHeadAntennaB,

MiddleStationAddress=@MiddleStationAddress,MiddleStationHeadAddress=@MiddleStationHeadAddress,
MiddleStationHeadAntennaA=@MiddleStationHeadAntennaA,MiddleStationHeadAntennaB=@MiddleStationHeadAntennaB,

LastStationAddress=@LastStationAddress,LastStationHeadAddress=@LastStationHeadAddress,
LastStationHeadAntennaA=@LastStationHeadAntennaA,LastStationHeadAntennaB=@LastStationHeadAntennaB,
TimeValue=@TimeValue,EmpID=@EmpID where WalkConfigId = @WalkConfigId

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE   PROCEDURE UserGroups_GetList
AS
	SELECT 
u.ID,UGName,IsEnable,IsUseEndDate,UseEndDate,u.Remark
	 FROM UserGroups U 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE   Proc W_GetUserGroupMenu
(
	@AdminID	int
)
As
	Declare @UGPID int

	If @AdminID < 0  Set @UGPID = -1

	Select @UGPID = UG.ID From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
	left Join UserGroupPower UGP On UGP.ID = UG.UGPowerID
	Where A.ID = @AdminID

	Select M.ID, M.PMenuID, M.StrewImage, M.Title, M.HrefID, M.Href, M.IsEnable, 
		M.Tip As Tip, M.OrderID, M.Remark, E.Title As Target  From UserGroupMenu U 
	Left Join Menus M On U.MenuID = M.ID 
	Left Join EnumInfo E On M.Target = E.ID 
	Where U.UserGroupID = @UGPID And FunID = 9




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create Proc [dbo].[Wwy_Station_InOutStation]
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@IsLowerPower bit,			-- 发码器是否是低电量 0 不是低电量，1 是低电量
	@Cards varchar(6000)
As

--判断时间是否正常，大于当前时间，取当前时间值
if(@DetectTime>getdate())
begin
	set @DetectTime=getdate()
end

-- 去除重复卡号
set @Cards=dbo.FunRepeatString(@Cards)

-- 自动创建历史数据表,自动创建历史视图
exec CreateHistoryDataTable @DetectTime

--低电量报警
--if @IsLowerPower=1
--begin
--	exec KJ128N_Update_CodeSenderLow @Cards --写入低电量报警表 (发码器表)
--end
--else
--begin
--	--申云飞 添加存储过程，如果非低电量报警，则把发码器的报警状态置为正常
--	exec Shine_Shen_Update_CodeSender_Common @Cards 
--end

if @HeadA=1 and @HeadB=1/*求救*/
begin
	--Exec process_EmpHelpInfo @DetectTime,@StationAddress,@StationHeadAddress,@HeadA,@HeadB,@Cards
	print 'a'
end
else
begin
	if(@HeadA=0 and @HeadB=0)  --出
	begin
		--判断实时里的状态是进的时候，并且时间不能比传入的时间大
		--存在的话保存到历史人员进出读卡分站信息
		--状态为进的人员保存到历史读卡分站中
		exec proc_InsertHisStation @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		--更新实时进出读卡分站信息
		exec proc_UpdateRealStation @DetectTime,@StationAddress,@StationHeadAddress,@Cards,1
	end
	else --进
	begin
		--区域信息
		if exists(select t.territorialid from Territorial_Set t 
		join Station_Head_Info sh on t.stationheadid=sh.stationheadid 
		where sh.stationaddress=@StationAddress and sh.stationHeadAddress=@StationHeadAddress and isTerriorialEnter=0)
		begin --该分站有区域存在
			--保存到实时人员区域信息
			exec proc_InsertRealAreaInfo @DetectTime,@StationAddress,@StationHeadAddress,@Cards
			--保存到历史人员信息,并删除实时区域信息
			exec proc_InsertHisAreaANDDeleteRealArea @DetectTime,@StationAddress,@StationHeadAddress,@Cards
			--判断实时区域的人数，大于保存到实时区域超员信息中
			--小于  判断有没有实时区域超员信息，有就保存到历史超员信息中
		end
		else  --保存到历史人员信息,并删除实时区域信息
		begin
			exec proc_InsertHisAreaANDDeleteRealArea @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		end
		--巡检人员信息

		--欠速、超速信息
		exec proc_InsertRTOverSpeed @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		--上下井信息
		if exists(select stationHeadID from Station_Head_Info where stationHeadTypeID=8 
				and stationaddress=@StationAddress and stationHeadAddress=@StationHeadAddress)--上井口分站
		begin
			--保存到历史人员超时信息
			exec proc_InsertHisOverTimeEmployee @DetectTime,@Cards
			--保存到历史下井信息并删除实时下井信息
			exec proc_InsertHisMineANDDeleteRealMine @DetectTime,@StationAddress,@StationHeadAddress,@Cards
			--保存历史考勤记录并删除实时考勤记录
			exec proc_InsertHisEmployeeAttendanceAndDelete @DetectTime,@Cards
			--修改历史欠速、超速信息
			exec proc_UpdateHisOverSpeed @Cards
			--保存下井分站信息
			exec proc_Insert_Update_InMineStationInfo @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		end
		else if exists(select stationHeadID from Station_Head_Info where stationHeadTypeID=32 
				and stationaddress=@StationAddress and stationHeadAddress=@StationHeadAddress)--井下分站
		begin
			--保存到实时下井信息
			exec proc_InsertRealMine @DetectTime,@StationAddress,@StationHeadAddress,@Cards
			--保存实时考勤信息
			exec proc_InsertRTEmployeeAttendance @DetectTime,@Cards
		end

		--保存到实时下井超员信息
		exec proc_InsertUpdateRealTimeOverEmp
		--更新实时进出读卡分站信息
		exec proc_UpdateRealStation @DetectTime,@StationAddress,@StationHeadAddress,@Cards,0
		--添加实时进出读卡分站信息
		exec proc_InsertRealStation @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		--状态为进的人员保存到历史读卡分站中(同个分站，同个读卡分站，同张卡)
		exec proc_InsertHisStationSame @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		--添加到实时进读卡分站临时表中
		exec proc_InsertRealStationTemp @DetectTime,@StationAddress,@StationHeadAddress,@Cards
		--异地交接班信息
		exec Associate_Logic @DetectTime,@StationAddress,@StationHeadAddress,@Cards
	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE         Proc Wwy_Station_InStation
	/*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
As
	/*
		插入记录
		1、卡号不能重复，卡号必须大于 0，所插入的数据应该是在 Rt_InStation 表中不存在的。
	*/
	Insert Into [RT_InOutStation] ([StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [InStationHeadTime], 
		[CodeSenderID], [CodeSenderAddress], [InStationHeadAntenna])
	SELECT @StationAddress As StationAddress, @StationHeadAddress As StationHeadAddress, 
		@HeadA As HeadA, @HeadB As HeadB, @DetectTime As DetectTime,
	CodeSenderID, F1 As CodeSenderAddress, @HeadA + @HeadB * 2 As InStationHeadAntenna
	From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0 And 
		F1 Not In (Select CodeSenderAddress From Rt_InStation)) As T1 
	Left Join CodeSender_Info As T2	On T2.CodeSender = T1.F1


	/*
		更新当前状态
	*/
	If (@HeadA = 0 And @HeadB = 0) 
		Begin
			-- 检测到卡的时间比当前记录新
			Update Rt_InStation
				Set StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB, 
				InStationHeadTime = @DetectTime
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > InStationHeadTime
			)
		End
	Else
		Begin
			-- 检测到卡的时间比当前记录新
			Update Rt_InStation
				Set InStationHeadAntenna = @HeadA + @HeadB * 2, InStationHeadTime = @DetectTime 
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > InStationHeadTime And 
				(
					StationHeadAntennaA = @HeadA And StationHeadAntennaB = @HeadB
						Or
					@HeadA + @HeadB * 2 = InStationHeadAntenna
				)
			)
		End

	-- 检测到卡的时间比当前记录旧，比上次记录新
	Update Rt_InStation
		-- 更新上次状态
		Set LastStationAddress = StationAddress, LastStationHeadAddress = StationHeadAddress,
		LastStationHeadAntennaA = StationHeadAntennaA, LastStationHeadAntennaB = StationHeadAntennaB,
		LastInStationHeadAntenna = InStationHeadAntenna, LastStationHeadDetectTime = InStationHeadTime, 

		-- 更新当前状态
		StationAddress = @StationAddress, StationHeadAddress = @StationHeadAddress, 
		StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB,
		InStationHeadAntenna = @HeadA + @HeadB * 2,	InStationHeadTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime > InStationHeadTime
	)

	-- 比较时间是否比当前小，比上一次更新大
	Update Rt_InStation
		Set LastStationAddress = @StationAddress, LastStationHeadAddress = @StationHeadAddress,
		LastStationHeadAntennaA = @HeadA, LastStationHeadAntennaB = @HeadB,
		LastInStationHeadAntenna = @HeadA + @HeadB * 2, LastStationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime < InStationHeadTime And @DetectTime > LastStationHeadDetectTime And 
		(Not (StationAddress = @StationAddress And StationHeadAddress = @StationHeadAddress) Or
		@HeadA + @HeadB * 2 <> InStationHeadAntenna)
	)
	

   exec proc_Inser_into_RealTimeCodeSender





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






CREATE         Proc Wwy_Station_InStation_BackUP
	/*
		实时进基站表 __备份于2008-9-1
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000)
As
	/*
		插入记录
		1、卡号不能重复，卡号必须大于 0，所插入的数据应该是在 Rt_InStation 表中不存在的。
	*/
	Insert Into [RT_InStation] ([StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [InStationHeadTime], 
		[CodeSenderID], [CodeSenderAddress], [InStationHeadAntenna])
	SELECT @StationAddress As StationAddress, @StationHeadAddress As StationHeadAddress, 
		@HeadA As HeadA, @HeadB As HeadB, @DetectTime As DetectTime,
	CodeSenderID, F1 As CodeSenderAddress, @HeadA + @HeadB * 2 As InStationHeadAntenna
	From (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0 And 
		F1 Not In (Select CodeSenderAddress From Rt_InStation)) As T1 
	Left Join CodeSender_Info As T2	On T2.CodeSender = T1.F1


	/*
		更新当前状态
	*/
	If (@HeadA = 0 And @HeadB = 0) 
		Begin
			-- 检测到卡的时间比当前记录新
			Update Rt_InStation
				Set StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB, 
				InStationHeadTime = @DetectTime
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > InStationHeadTime
			)
		End
	Else
		Begin
			-- 检测到卡的时间比当前记录新
			Update Rt_InStation
				Set InStationHeadAntenna = @HeadA + @HeadB * 2, InStationHeadTime = @DetectTime 
			Where CodeSenderAddress In
			(
				Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
				Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
				Where @DetectTime > InStationHeadTime And 
				(
					StationHeadAntennaA = @HeadA And StationHeadAntennaB = @HeadB
						Or
					@HeadA + @HeadB * 2 = InStationHeadAntenna
				)
			)
		End

	-- 检测到卡的时间比当前记录旧，比上次记录新
	Update Rt_InStation
		-- 更新上次状态
		Set LastStationAddress = StationAddress, LastStationHeadAddress = StationHeadAddress,
		LastStationHeadAntennaA = StationHeadAntennaA, LastStationHeadAntennaB = StationHeadAntennaB,
		LastInStationHeadAntenna = InStationHeadAntenna, LastStationHeadDetectTime = InStationHeadTime, 

		-- 更新当前状态
		StationAddress = @StationAddress, StationHeadAddress = @StationHeadAddress, 
		StationHeadAntennaA = @HeadA, StationHeadAntennaB = @HeadB,
		InStationHeadAntenna = @HeadA + @HeadB * 2,	InStationHeadTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime > InStationHeadTime
	)

	-- 比较时间是否比当前小，比上一次更新大
	Update Rt_InStation
		Set LastStationAddress = @StationAddress, LastStationHeadAddress = @StationHeadAddress,
		LastStationHeadAntennaA = @HeadA, LastStationHeadAntennaB = @HeadB,
		LastInStationHeadAntenna = @HeadA + @HeadB * 2, LastStationHeadDetectTime = @DetectTime
	Where CodeSenderAddress In
	(
		Select CodeSenderAddress From  (Select Distinct F1 FROM f_splitstr(@Cards, ',') Where F1 > 0) As T1
		Left Join Rt_InStation As T2 On T1.F1 = T2.CodeSenderAddress 
		Where @DetectTime < InStationHeadTime And @DetectTime > LastStationHeadDetectTime And 
		(Not (StationAddress = @StationAddress And StationHeadAddress = @StationHeadAddress) Or
		@HeadA + @HeadB * 2 <> InStationHeadAntenna)
	)
	

   exec proc_Inser_into_RealTimeCodeSender





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE  Proc Wwy_Station_Load
As
	Select StationID, StationAddress, StationState, StationGroup, EditBaseInfo, StationVersion From dbo.Station_Info


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create Proc [dbo].[Wwy_Station_StateChange]
(
	@StationAddress int,
	@StationHeadAddress int,
	@StationState int,
	@BreakTime datetime
)
As

declare @BreakTimes int
set @BreakTimes=0
	-- 基站状态故障 [更新基站故障时间、置基站状态为故障]
	If (@StationState = -1000 And @StationHeadAddress = 0)
	begin
		if((select StationState from Station_Info where StationAddress= @StationAddress)<>-1000)
		begin
		
			UPDATE [Station_Info]
				SET [StationState]=@StationState, [BreakTime]=@BreakTime
				WHERE [StationAddress] = @StationAddress 
			--保存到历史进出分站
			exec proc_InsertHisStationByStationError @BreakTime,@StationAddress
		end
	end
      -- 基站状态正常
	If ((not(@StationState = -1000  or @StationState=-2000
                      or @StationState=-1 or @StationState = 0 or @StationState=1  )) And  @StationHeadAddress = 0)
	Begin
         -- 追加历史基站故障
         exec KJ128N_Insert_HistoryBadStations 
              @StationAddress,@StationHeadAddress,@StationState,@BreakTime

        --- 更新实时
		UPDATE [Station_Info]
		SET [StationState]=@StationState,[BreakTimes]=0
		WHERE [StationAddress] = @StationAddress and 
                (StationState = -1000  or StationState=-2000
                      or StationState=-1 or StationState = 0 or StationState=1)
	End
        set @BreakTimes=0
	-- 探头状态故障
	If (@StationState = -1000)
	Begin
		if(not EXISTS (select * from Station_Head_Info where StationAddress = @StationAddress and StationHeadAddress=@StationHeadAddress and StationHeadState=-1000))
		begin
			UPDATE [Station_Head_Info]
			SET [StationHeadState]=@StationState, [BreakTime]=@BreakTime
			WHERE [StationAddress] = @StationAddress 
                	And [StationHeadAddress] = @StationHeadAddress     
			--保存到历史进出分站
			exec proc_InsertHisStationByStationHeadError @BreakTime,@StationAddress,@StationHeadAddress
		end
	End

	-- 探头状态正常
	If (not(@StationState = -1000  or @StationState=-2000
                      or @StationState=-1 or @StationState = 0 or @StationState=1  ))
	Begin
                -- 追加历史探头故障
                exec KJ128N_Insert_HistoryBadStations 
                     @StationAddress,@StationHeadAddress,@StationState,@BreakTime
		
                -- 更新实时探头
                UPDATE [Station_Head_Info]
		SET [StationHeadState]=@StationState,[BreakTimes]=0
		WHERE [StationAddress] = @StationAddress 
                      And [StationHeadAddress] = @StationHeadAddress
                      And
                      (
                       StationHeadState=-1000 or StationHeadState=-2000
                      or StationHeadState=-1 or StationHeadState = 0  or StationHeadState = 1)
	End

	-- 基站休眠
	If (@StationState = -2000 )
	Begin
		  -- 追加历史探头故障
                exec KJ128N_Insert_HistoryBadStations 
                     @StationAddress,@StationHeadAddress,@StationState,@BreakTime
                -- 更新实时基站
                UPDATE [Station_Info]
		SET [StationState]=@StationState
		WHERE [StationAddress] = @StationAddress
                      And StationState<>-2000 
                      
	End
        --基站未初始化
	If (@StationState = 0 )
	Begin
		  -- 追加历史探头故障
                exec KJ128N_Insert_HistoryBadStations 
                     @StationAddress,@StationHeadAddress,@StationState,@BreakTime
                -- 更新实时基站
                UPDATE [Station_Info]
		SET [StationState]=@StationState
		WHERE [StationAddress] = @StationAddress
                      And StationState<>0  
	End

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--袁丽 时间：2008-2-23 13 ：26
--袁丽 修改 时间：2008-04-25 10 ：26
--蔡建钢 修改 时间：2008-6-6 15：30
CREATE  proc [dbo].[Yl_Station_ExecProc]
	@Commands varchar(6000) 
AS
	declare @oneCommand varchar(6000)  
	declare mycursor cursor for select * from [dbo].[f_splitstr](@Commands,';')   --为所获得的数据集指定游标
		open mycursor                   --打开游标
		BEGIN TRANSACTION		--创建事务
		fetch next from mycursor  into @oneCommand   --开始抓第一条数据
		while(@@fetch_status=0)     --如果数据集里一直有数据
		begin
	         	--测试 print @oneCommand
			--创建第二个游标 以及要做的事情
			declare @str1 varchar(6000)
			DECLARE mySelectCursor cursor for select * from [dbo].[f_splitstr](@oneCommand,'.')
			OPEN mySelectCursor
			DECLARE @DetectTime datetime
			declare @IsLowerPower bit
			DECLARE @HeadA bit
			DECLARE @HeadB bit
			DECLARE @Cards varchar(6000)
			if @@CURSOR_ROWS=4
				begin
					--调用存储过程：dbo.Wwy_Station_StateChange					
					DECLARE @StationAddress int
					DECLARE @StationHeadAddress int
					DECLARE @StationState int
					DECLARE @BreakTime datetime
					--设置参数值
					fetch next from mySelectCursor  into @StationAddress
					fetch next from mySelectCursor  into @StationHeadAddress
					fetch next from mySelectCursor  into @StationState
					fetch next from mySelectCursor  into @BreakTime
					EXEC [dbo].[Wwy_Station_StateChange] @StationAddress, @StationHeadAddress, @StationState, @BreakTime

					--dbo.Wwy_Station_StateChange
				end
			else if @@CURSOR_ROWS=7
				begin
					--调用存储过程：dbo.Wwy_Station_InOutStation
					
					-- 设置参数值
					fetch next from mySelectCursor  into @StationAddress
					fetch next from mySelectCursor  into @StationHeadAddress
					fetch next from mySelectCursor  into @IsLowerPower
					fetch next from mySelectCursor  into @HeadA
					fetch next from mySelectCursor  into @HeadB
					fetch next from mySelectCursor  into @DetectTime
					fetch next from mySelectCursor  into @Cards
					EXEC [dbo].[Wwy_Station_InOutStation] @DetectTime, @StationAddress, @StationHeadAddress, @HeadA, @HeadB,@IsLowerPower, @Cards

				end		
			close mySelectCursor
			deallocate mySelectCursor
		fetch next from mycursor into @oneCommand    --跳到下一条数据	
		end
		commit
		close mycursor        --关闭游标
	deallocate mycursor  --删除游标







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








-- KJ128N基本测试用例 构造了六个基本数据运行情况
CREATE       proc  Zdc_KJ128N_BaseTest
as
--清除所有实时数据表
delete from RT_InOutStation -- 清除实时进出基站表
delete from RT_InOutMine  --清除实时下井表
delete from RT_InStationHeadInfo --清除实时进探头表
delete from RealTimeCodeSender  --清除实时发码器表(包括发向性判断)






--清除 基础配置数据
delete from Emp_Info  --清除人员信息

delete from CodeSender_Info  -- 清除发码器信息


delete from CodeSender_Set -- 清除发码器配置


delete from dbo.CodeSender_Directional --发码器方向性 配置

-- 清除 历史数据

delete from His_InOutMine  --  删除历史上下井

delete from His_InOutStation -- 清除历史进出天线

delete from His_InOutStationHead -- 清除历史进出探头

delete from His_OverTimeAlarm -- 清除历史超时
/*
   发码器方向性
*/

INSERT INTO [KJ128N2].[dbo].[CodeSender_Directional]( [DetectionInfo], [Directional])
VALUES('1,0,1:1,0,2','从A到B')

INSERT INTO [KJ128N2].[dbo].[CodeSender_Directional]( [DetectionInfo], [Directional])
VALUES('1,0,2:1,0,1','从B到A')

/*
   添加基本信息
*/

-- 添加六个基本员工数据
Exec KJ128N_Emp_Info_Insert '张大成','NO1',0,''

Exec KJ128N_Emp_Info_Insert '魏文元','NO2',0,''

Exec KJ128N_Emp_Info_Insert '申云飞','NO3',0,''

Exec KJ128N_Emp_Info_Insert '丁静超','NO4',0,''

Exec KJ128N_Emp_Info_Insert '赵建伟','NO5',0,''

Exec KJ128N_Emp_Info_Insert '易晓岚','NO6',0,''


Exec KJ128N_Emp_Info_Insert '马荣辉','NO7',0,''

Exec KJ128N_Emp_Info_Insert '蔡建刚','NO8',0,''

Exec KJ128N_Emp_Info_Insert '李恩仁','NO9',0,''

Exec KJ128N_Emp_Info_Insert '卞爱进','NO10',0,''

Exec KJ128N_Emp_Info_Insert '李乐','NO11',0,''

Exec KJ128N_Emp_Info_Insert '吕锋','NO12',0,''

/*
  　添加6个基本的发码器
*/
Exec KJ128N_CodeSender_Info_Insert 113,1,''

Exec KJ128N_CodeSender_Info_Insert 114,1,''

Exec KJ128N_CodeSender_Info_Insert 115,1,''

Exec KJ128N_CodeSender_Info_Insert 116,1,''

Exec KJ128N_CodeSender_Info_Insert 117,1,''

Exec KJ128N_CodeSender_Info_Insert 118,1,''


Exec KJ128N_CodeSender_Info_Insert 119,1,''

Exec KJ128N_CodeSender_Info_Insert 120,1,''

Exec KJ128N_CodeSender_Info_Insert 121,1,''

Exec KJ128N_CodeSender_Info_Insert 122,1,''

Exec KJ128N_CodeSender_Info_Insert 123,1,''

Exec KJ128N_CodeSender_Info_Insert 124,1,''


/*
  　添加6个人员与发码器配置
*/

declare @UserID int
declare @CodeSenderID int
declare @CodeSender int


select @UserID=empID from Emp_Info where empName='张大成'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=113

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0



select @UserID=empID from Emp_Info where empName='魏文元'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=114

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0


select @UserID=empID from Emp_Info where empName='申云飞'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=115

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0


select @UserID=empID from Emp_Info where empName='丁静超'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=116

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0



select @UserID=empID from Emp_Info where empName='赵建伟'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=117

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0




select @UserID=empID from Emp_Info where empName='易晓岚'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=118

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0




select @UserID=empID from Emp_Info where empName='马荣辉'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=119

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0


select @UserID=empID from Emp_Info where empName='蔡建刚'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=120

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0



select @UserID=empID from Emp_Info where empName='李恩仁'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=121

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0

select @UserID=empID from Emp_Info where empName='卞爱进'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=122

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0


select @UserID=empID from Emp_Info where empName='李乐'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=123

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0

select @UserID=empID from Emp_Info where empName='吕锋'


select @CodeSenderID=CodeSenderID,@CodeSender=CodeSenderAddress from CodeSender_Info where CodeSenderAddress=124

exec dbo.KJ128N_CodeSender_Set_Insert @CodeSenderID,@CodeSender,@UserID,0


/*
    添加基站和探头信息
*/


--略

/*
   通讯基站完成一次进出井过程的测试
*/

-- 有 113 114 115 116 117 118  六个发码器进入考勤基站，下井
exec dbo.Wwy_Station_InOutStation '2007-10-1 11:00:00',2,101,0,0,'113,114,115,116,117,118,119,120,121,122,123,124'


-- 存在 113 114 115 116 117 118  六个发码器进入考勤基站，上井

exec dbo.Wwy_Station_InOutStation '2007-10-1 14:00:00',3,102,0,0,'113,114,115,116,117,118'


-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线A 接收到
exec dbo.Wwy_Station_InOutStation '2007-10-1 15:00:00',1,0,1,0,'113,114,115,116,117,118,121,122,123,124,125'


-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线B 接收到
exec dbo.Wwy_Station_InOutStation '2007-10-1 16:00:00',1,0,0,1,'113,114,115,116,117,118'


-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线A 天线B都没有接收到
exec dbo.Wwy_Station_InOutStation '2007-10-1 17:00:00',1,0,0,0,'113,114,115,116,117,118,121,123'









GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





-- KJ128N系统测试存储过程 
CREATE                     Proc Zdc_KJ128N_TestData
as 
exec Zdc_KJ128N_BaseTest --基本数据的测试

delete from dbo.Station_Head_Info

delete from CodeSender_Directional

delete from  dbo.Station_Info

Select * from dbo.CodeSender_Directional

/*
   查看执行结果是否正确
*/

select * from RT_InOutStation


select * from RT_InOutMine


select * from RT_InStationHeadInfo


select * from His_InOutStationHead

Select count(*),CodeSenderDirectional from RealTimeCodeSender group by CodeSenderDirectional


select * from RealTimeCodeSender

--不同的方向
exec dbo.Wwy_Station_InOutStation '2007-10-14 3:56:00',1,1,1,0,'113'
exec dbo.Wwy_Station_InOutStation '2007-10-14 4:55:00',1,1,0,1,'113'

exec dbo.Wwy_Station_InOutStation '2007-10-14 5:56:00',1,1,0,1,'114'
exec dbo.Wwy_Station_InOutStation '2007-10-14 6:55:00',1,1,1,0,'114'

exec dbo.Wwy_Station_InOutStation '2007-10-14 7:56:00',1,1,0,1,'116'
exec dbo.Wwy_Station_InOutStation '2007-10-14 8:55:00',1,1,0,0,'116'

exec dbo.Wwy_Station_InOutStation '2007-10-14 9:56:00',1,1,1,0,'115'
exec dbo.Wwy_Station_InOutStation '2007-10-14 10:55:00',1,1,0,0,'115'

exec dbo.Wwy_Station_InOutStation '2007-10-14 7:56:00',1,1,0,1,'1311'
exec dbo.Wwy_Station_InOutStation '2007-10-14 8:55:00',1,1,0,0,'1311'

exec dbo.Wwy_Station_InOutStation '2007-10-14 9:56:00',1,1,1,0,'1314'
exec dbo.Wwy_Station_InOutStation '2007-10-14 10:55:00',1,1,0,0,'1314'
-- 经过某一个探头所有的发码器 
-- 基站号 探头号 天线A的统计 天线B的统计 a-b的统计 b-a 的统计 其它未知目的统计

--select Count(*),CodeSenderDirectional from RealTimeCodeSender 
--where 
--group by CodeSenderDirectional



SELECT [RTCodeSenderID], [CodeSenderAddress], [CsSetID], 
[CodeSenderDirectional], [LastPlace], [StationHeadDetectTime], 
[StationAddress], [StationHeadAddress], [InStationHeadAntenna], 
[RtInOutStationId] FROM [KJ128N2].[dbo].[RealTimeCodeSender]


Select * from RealTimeCodeSender

exec dbo.Wwy_Station_InOutStation '2007-10-8 3:55:00',4,2,1,0,'113,114,115,116,117,118'



Declare @InAntenna int
Set @InAntenna=0*2+1

exec proc_Inser_into_RealTimeCodeSender '2007-10-1 15:00:00',1,0,1,0,'113,114,115,116,117,118,121,122,123,124,125',@InAntenna

/*
   区域测试
*/

-- 清除实时区域
    Delete From dbo.RT_TerritorialInfo
-- 清除历史区域
    Delete From dbo.His_InOutTerritorial


select * from RT_TerritorialInfo

select * from His_InOutTerritorial

-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线B 接收到
exec dbo.Wwy_Station_InOutStation '2007-10-6 18:00:00',1,4,1,0,'113,114,115,116,117,118'


-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线A 天线B都没有接收到
exec dbo.Wwy_Station_InOutStation '2007-10-6 19:00:00',2,4,1,0,'113,114,115,116,117,118,121,123'



--下井了
exec dbo.Wwy_Station_InOutStation '2007-10-1 1:00:00',2,101,0,0,'113,114,115,116,117,118'

--进入一号基站 1.1
exec dbo.Wwy_Station_InOutStation '2007-10-1 1:20:00',1,1,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-1 1:40:00',1,1,0,1,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-1 1:50:00',1,1,0,0,'113,114,115,116,117,118'

-- 1.2 

exec dbo.Wwy_Station_InOutStation '2007-10-1 1:55:00',1,2,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-1 1:56:00',1,2,0,1,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-1 2:03:00',1,2,0,0,'113,114,115,116,117,118'

--4.1

exec dbo.Wwy_Station_InOutStation '2007-10-4 2:55:00',4,1,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 2:56:00',4,1,0,1,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 3:03:00',4,1,0,0,'113,114,115,116,117,118'


--4.2

exec dbo.Wwy_Station_InOutStation '2007-10-4 3:55:00',4,2,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 3:56:00',4,2,0,1,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 4:03:00',4,2,0,0,'113,114,115,116,117,118'


--4.3

exec dbo.Wwy_Station_InOutStation '2007-10-4 4:55:00',4,3,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 5:05:00',4,3,0,1,'113,114,115'

exec dbo.Wwy_Station_InOutStation '2007-10-4 5:10:00',4,3,0,0,'117,118'



exec dbo.Wwy_Station_InOutStation '2007-10-4 5:55:00',1,1,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-4 22:55:00',3,102,1,0,'113,114,115,116,117,118'




-- 进出井统计

exec dbo.Wwy_Station_InOutStation '2007-10-7 1:00:00',2,101,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 2:00:00',3,102,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 3:56:00',2,101,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 4:55:00',3,102,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 5:56:00',2,101,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 6:55:00',3,102,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 7:56:00',2,101,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-7 8:55:00',3,102,1,0,'113,114,115,116,117,118'

--  在井下
exec dbo.Wwy_Station_InOutStation '2007-10-7 12:56:00',2,101,1,0,'113,114,115,116,117,118'
exec dbo.Wwy_Station_InOutStation '2007-10-8 3:55:00',4,2,1,0,'113,114,115,116,117,118'

exec dbo.Wwy_Station_InOutStation '2007-10-8 3:56:00',4,2,0,1,'113,114,115,116,117,118'




exec dbo.Wwy_Station_InOutStation '2007-10-7 12:56:00',2,101,1,0,'113,114,115,116,117,118'
exec dbo.Wwy_Station_InOutStation '2007-10-8 3:55:00',4,2,1,0,'113,114,115,116,117,118'

select * from dbo.His_InOutMine





Select * from dbo.RealTimeCodeSender




select * from His_InOutMine

select * from dbo.RT_InOutMine



-- 清除实时和历史数据

delete from RealTimeCodeSender
delete from dbo.His_OverTimeAlarm
-- delete from dbo.RT_OverTimeInfo
-- 基站
delete from dbo.His_InOutStation
delete from dbo.RT_InOutStation
-- 出入探头
delete from dbo.RT_InStationHeadInfo
delete from dbo.His_InOutStationHead
-- 出入井
delete from   dbo.RT_InOutMine
delete from  dbo.His_InOutMine
-- 区域
delete from dbo.RT_TerritorialInfo
delete from dbo.His_InOutTerritorial



select * from RT_InOutStation


-- 测试基站故障

exec Wwy_Station_StateChange 1,0,-1000,'2007-1-1 2:00:00'

exec Wwy_Station_StateChange 1,0,1000,'2007-1-1 3:00:00'





exec Wwy_Station_StateChange 1,2,1000,'2007-1-1 5:00:00'
exec Wwy_Station_StateChange 2,2,-1000,'2007-1-1 6:00:00'
exec Wwy_Station_StateChange 2,2,1000,'2007-1-1 7:00:00'
exec Wwy_Station_StateChange 1,0,-2000,'2007-1-1 8:00:00'
exec Wwy_Station_StateChange 1,0,1000,'2007-1-1 9:00:00'

exec Wwy_Station_StateChange 10,0,-2000,'2007-10-10 9:00:00'



exec Wwy_Station_StateChange 2,2,2000,null



exec Wwy_Station_StateChange 10,1,-2000,'2007-1-2 4:00:00'

select * from Station_Info


select * from HistoryBadStations












Select * from dbo.RealTimeCodeSender


delete from RealTimeCodeSender






exec Wwy_Station_StateChange 4,0,2000,null








-- 系统10月25日测试过程
--1.手动使2 3 号基站正常
exec Wwy_Station_StateChange 2,0,2000,'2007-10-25 8:00:00'
exec Wwy_Station_StateChange 3,0,2000,'2007-10-25 9:00:00'
exec Wwy_Station_StateChange 4,0,2000,'2007-10-25 10:00:00'
--2.测试 113,114 下井
exec dbo.Wwy_Station_InOutStation '2007-10-15 1:56:00',3,102,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 1:58:00',2,102,0,0,'113,114'
-- 结果 实时发码器__不能实时刷 新 实时发码器信息，不能显示所在位置
--3. 测试 113 114 依次经过 1.1 1.2 1.3 1.4 
exec dbo.Wwy_Station_InOutStation '2007-10-15 2:56:00',1,1,1,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 2:58:00',1,1,0,1,'113,114'
-- 察看实时发码器表的信息
select * from RealTimeCodeSender
select * from RT_InOutStation
-- 两个表格中的数据有误差，原因是RealTimeCodeSender 所在天线字段的值取得是最后一次传过来的值，最后一次传过来的值未必是当前值，修改为与RTInOutStaion表数据相同
-- 修改存储过程
-- 修改完成，重新测试一次
-- 清空实时记录
delete from RealTimeCodeSender
delete from dbo.RT_OverTimeInfo
-- 基站
delete from dbo.RT_InOutStation
-- 出入探头
delete from dbo.RT_InStationHeadInfo
-- 出入井
delete from dbo.RT_InOutMine
-- 区域
delete from dbo.RT_TerritorialInfo
-- 查看历史轨迹的基本视图
select * from Shen_HisInOutStationHeadInfo_zdc 
where InStationTime>='2007-10-15' and blockID=113-- and UserName='张大成'
-- 发码器信息及配置信息 增加查询_ 发码器地址，人员或设备 姓名  发码器配置信息增加部门列，查询增加按部门查找

-- 继续测试 113 114
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:01:00',1,1,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:10:11',1,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:10:19',1,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 3:11:00',1,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:12:00',1,3,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:13:00',1,3,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 3:14:00',1,3,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:15:00',1,4,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:16:00',1,4,1,0,'113,114'


exec dbo.Wwy_Station_InOutStation '2007-10-15 4:01:00',4,1,1,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:10:11',4,1,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:10:19',4,1,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:11:00',4,1,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:12:00',4,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:13:00',4,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:14:00',4,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:15:00',4,4,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:16:00',4,4,1,0,'113,114'


exec dbo.Wwy_Station_InOutStation '2007-10-15 4:30:00',4,4,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:31:00',4,5,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:32:00',4,5,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:33:00',4,5,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:34:00',4,6,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:35:00',4,6,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 5:30:00',4,6,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:31:00',1,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:32:00',1,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 5:33:00',1,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:34:00',4,1,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:35:00',4,1,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 3:01:00',1,1,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:10:11',1,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:10:19',1,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 3:11:00',1,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:12:00',1,3,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:13:00',1,3,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 3:14:00',1,3,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:15:00',1,4,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 3:16:00',1,4,1,0,'113,114'


exec dbo.Wwy_Station_InOutStation '2007-10-15 4:01:00',4,1,1,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:10:11',4,1,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:10:19',4,1,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:11:00',4,1,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:12:00',4,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:13:00',4,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:14:00',4,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:15:00',4,4,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:16:00',4,4,1,0,'113,114'


exec dbo.Wwy_Station_InOutStation '2007-10-15 4:30:00',4,4,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:31:00',4,5,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:32:00',4,5,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 4:33:00',4,5,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:34:00',4,6,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 4:35:00',4,6,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 5:30:00',4,6,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:31:00',1,2,0,1,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:32:00',1,2,1,0,'113,114'

exec dbo.Wwy_Station_InOutStation '2007-10-15 5:33:00',1,2,0,0,'113,114'
exec dbo.Wwy_Station_InOutStation '2007-10-15 5:34:00',4,1,0,1,'113,114'

-- 11. 1

-- 进井
exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 1:00:00',1,1,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'


-- 下井人员
exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'214,215,216,217,218'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 0:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'





-- 上下井口基站考勤测试
exec dbo.Wwy_Station_InOutStation '2007-11-4 9:00:00',9,1,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-11-4 10:00:00',1,1,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-11-4 2:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'

exec dbo.Wwy_Station_InOutStation '2007-10-25 3:00:00',2,101,1,0,'113,114,115,116,117,118,119,120,121,122,123,124,125,126,127,128,129,130'



exec dbo.KJ128N_Insert_Update_InOutMine_Attendance






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--蔡建钢 时间：2008-5-20 13 ：21 创建
create proc [dbo].[cjg_select_tcpIpConfig]
as
select ipid,ipaddress,ipport from tcpIpConfig

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc deleteMenus1
@id int 
as
delete menus1 where id = @id



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE procedure [dbo].[deleteRealWriteToHisAlert]
@cardNo int,--卡号
@DetecTime datetime--检测时间
as
declare @empID int
declare @empName nvarchar(10)

set @empID = (select UserID from CodeSender_Set  
			  where CodeSenderAddress=@cardNo and CsTypeId=0)

set @empName = (select EmpName from Emp_Info 
			  where EmpID = @empID)

if @empID is not null 
begin
	declare @isIn int
	--查看实时记录，有无此人报警信息
	set @isIn = (select count(*) from RealTimeAlarmPathInfo where EmpID=@empID)

	--信息存在，插入历时信息
	if @isIn<>0
	begin
		--写入历史表,在删除实时报警表中的此条信息

		--获取路线编号
	--declare @HPathNo varchar(20)
	--set @HPathNo = (select PathNo from Path_Emp_Relation where EmpNo=@EmpNo)
		--获取StationAddress
		declare @HStationAddress int
		set @HStationAddress = (select StationAddress from RealTimeAlarmPathInfo where EmpID=@empID)
		--获取StationHeadAddress
		declare @HStationHeadAddress int
		set @HStationHeadAddress = (select StationHeadAddress  from RealTimeAlarmPathInfo where EmpID=@empID)
		--获取AlertBeginTime
		declare @HAlertBeginTime datetime
		set @HAlertBeginTime = (select AlarmDatetime  from RealTimeAlarmPathInfo where EmpID=@empID)
		
		declare @timeValue int 
		set @timeValue = datediff(second,@HAlertBeginTime,@DetecTime)
		
		if(@empName is null)
		begin
			set @empName = ''
		end

		--写入历史表
		exec insert_His_PathAlert 
			@empID,@empName,@HStationAddress,@HStationHeadAddress,@HAlertBeginTime,@DetecTime,
			@timeValue
		--删除实时表
		exec delete_RealTimeAlarmPathInfo @empID

	end
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--删除His_PathAlert
create procedure delete_His_PathAlert
@Id int
as
delete His_PathAlert where Id=@Id



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--删除Path_Detail
create procedure delete_Path_Detail
@Id int
as 
delete Path_Detail where Id=@id


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--删除Path_Emp_Relation
create procedure delete_Path_Emp_Relation
@Id int
as
delete Path_Emp_Relation where Id=@Id



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--删除Path_Info及相关信息
create procedure delete_Path_Info
@Id int 
as
declare @pathNo varchar(20)
declare @result int
begin transaction deleteInfo

set  @pathNo = (select PathNo from Path_Info where Id=@id)
if @pathNo is not null
begin
--删除Path_Info相关信息
	delete Path_Info where Id=@Id
--删除Path_Detail相关信息
	delete Path_Detail where PathNo= @pathNo
--删除Path_Emp_Relation相关信息
	delete Path_Emp_Relation where PathNo= @pathNo
end

if @@error=0
begin
	commit transaction deleteInfo
	set @result=1
end

else
begin
	rollback transaction deleteInfo
	set @result= -1
end
select result=@result



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




--删除实时报警信息
CREATE procedure [dbo].[delete_RealTimeAlarmPathInfo]
@EmpID int--员工id
as
delete RealTimeAlarmPathInfo where EmpID=@EmpID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--提供手动删除路线报警信息
CREATE procedure [dbo].[delete_RealTimePathAlert]
@EmpID int
as
delete RealTimeAlarmPathInfo where EmpID= @EmpID
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--更具员工编号删除实时巡检信息
CREATE procedure delete_RealTimePathCheck
@EmpNo int 
as
delete RealTimePathCheck where Empid=@EmpNo
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--上井时删除此人的走过路线路线信息(放在考勤上井里)
--exec delete_passStationHeadByCardNO 1
CREATE procedure [dbo].[delete_passStationHeadByCardNO]
@cardNo int
as
declare @EmpID int

set @EmpID = (select UserID from CodeSender_Set  
			where CodeSenderAddress=@cardNo and CsTypeId=0)

if @EmpID is not null 
begin	
	delete passStationHead where EmpID = @EmpID
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--上井时删除此人的路线字符传信息(放在考勤上井里)
--exec delete_pathStringByCardNO 1

CREATE procedure [dbo].[delete_pathStringByCardNO]
@cardNo int
as
declare @EmpID int
set @EmpID = (select UserID from CodeSender_Set  
			where CodeSenderAddress=@cardNo and CsTypeId=0)

if @EmpID is not null 
--print @empNo
begin
	delete pathString where EmpID = @EmpID
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE      proc getAlluser
as
select a.id, a.account  ,a.Isenable,a.IsUseEndDate,A.UseEndDate ,a.remark,u.ugname,
a.Passwordback 
from admins a 
left join  userGroups u  on a.usergroupid = u.id  



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc getMenuAll 
as
select a.id ,a.Title ,b.title from menus1 a left join menus1 b on a.PMenuID = b.id



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc getUserGroupsByAccount
@Account varchar(20)
as
declare @level1 int
 select @level1 = UGPLevelID  From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID



Select UG.UGname,UG.ID From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID where UGP.UGPLeveLID >@level1


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc getUserGroupsPowerByAccount
@Account varchar(20)
as
declare @level1 int
 select @level1 = UGPLevelID  From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID



Select UGp.UGPowername,UGp.ID From Admins A Left Join UserGroups UG On A.UserGroupID = UG.ID
Left Join UserGroupPower UGP On  UG.UGPowerID = UGP.UGPLevelID where UGP.UGPLeveLID >@level1


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE   PROCEDURE inserUser
(

@Account varchar (20),
@Password varchar (16),
@Passwordback varchar (16),
@IsEnable bit,
@IsUseEndDate bit,
@UseEndDate smalldatetime,
@UserGroupID int,
@CreateID int,

@CreateIP bigint,
@Remark varchar (200),
@ID int
)
AS
INSERT INTO Admins([ID],
[Account], [Password], [IsEnable], [IsUseEndDate], [UseEndDate], [UserGroupID], [LoginTotal], [CreateID], [CreateDate], [CreateIP], [FlagTag], [Style], [Remark]
,[Passwordback])VALUES(@ID,
@Account, @Password, @IsEnable, @IsUseEndDate, @UseEndDate, @UserGroupID, 0, @CreateID,getdate(), @CreateIP, 0, 0, @Remark,@Passwordback 		
)





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO



create     proc insertUserGroupMenu1
(
@name varchar (50),
@UserGroupID int,
@ISuse bit
)
as
declare  @id int 
declare @pid int  
set @id = -1
select  @id =id  from menus1 where name = @name
print @name
if (exists (select UserGroupID from UserGroupMenu1 where  @UserGroupID=UserGroupID and @id=MenuID))
begin 


	UPDATE UserGroupMenu1
	SET    ISuse=@ISuse
	where  @UserGroupID=UserGroupID and @id=MenuID
end 
else

	begin 
	INSERT INTO [UserGroupMenu1]( [UserGroupID], [MenuID],ISuse)
	VALUES( @UserGroupID, @id,@ISuse)
end 





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--插入历史信息
CREATE procedure [dbo].[insert_HisPathCheck]
@EmpID int,
@Interval int,
@CheckBeginTime datetime,
@CheckEndTime datetime
as

declare @EmpName nvarchar(10)
set @EmpName=(select EmpName from Emp_Info where EmpID= @EmpID)

insert into HisPathCheck(EmpID,EmpName,Interval,CheckBeginTime,CheckEndTime)
values (@EmpID,@EmpName,@Interval,@CheckBeginTime,@CheckEndTime)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--增加His_PathAlert
CREATE procedure [dbo].[insert_His_PathAlert]
--@PathNo varchar(20),
@EmpID int,
@EmpName varchar(20),
@StationAddress int,
@StationHeadAddress int,
@AlertBeginTime datetime,
@AlertEndTime datetime,
@AlertTimeValue int
as
insert into His_PathAlert(EmpID,EmpName,StationAddress,StationHeadAddress,AlertBeginTime,AlertEndTime,AlertTimeValue)
values(@EmpID,@EmpName,@StationAddress,@StationHeadAddress,@AlertBeginTime,@AlertEndTime,@AlertTimeValue)
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--增加Path_Detail
CREATE  procedure insert_Path_Detail
@PathNo varchar(50),
@StationAddress int,
@StationHeadAddress int
as
--declare @count int 
--set @count = (select count(*) from Path_Detail where PathNo=@PathNo and (StationAddress=@StationAddress 
--and StationHeadAddress = @StationHeadAddress ))
--if @count=0
--begin
	insert into Path_Detail(PathNo,StationAddress,StationHeadAddress)
 values (@PathNo,@StationAddress,@StationHeadAddress)
--end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE procedure [dbo].[insert_Path_Emp_Relation]
@PathNo varchar(20),
@Empid int
as
declare @count int 
set @count=(select count(*) from Path_Emp_Relation where PathNo=@PathNo and Empid=@Empid)
if @count=0
begin
	insert into Path_Emp_Relation(PathNo,Empid) values(@PathNo,@Empid)
end
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--增加Path_Info
CREATE procedure [dbo].[insert_Path_Info]
@PathNo varchar(50),
@PathName varchar(100),
@Remark varchar(200)
as
declare @count int 
set @count = (select count(*) from Path_Info where PathNo=@PathNo)
if @count=0
begin
	insert into Path_Info(PathNo,PathName,Remark) values(@PathNo,@PathName,@Remark)
end 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--插入实时路线报警信息
CREATE procedure [dbo].[insert_RealTimeAlarmPathInfo]
--@PathNo varchar(20),
@EmpID int,  
@StationAddress int,
@StationHeadAddress int,
@AlarmDatetime datetime
as
insert into RealTimeAlarmPathInfo(EmpID,StationAddress,StationHeadAddress,AlarmDatetime)
values(@EmpID,@StationAddress,@StationHeadAddress,@AlarmDatetime)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE procedure [dbo].[insert_RealTimePathCheck]
@EmpID int,
@Interval int,
@CheckTime datetime
as
insert into RealTimePathCheck (Empid,Interval,CheckTime)
values(@Empid,@Interval,@CheckTime)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO








--下井每经过探测器插入此人走过的信息(放在接受数据里面)
CREATE procedure [dbo].[insert_passStationHead]
--卡号
@cardNo int,
--分站地址
@stationAddress int,
--测点地址
@stationHeadAddress int

as
declare @empID int
declare @count int

set @empID = (select UserID from CodeSender_Set  
			  where CodeSenderAddress=@cardNo and CsTypeId=0)
if @empID is not null
begin
	--检查有没有配制路线
	set @count = (select count(1) from Path_Emp_Relation where EmpID=@empID )
	if @count<>0
	begin

		--查找最后一条记录ID，根据记录ID查找到StationAddress和StationHeadAddress
		--再跟当前的数据中的@stationAddress和@stationHeadAddress比对 如果记录不相同，则往里面插入数据

		declare @pId int 

		declare @sa int

		declare @sha int

		--查找当前人的信息最大的id
		set @pId = (select max(PassID) from passStationHead where EmpID=@empID)
		
		if @pId is not null
		begin
		
			set @sa = (select StationAddress from passStationHead where PassID = @pId)

			set @sha = (select StationHeadAddress from passStationHead where PassID = @pId)
			

			if ((@sa <> @stationAddress) or (@sha <> @stationHeadAddress))
			begin
				insert into passStationHead values(@empID,@stationAddress,@stationHeadAddress)
			end

		end

		else
		begin	
			insert into passStationHead values(@empID,@stationAddress,@stationHeadAddress)
		end
	end
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--插入此人的路线字符串处理逻辑 游标嵌套
--exec insert_pathStringByEmpNo 1
--下井时调用插入
CREATE  procedure [dbo].[insert_pathStringByEmpNo]
@cardNo int
as 
declare @empID int
declare @PathNo varchar(20)
declare @string varchar(1000)

--分站地址
declare @sA int
--探头地址
declare @shA int

set @string = ''

set @empID = (select UserID from CodeSender_Set  
			  where CodeSenderAddress=@cardNo and CsTypeId=0)

declare @pathcount int 
--路线字符信息
declare @pathStringcount int
 
set @pathcount = (select count(PathNo) from Path_Emp_Relation where EmpID = @empID)

set @pathStringcount = (select count(1) from pathString where EmpID = @empID)

if @pathcount<>0

begin
if @pathStringcount=0
begin
	declare processPathNo cursor for (select PathNo from Path_Emp_Relation where EmpID = @empID)
		--打开游标
		open processPathNo
		--移到下一行
		fetch next from processPathNo into @PathNo
		while (@@FETCH_STATUS <> -1)
		begin
			
			--print @PathNo

			declare processPathString cursor for (select StationAddress,StationHeadAddress from Path_Detail where PathNo = @PathNo)
			--打开游标
			open processPathString
			--移到下一行
			fetch next from processPathString into @sA,@shA
			while (@@FETCH_STATUS <> -1)
			begin
					
				set @string = @string + cast(@sA as varchar(10))+'-'+cast(@shA as varchar(10))+','
					
				fetch next from processPathString into @sA,@shA	
			end

			--关闭游标
			close processPathString
			--释放游标
			deallocate processPathString

			print @string

			--插入此人的路线字符串
			insert into pathString values(@empID,@string)

			set @string =''
		fetch next from processPathNo into @PathNo	
		end
		--关闭游标
		close processPathNo
		--释放游标
		deallocate processPathNo
end
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create procedure leadMonthStatement
@beginTime datetime,
@endTime datetime
as

select distinct  hiom.CodeSenderAddress as 标识卡,ei.EmpNo as 人员编号 ,hiom.UserName as 人员姓名,
dui.DutyName as 职务,wti.WtName as 工种,di.DeptName as 部门,
(select count(hiom1.UserID) from His_InOutMine as hiom1 where hiom1.UserID=hiom.UserID and hiom1.InTime>=@beginTime and hiom1.InTime<@endTime) as 下井次数,
dbo.FunConvertTime((select sum(ContinueTime) from His_InOutMine as hiom2 where hiom2.UserID=hiom.UserID and hiom2.InTime>=@beginTime and hiom2.InTime<@endTime)) as 下井时间总长
from His_InOutMine as hiom
join Emp_NowCompany as enc on hiom.UserID = enc.EmpID
join Emp_Info as ei on hiom.UserID = ei.EmpID
join Dept_Info as di on enc.DeptID = di.DeptID
left join Duty_Info as dui on dui.DutyID = enc.DutyID
left Join Emp_WorkType as ewt on ewt.EmpID = hiom.UserID
left join WorkType_Info as wti on wti.WorkTypeID = ewt.WorkTypeID
left join EnumTable as et on et.EnumID=dui.DutyClassID and et.FunID=4
where InTime>=@beginTime and InTime<@endTime and CsTypeID=0 and et.EnumID<6
order by hiom.CodeSenderAddress


--exec leadMonthStatement '2008-08-01 00:00:00','2008-08-30 23:59:59'

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--路径删除
CREATE proc pathDetailInfo_Delete
@pathno varchar(50),
@stationAddress int,
@stationHeadAddress int
as
delete from path_detail where pathno=@pathno and stationAddress=@stationAddress and stationHeadAddress=@stationHeadAddress

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--路径删除
CREATE proc pathDetail_Delete
@id int,
@pathno varchar(50)
as
delete from path_detail where id=@id
declare @count int
select @count=count(pathno) from path_detail where pathno=@pathno
if(@count=0)
begin
delete from path_info where pathno=@pathno
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询路径
CREATE proc pathDetail_Select
--查询条件
@condition varchar(1000)
as
declare @execValue varchar(2000)
if @condition=''
begin
set @execValue='select pa.id as pID,pad.id as did,pa.pathNo,pa.PathName,pad.stationAddress,pad.stationHeadAddress,sh.StationHeadPlace,pa.remark from path_info pa
join path_detail pad on pa.pathNo=pad.pathno
join station_head_info sh on pad.stationAddress=sh.stationAddress and pad.stationHeadAddress=sh.stationHeadAddress order by pad.id'
end
else
begin
set @execValue='select pa.id as pID,pad.id as did,pa.pathNo,pa.PathName,pad.stationAddress,pad.stationHeadAddress,sh.StationHeadPlace,pa.remark from path_info pa
join path_detail pad on pa.pathNo=pad.pathno
join station_head_info sh on pad.stationAddress=sh.stationAddress and pad.stationHeadAddress=sh.stationHeadAddress where '+@condition+' order by pad.id'
end
exec (@execValue)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc proc_GetRTTotalInfo_Zdc
(
@addressList varchar(2000),
@sumType int 			--0人员 1设备 2卡
)
as



select Count(*) as AntennaCount,LastInStationHeadAntenna,StationAddress,
StationHeadAddress from RealTimeCodeSender 
group by LastInStationHeadAntenna,StationAddress,StationHeadAddress


select Count(*) as HeadCount,StationAddress,StationHeadAddress from RealTimeCodeSender
group by StationAddress,StationHeadAddress


Select Count(*) as StationCount,StationAddress from RealTimeCodeSender
 group by StationAddress


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE            proc proc_Inser_into_RealTimeCodeSender
(
        /*
		实时进基站表
	*/
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@HeadA bit,						-- 天线 A
	@HeadB bit,						-- 天线 B
	@Cards varchar(6000),
        @InStationAntenna int -- 0 离开探头 1 天线A  2 天线B
)
as 

-- 添加新的记录在RealTimeCodeSender
INSERT INTO [RealTimeCodeSender]
([CodeSenderAddress], [CsSetID], 
[CodeSenderDirectional], [LastPlace], [StationHeadDetectTime], 
[StationAddress], [StationHeadAddress], [InStationHeadAntenna], 
[RtInOutStationId],[LastInStationHeadAntenna])
select T1.F1,Cs.CsSetID,R1.CodeSenderDirectional,R1.LastPlace,
R1.StationHeadDetectTime,
R1.StationAddress,R1.StationHeadAddress,R1.RealInAntenna,R1.RtInOutStationId,
R1.InStationHeadAntenna
from (
      select F1 from dbo.f_splitstr(@Cards,',') where 
      F1 not in(Select CodeSenderAddress from RealTimeCodeSender)
      ) As T1 
Inner join CodeSender_Set Cs On Cs.CodeSenderAddress=T1.F1
Left join  KJ128N_RealTime_CodeSender_Info R1 on R1.CodeSenderAddress=T1.F1



-- 更新新的记录在RealTimeCodeSender
UPDATE [RealTimeCodeSender]

Set CsSetID=Cs.CsSetID,CodeSenderDirectional=R1.CodeSenderDirectional,
LastPlace=R1.LastPlace,StationHeadDetectTime=R1.StationHeadDetectTime,
StationAddress=R1.StationAddress,
StationHeadAddress=R1.StationHeadAddress,
InStationHeadAntenna=R1.RealInAntenna,
RTInOutStationId=R1.RTInOutStationID,
LastInStationHeadAntenna=R1.InStationHeadAntenna
From 
(
   select F1 from dbo.f_splitstr(@Cards,',') where F1 
   in (Select CodeSenderAddress From RealTimeCodeSender)
) As T1 
Left join KJ128N_RealTime_CodeSender_Info R1 On R1.CodeSenderAddress=T1.F1
Left join CodeSender_Set CS On CS.CodeSenderAddress=T1.F1
Where 
   RealTimeCodeSender.CodeSenderAddress = T1.F1







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--保存到历史区域信息并且删除实时区域信息
create proc proc_InsertHisAreaANDDeleteRealArea
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
declare @temDate dateTime
	set @temDate=getdate()
--添加到历史区域信息表中
--判断不是当前区域的，并且进入的当前区域的分站是区域口，则添加数据到历史中
INSERT INTO [His_InOutTerritorial](HisTerritorialID,[TerritorialID], 
[TerritorialName], [TerritorialTypeName], [InTerritorialTime], [CodeSenderAddress], [CsSetID], 
[CsTypeID], [UserID], [UserName], [OutTerritorialTime],[IsAlarm])
Select dbo.FunDateBigIntID(@temDate,RTT1.CodeSenderAddress),RTT1.TerritorialID,RTT1.TerritorialName,RTT1.TerritorialTypeName,
	   RTT1.InTerritorialTime,RTT1.CodeSenderAddress,RTT1.CsSetID,RTT1.CsTypeID,RTT1.UserID,      
	   Case RTT1.CsTypeID
	   when 0  then (Select EmpName from dbo.Emp_Info where EmpID=RTT1.UserID )
	   when 1  then  (Select EquName from dbo.Equ_BaseInfo where EquID=RTT1.UserID )
	   end as  UserName
	   ,@DetectTime	as OutTerritorialTime,RTT1.IsAlarm
from (Select F1 FROM f_splitstr(@Cards, ',')) As FC
		Join RT_TerritorialInfo as RTT1 on RTT1.CodeSenderAddress=FC.F1
		join RT_InStationHeadInfo rtin on rtin.CodeSenderAddress=FC.F1
		where RTT1.TerritorialID not in(
			select TS.TerritorialID from Territorial_Set TS
			join Station_Head_Info SHI On SHI.StationAddress=@StationAddress 
			and SHI.StationHeadAddress=@StationHeadAddress and TS.StationHeadID=SHI.StationHeadID
			where TS.IsTerriorialEnter=0) and rtt1.InTerritorialTime<=@DetectTime and (rtin.StationHeadTime<=@DetectTime or rtin.StationHeadTime is null)
/*
   删除实时区域信息表中的　不在此区域的此发码器的信息,并且是在此区域口，但是是进入区域口
*/
delete from RT_TerritorialInfo 
where 
CodeSenderAddress In (select T1.F1 from (Select F1 FROM f_splitstr(@Cards, ',')) T1
	join RT_InStationHeadInfo rtin on rtin.CodeSenderAddress=T1.F1 where rtin.StationHeadTime<=@DetectTime or rtin.StationHeadTime is null) and
TerritorialID not in(select TS.TerritorialID from Territorial_Set TS
			join Station_Head_Info SHI On SHI.StationAddress=@StationAddress 
			and SHI.StationHeadAddress=@StationHeadAddress and TS.StationHeadID=SHI.StationHeadID
			where TS.IsTerriorialEnter=0) and InTerritorialTime<=@DetectTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史人员考勤信息
create proc proc_InsertHisEmployeeAttendanceAndDelete
	@DetectTime datetime,			-- 检测时间
	@Cards varchar(6000)
as	
declare @temDate dateTime
	set @temDate=getdate()
insert into HistoryAttendance(ID,BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime,
	EndWorkTime,WorkTime,DataAttendance,TimerIntervalID) 
select dbo.FunDateBigIntID(@temDate,T1.F1),T1.F1,rt.EmployeeID,rt.EmployeeName,rt.DeptID,rt.ClassID,rt.ClassShortName,rt.BeginWorkTime,@DetectTime,
	datediff (minute,rt.BeginWorkTime,@DetectTime),rt.DataAttendance,rt.TimerIntervalID 
from (Select F1 from f_splitstr(@Cards,',')) as T1
join RealTimeAttendance rt on rt.blockid=T1.F1
join RT_InStationHeadInfo rtinS on T1.F1=rtinS.CodeSenderAddress
where rt.BeginWorkTime<@DetectTime and (rtinS.StationHeadTime<@DetectTime or rtinS.StationHeadTime is null)

--删除实时考勤记录
delete from RealTimeAttendance
where 
blockid In (select T1.F1 from (Select F1 FROM f_splitstr(@Cards, ',')) T1 
	join RT_InStationHeadInfo rtinS on T1.F1=rtinS.CodeSenderAddress
	where stationHeadTime<@DetectTime or StationHeadTime is null) and BeginWorkTime<@DetectTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--保存到历史下井信息并且删除实时下井信息
create proc proc_InsertHisMineANDDeleteRealMine
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
declare @temDate dateTime
	set @temDate=getdate()
--添加到历史下井信息表中
--判断是否存在实时下井信息，如果存在则保存到历史下井数据中，并删除实时数据
INSERT INTO [His_InOutMine]
    (HisInOutMineID,[InStationAddress], [InStationHeadAddress], 
     [InWellPlace], [CsSetID], [CsTypeID], [UserID],[UserName],
     [CodeSenderAddress], [InTime], 
     [OutStationAddress], [OutStationHeadAddress], 
     [OutWellPlace], [OutTime], [ContinueTime])                     
    Select dbo.FunDateBigIntID(@temDate,RBase.CodeSenderAddress),
        RSHI.StationAddress,RSHI.StationHeadAddress,
        RSHI.StationHeadPlace,KCC.CsSetId,KCC.CsTypeID,KCC.USerID,KCC.empName,
        RBase.CodeSenderAddress,RBase.InTime,@StationAddress,
        @StationHeadAddress,HSHI.StationHeadPlace,@DetectTime,
        DATEDIFF (s ,RBase.InTime,@DetectTime)
     From (select * from RT_InOutMine RTI where RTI.CodeSenderAddress In 
           (select F1 from f_splitStr(@Cards,','))) As RBase
	 join RT_InStationHeadInfo rtinS on RBase.CodeSenderAddress=rtinS.CodeSenderAddress
     Left join Station_Head_Info RSHI  on RBase.StationHeadID=RSHI.StationHeadID
     Left join Station_Head_Info HSHI on HSHI.StationAddress=@StationAddress and HSHI.StationHeadAddress=@StationHeadAddress
     Left Join KJ128N_Comm_CsEmpEqu KCC On KCC.CsSetID=RBase.CsSetId 
	 where RBase.InTime < @DetectTime and (rtinS.StationHeadTime<=@DetectTime or rtinS.StationHeadTime is null)
/*
   删除实时下井表中的信息
*/
delete from RT_InOutMine 
where CodeSenderAddress In 
	(select T1.F1 from (Select F1 FROM f_splitstr(@Cards, ',')) T1 
	join RT_InStationHeadInfo rtinS on T1.F1=rtinS.CodeSenderAddress
	where stationHeadTime<=@DetectTime or StationHeadTime is null)
 and intime<@DetectTime
--修改实时下井表中的信息
update RT_InOutMine
set StationHeadID=HSHI.StationHeadID,InTime=@DetectTime
From (select * from RT_InOutMine RTI where RTI.CodeSenderAddress In 
           (select F1 from f_splitStr(@Cards,','))) As RBase
	 join RT_InStationHeadInfo rtinS on RBase.CodeSenderAddress=rtinS.CodeSenderAddress
     Left join Station_Head_Info HSHI on HSHI.StationAddress=@StationAddress and HSHI.StationHeadAddress=@StationHeadAddress
     Left Join KJ128N_Comm_CsEmpEqu KCC On KCC.CsSetID=RBase.CsSetId 
	 where RBase.InTime < @DetectTime and rtinS.StationHeadTime>@DetectTime and RBase.CodeSenderAddress=RT_InOutMine.CodeSenderAddress

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史人员超时信息
create proc proc_InsertHisOverTimeEmployee
	@DetectTime datetime,			-- 检测时间
	@Cards varchar(6000)
as
declare @temDate dateTime
	set @temDate=getdate()
	-- 历史超时记录
INSERT INTO [His_OverTimeAlarm]([HisOverTimeAlarmID],[CodeSenderAddress], [CsSetID], [CsTypeID], [UserID], [UserName],
 [InMineTime], [DelayedStartTime], [DelayedEndTime], [DelayedTime],[DeptName])
Select dbo.FunDateBigIntID(@temDate,CF.F1),CF.F1,RTOV.CsSetID,RTOV.CsTypeID,RTOV.UserID,EI.EmpName,
    RTOV.InMineTime,RTOV.StartOverTime ,@DetectTime,
    dateDiff(s,RTOV.StartOverTime,@DetectTime),DI.DeptName
from (Select F1 from f_splitstr(@Cards,',')) as CF
Inner join dbo.RT_OverTimeInfo_View RTOV On RTOV.CodeSenderAddress=CF.F1
left Join dbo.Emp_Info EI On EI.EmpID=RTOV.UserID
left join dbo.Emp_NowCompany ENC On ENC.EmpID=RTOV.UserID
Left Join dbo.Dept_Info DI On DI.DeptID=ENC.DeptID
where RTOV.StartOverTime<@DetectTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史读卡分站信息
create proc proc_InsertHisStation
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
	declare @temDate dateTime
	set @temDate=getdate()
     INSERT INTO [His_InOutStationHead](
		[HisStationHeadID], [StationAddress],[StationHeadAddress],[StationHeadPlace],[CodeSenderAddress],
		[CsSetID],[CsTypeID],[UserName],[UserID],[InStationHeadTime],[OutStationHeadTime])
	Select dbo.FunDateBigIntID(@temDate,F1),SHI.StationAddress,SHI.StationHeadAddress,SHI.StationHeadPlace,
	T1.F1,RT.CsSetID,RT.CsTypeID,KCC.EmpName,RT.UserID,RT.InStationHeadTime,@DetectTime
	From (Select F1 From f_splitstr(@Cards,',')) As T1
	Inner Join RTInstationHeadTmep As RT On T1.F1=RT.CodeSenderAddress and RT.StationAddress=@StationAddress and RT.StationHeadAddress=@StationHeadAddress
	Left Join Station_Head_Info SHI On RT.StationAddress=SHI.StationAddress and RT.StationHeadAddress=SHI.stationHeadAddress
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where inStationHeadTime<=@DetectTime

	--删除实时进读卡分站临时表
	delete from RTInstationHeadTmep
	where CodeSenderAddress In (Select F1 FROM f_splitstr(@Cards, ',')) and StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
		and inStationHeadTime<=@DetectTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史读卡分站信息(传输分站故障时)
create proc proc_InsertHisStationByStationError
	@DetectTime datetime,			-- 检测时间
	@StationAddress int			-- 基站号
as
	declare @temDate dateTime
	set @temDate=getdate()
     INSERT INTO [His_InOutStationHead](
		[HisStationHeadID], [StationAddress],[StationHeadAddress],[StationHeadPlace],[CodeSenderAddress],
		[CsSetID],[CsTypeID],[UserName],[UserID],[InStationHeadTime],[OutStationHeadTime])
	Select dbo.FunDateBigIntID(@temDate,CodeSenderAddress),SHI.StationAddress,SHI.StationHeadAddress,SHI.StationHeadPlace,
	CodeSenderAddress,RT.CsSetID,RT.CsTypeID,KCC.EmpName,RT.UserID,RT.InStationHeadTime,@DetectTime
	From RTInstationHeadTmep As RT 
	Left Join Station_Head_Info SHI On RT.StationAddress=SHI.StationAddress and RT.StationHeadAddress=SHI.stationHeadAddress
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where inStationHeadTime<=@DetectTime and RT.StationAddress=@StationAddress
	--删除实时进读卡分站临时表
	delete from RTInstationHeadTmep
	where StationAddress=@StationAddress and inStationHeadTime<=@DetectTime

	exec proc_UpdateRealStationByStationError @DetectTime,@StationAddress

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史读卡分站信息(读卡分站故障时)
create proc proc_InsertHisStationByStationHeadError
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int		-- 探头号
as
	declare @temDate dateTime
	set @temDate=getdate()
     INSERT INTO [His_InOutStationHead](
		[HisStationHeadID], [StationAddress],[StationHeadAddress],[StationHeadPlace],[CodeSenderAddress],
		[CsSetID],[CsTypeID],[UserName],[UserID],[InStationHeadTime],[OutStationHeadTime])
	Select dbo.FunDateBigIntID(@temDate,CodeSenderAddress),SHI.StationAddress,SHI.StationHeadAddress,SHI.StationHeadPlace,
	CodeSenderAddress,RT.CsSetID,RT.CsTypeID,KCC.EmpName,RT.UserID,RT.InStationHeadTime,@DetectTime
	From RTInstationHeadTmep As RT 
	Left Join Station_Head_Info SHI On RT.StationAddress=SHI.StationAddress and RT.StationHeadAddress=SHI.stationHeadAddress
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where inStationHeadTime<=@DetectTime and RT.StationAddress=@StationAddress and RT.StationHeadAddress=@StationHeadAddress
	--删除实时进读卡分站临时表
	delete from RTInstationHeadTmep
	where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
		and inStationHeadTime<=@DetectTime

	exec proc_UpdateRealStationByStationHeadError @DetectTime,@StationAddress,@StationHeadAddress

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史读卡分站信息(直接存历史)
create proc proc_InsertHisStationHis
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
	declare @temDate dateTime
	set @temDate=getdate()
     INSERT INTO [His_InOutStationHead](
		[HisStationHeadID], [StationAddress],[StationHeadAddress],[StationHeadPlace],[CodeSenderAddress],
		[CsSetID],[CsTypeID],[UserName],[UserID],[InStationHeadTime],[OutStationHeadTime])
	Select dbo.FunDateBigIntID(@temDate,F1),@StationAddress,@StationHeadAddress,SHI.StationHeadPlace,
	T1.F1,T3.CsSetID,T3.CsTypeID,KCC.EmpName,T3.UserID,@DetectTime,dateadd(ss,5,@DetectTime)
	From (Select F1 From f_splitstr(@Cards,',')) As T1
	Left Join Station_Head_Info SHI On @StationAddress=SHI.StationAddress and @StationHeadAddress=SHI.stationHeadAddress
	left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1
	Left Join KJ128N_Comm_CsEmpEqu KCC On T3.CsSetID=KCC.CsSetID


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到历史读卡分站信息（在同个读卡分站和传输分站上，并且是同一张卡）
create proc proc_InsertHisStationSame
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
	declare @temDate dateTime
	set @temDate=getdate()
     INSERT INTO [His_InOutStationHead](
		[HisStationHeadID], [StationAddress],[StationHeadAddress],[StationHeadPlace],[CodeSenderAddress],
		[CsSetID],[CsTypeID],[UserName],[UserID],[InStationHeadTime],[OutStationHeadTime])
	Select dbo.FunDateBigIntID(@temDate,F1),SHI.StationAddress,SHI.StationHeadAddress,SHI.StationHeadPlace,
	T1.F1,RT.CsSetID,RT.CsTypeID,KCC.EmpName,RT.UserID,RT.InStationHeadTime,dateadd(ss,5,RT.InStationHeadTime)
	From (Select F1 From f_splitstr(@Cards,',')) As T1
	Inner Join RTInstationHeadTmep As RT On T1.F1=RT.CodeSenderAddress and RT.StationAddress=@StationAddress and RT.StationHeadAddress=@StationHeadAddress
	Left Join Station_Head_Info SHI On RT.StationAddress=SHI.StationAddress and RT.StationHeadAddress=SHI.stationHeadAddress
	Left Join KJ128N_Comm_CsEmpEqu KCC On RT.CsSetID=KCC.CsSetID
	Where inStationHeadTime<=@DetectTime

	--删除实时进读卡分站临时表
	delete from RTInstationHeadTmep
	where CodeSenderAddress In (Select F1 FROM f_splitstr(@Cards, ',')) and StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
		and inStationHeadTime<=@DetectTime

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到实时人员考勤信息
create proc proc_InsertRTEmployeeAttendance
	@DetectTime datetime,			-- 检测时间
	@Cards varchar(6000)
as
insert into RealTimeAttendance(BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime,DataAttendance,TimerIntervalID)
select T1.F1,ssa.UserID,ssa.UserName,ssa.deptid,ssa.classid,ssa.NameShort,@DetectTime,
case ssa.DataAttendanceType
when -1 then 
(case when datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))>0
then dateadd(day,-1,convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),DATEPART(dd,@DetectTime)))))
else convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),
DATEPART(dd,@DetectTime)))) 
end)
when 0 then
(case when datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))>0
then convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),
DATEPART(dd,@DetectTime)))) 
else 
dateadd(day,1,convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),DATEPART(dd,@DetectTime)))))
end)
when 1 then  
(case when datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))>0
then dateadd(day,1,convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),DATEPART(dd,@DetectTime)))))
else convert(datetime,(convert(varchar(4),DATEPART(yyyy,@DetectTime))+'-'+convert(varchar(2),DATEPART(mm,@DetectTime))+'-'+convert(varchar(2),
DATEPART(dd,@DetectTime)))) 
end)
end as DataAttendance,
ssa.TimerIntervalID
from (select F1 from f_splitstr(@Cards,',')) as T1
	join Shine_Shen_AttendanceClass ssa on T1.F1=ssa.blockID
where T1.F1 not in(select BlockID from RealTimeAttendance) and 
	((datediff(minute,convert(varchar(2),DATEPART(hh,StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,StartWorkTime)),
				convert(varchar(2),DATEPART(hh,EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,EndWorkTime)))>0
	and datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,StartWorkTime)))<=0
	and datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))>0) 
	or (datediff(minute,convert(varchar(2),DATEPART(hh,StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,StartWorkTime)),
				convert(varchar(2),DATEPART(hh,EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,EndWorkTime)))<0
	and (datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,StartWorkTime)))<=0 
	and datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))<0)
	or (datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,StartWorkTime)))>=0  
	and datediff(minute,convert(varchar(2),DATEPART(hh,@DetectTime))+':'+convert(varchar(2),DATEPART(mi,@DetectTime))+':'+convert(varchar(2),DATEPART(ss,@DetectTime)),
					convert(varchar(2),DATEPART(hh,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(mi,dateadd(minute,SwAfterTime,StartWorkTime)))+':'+convert(varchar(2),DATEPART(ss,dateadd(minute,SwAfterTime,StartWorkTime))))>0
	and datediff(dd,startworkTime,EndWorkTime)>0))) 
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到实时超速欠速报警信息
create proc proc_InsertRTOverSpeed
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as	
declare @temDate dateTime
	set @temDate=getdate()
insert into His_OverSpeed(HisOverSpeedID,CodeSenderAddress,CsTypeID,UserID,FirstStationAddress,FirstStationHeadAddress,FirstMonitoringTime,
				LastStationAddress,LastStationHeadAddress,LastMonitoringTime,WalkTime,IsOverSpeed,DeptName,DutyName,WtName,IsOutWell,IsEnd,
				EmpName,LackWalkTime,IsLackSpeed)
select dbo.FunDateBigIntID(@temDate,F1), F1 As CodeSenderAddress,Css.CsTypeID,Css.UserID,shi1.StationAddress,shi1.StationHeadAddress,rtInS.StationHeadTime,@StationAddress,
				@StationHeadAddress,@DetectTime,os.walkTime,
				case when datediff(ss,rtInS.StationHeadTime,@DetectTime) < os.walkTime then 1 
				else 0 end,
				Dei.DeptName,Dui.DutyName,Wti.WtName,0,0,Ei.EmpName,os.lackwalkTime,
				case when datediff(ss,rtInS.StationHeadTime,@DetectTime)>os.lackwalkTime then 1 
				else 0 end
			From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
				join  CodeSender_Set As Css On Css.CodeSenderAddress=T1.F1 and Css.CsTypeID=0
				join Emp_Info as Ei on Css.UserID=Ei.EmpID
				join Emp_NowCompany as Enc on Css.UserID=Enc.EmpID
				join station_head_Info shi on StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
				join RT_InStationHeadInfo rtInS on rtInS.codeSenderAddress=T1.F1
				join Station_Head_Info shi1 on rtInS.StationHeadID=shi1.StationHeadID
				join OverSpeed os on os.FirstStationAddress=@StationAddress and os.FirstStationHeadAddress=@StationHeadAddress
					and os.LastStationAddress=shi1.StationAddress and os.LastStationHeadAddress=shi1.StationHeadAddress
				left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
				left join Duty_Info as Dui on Enc.DutyID=Dui.DutyID
				Left Join Emp_WorkType as Ewt on Ewt.EmpID=Css.UserID
				Left Join WorkType_Info as Wti on  Ewt.WorkTypeID = Wti.WorkTypeID
where rtInS.StationHeadTime is not null and (datediff(ss,rtInS.StationHeadTime,@DetectTime)<os.walkTime or datediff(ss,rtInS.StationHeadTime,@DetectTime)>os.lackwalkTime)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--插入实时区域信息
create proc proc_InsertRealAreaInfo
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
--添加区域内没有的信息
INSERT INTO [RT_TerritorialInfo]([TerritorialID], [TerritorialName],[InTerritorialTime], [CodeSenderAddress],
 [CsSetID],[CsTypeID],[UserID],[TerritorialTypeName])
SELECT TI.TerritorialID,TerritorialName,@DetectTime,FC.F1,Css.CsSetID,
Css.CsTypeID,Css.UserID,TTy.TypeName
From (Select F1 FROM f_splitstr(@Cards, ',')) As FC
join Station_Head_Info as SHI On SHI.StationAddress=@StationAddress and SHI.StationHeadAddress=@StationHeadAddress      
Join Territorial_Set As TS On TS.StationHeadID=SHI.StationHeadID
Join Territorial_Info AS TI On TS.TerritorialID=TI.TerritorialID
join Territorial_Type TTy on TTy.TerritorialTypeID=TI.TerritorialTypeID
Join CodeSender_Set As CSS On CSS.CodeSenderAddress=FC.F1
where FC.F1 not in(select CodeSenderAddress from RT_TerritorialInfo As RTT where RTT.TerritorialID=TI.TerritorialID) 
and ts.IsTerriorialEnter = 0 and CSS.CsTypeID is not null

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--保存到实时下井信息
create proc proc_InsertRealMine
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
if exists(select RtInOutMineID From RT_InOutMine)
begin
	-- 插入新的下井时间
	INSERT INTO RT_InOutMine([CodeSenderAddress],[StationHeadID], [CsSetID], [InTime])
		Select T1.F1, ISI.StationHeadID,Cs.CsSetID,ISI.InMineStationTime as InTime
			From (Select F1 From f_splitstr(@Cards, ',')) As T1
				--join Station_Head_Info shi on StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
				inner join InMineStationInfo ISI on ISI.CodeSenderAddress=T1.F1
				Inner Join [CodeSender_Set] As Cs On Cs.CodeSenderAddress = T1.F1 
                  and Cs.CsSetID Not in(select cssetid from RT_InOutMine)
			where @DetectTime>=ISI.InMineStationTime
end
else
begin
	Insert into RT_InOutMine([CodeSenderAddress],[StationHeadID], [CsSetID],[InTime])
		Select T1.F1,ISI.StationHeadID,Cs.CsSetID,ISI.InMineStationTime as InTime
			from (Select F1 From f_splitstr(@Cards, ',')) As T1
				--join Station_Head_Info shi on StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress
				inner join InMineStationInfo ISI on ISI.CodeSenderAddress=T1.F1
                inner Join [CodeSender_Set] As Cs On Cs.CodeSenderAddress = T1.F1 
			where @DetectTime>=ISI.InMineStationTime
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加实时读卡分站信息
create proc proc_InsertRealStation
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
 if Exists(select CsSetID from RT_InStationHeadInfo)
   begin
     INSERT INTO [RT_InStationHeadInfo]([CodeSenderAddress], [StationHeadID], 
            [CsSetID], [CsTypeID], [UserID],[InStationHeadTime],[inOutFlag],[StationHeadTime])
      SELECT T1.F1,T4.StationHeadID,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime,0,@DetectTime
      From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
      left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1 
	  Inner Join Station_Head_Info as T4 On T4.StationAddress=@StationAddress and T4.StationHeadAddress=@StationHeadAddress
	  where T1.F1 Not in(select codeSenderAddress from RT_InStationHeadInfo)
      
    end
else
   begin
      INSERT INTO [RT_InStationHeadInfo]([CodeSenderAddress], [StationHeadID], 
            [CsSetID], [CsTypeID], [UserID],[InStationHeadTime],[inOutFlag],[StationHeadTime])
      SELECT T1.F1,T4.StationHeadID,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime,0,@DetectTime
      From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
      left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1
      Inner Join Station_Head_Info as T4 On T4.StationAddress=@StationAddress and T4.StationHeadAddress=@StationHeadAddress
   end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加实时读卡分站临时信息
create proc proc_InsertRealStationTemp
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as
if exists(select StationHeadID from Station_Head_Info where stationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and 
		breakTime<>null and	@DetectTime<breakTime)
begin
	--直接存历史读卡分站表
	exec proc_InsertHisStationHis @DetectTime,@StationAddress,@StationHeadAddress,@Cards
end
else
begin
	if exists(select * from Station_Info where StationAddress=@StationAddress and breakTime<>null and @DetectTime<breakTime)
	begin
		exec proc_InsertHisStationHis @DetectTime,@StationAddress,@StationHeadAddress,@Cards
	end
	else
	begin
		if Exists(select CsSetID from RTInstationHeadTmep)
		begin
		 INSERT INTO [RTInstationHeadTmep]([CodeSenderAddress],[StationAddress],[StationHeadAddress], 
				[CsSetID], [CsTypeID], [UserID],[InStationHeadTime])
		  SELECT T1.F1,@StationAddress,@StationHeadAddress,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime
		  From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
		  left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1 
		  where T1.F1 Not in(select codeSenderAddress from RTInstationHeadTmep where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress)
	      
		end
		else
		begin
		  INSERT INTO [RTInstationHeadTmep]([CodeSenderAddress], [StationAddress],[StationHeadAddress], 
				[CsSetID], [CsTypeID], [UserID],[InStationHeadTime])
		  SELECT T1.F1,@StationAddress,@StationHeadAddress,T3.CsSetID,T3.CsTypeID,T3.UserID,@DetectTime
		  From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
		  left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1
		end
	end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--添加到实时超员信息
create proc proc_InsertUpdateRealTimeOverEmp
as
	Declare @OrgCount int		--额定人数
	Declare @NewCount int		--当前人数	
	declare @RealTimeCount int	--当前超员人数
	--获取额定人数
	select @OrgCount=EnumValue From EnumTable Where FunID=8 and EnumID=1
	--获取当前人数
	select @NewCount=count(1) from RT_InOutMine as Ri left join CodeSender_Set as Css on Ri.CodeSenderAddress=Css.CodeSenderAddress
	where CsTypeID=0 
	--当前人数比额定人数大
	if(@NewCount>@OrgCount)
	begin
		set @RealTimeCount=@NewCount-@OrgCount
		if exists(select top 1 * from RTOverEmployees) --是否有实时超员信息
		begin
			if exists(select top 1 * from RTOverEmployees where maxEmpCount<@RealTimeCount)
			begin--最大超员人数比当前人数小
				--更新最大超员人数和时间，和当前超员人数
				update RTOverEmployees set MaxEmpCount=@RealTimeCount,MaxEmpTime=getdate(),realTimeEmpCount=@RealTimeCount
			end
			else--最大超员人数比当前人数大
			begin
				--更新当前超员人数
				update RTOverEmployees set realTimeEmpCount=@RealTimeCount
			end
		end
		else--没有超员人数信息
		begin
			--添加到实时超员信息中
			insert into RTOverEmployees(beginTime,ratingEmpCount,MaxEmpCount,MaxEmpTime,realTimeEmpCount)
				values(getdate(),@OrgCount,@RealTimeCount,getdate(),@RealTimeCount)
		end
	end
	else--当前人数比额定人数小
	begin
		if exists(select * from RTOverEmployees)
		begin
			insert into HisOverEmployee(HisOverEmployeeID,beginTime,endTime,ratingEmpCount,MaxEmpCount,MaxEmpTime,ExistsTime)
			select top 1 dbo.FunDateBigIntID(getdate(),0), beginTime,getdate(),ratingEmpcount,maxEmpCount,maxEmpTime,
				 dbo.FunConvertTime(datediff(ss,beginTime,getdate())) from RTOverEmployees

			delete from RTOverEmployees
		end
	end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--保存下井分站信息
create proc proc_Insert_Update_InMineStationInfo
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
as	
UPDATE InMineStationInfo
	SET StationAddress=@StationAddress,[StationHeadID]=SHI.StationHeadID,[StationHeadAddress]=@StationHeadAddress, 
	    [CodeSenderAddress]=T1.F1,[InMineStationTime]=@DetectTime
	    from (Select F1 from dbo.f_splitstr(@Cards,',')) as T1
				Inner join InMineStationInfo ISI On ISI.CodeSenderAddress=T1.F1
                Inner join Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
                      and SHI.StationAddress=@StationAddress
	        WHERE InMineStationTime<@DetectTime or (InMineStationTime>getDate() and InMineStationTime>@DetectTime)
	        
if exists(Select CodeSenderAddress from InMineStationInfo )
begin
	INSERT INTO [InMineStationInfo]([StationHeadID],[StationAddress],[StationHeadAddress],
			[CodeSenderAddress], [InMineStationTime])
		select SHI.StationHeadID, @StationAddress,@StationHeadAddress,T1.F1,@DetectTime from 
			(Select F1 from f_splitstr(@Cards,',')) as T1
			 Inner join Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
                     	 and SHI.StationAddress=@StationAddress
			where T1.F1 not in (Select CodeSenderAddress from InMineStationInfo)
end
else
begin
	INSERT INTO [InMineStationInfo]([StationHeadID],[StationAddress], [StationHeadAddress],
			[CodeSenderAddress], [InMineStationTime])
		select SHI.StationHeadID,@StationAddress,@StationHeadAddress,T1.F1,@DetectTime from 
			(Select F1 from f_splitstr(@Cards,',')) as T1	
             Inner join dbo.Station_Head_Info SHI ON SHI.StationHeadAddress=@StationHeadAddress 
             and SHI.StationAddress=@StationAddress	
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

CREATE    proc proc_IpStationConfig_add_txj
(
  @IPAddress nvarchar(20),
  @IPPort  int,
  @PLACE nvarchar(200),
  @ID int
)
As
begin
if((select count(*) from TcpIPConfig where IPAddress=@IPAddress)=0)
	begin
		Insert into TcpIPConfig	(IPId,IPAddress,IPPort,PLACE)values(@ID,@IPAddress,@IPPort,@PLACE)
	end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE    proc proc_IpStationConfig_delete_txj
(

@id int

)
As
	
begin

if((select count(*)  from TcpIPConfig where ipid=@id )=1)
	begin
	--update  TcpIPConfig  set  IPPort=@IPPort,PLACE=@PLACE where ID=@id
	
	delete from TcpIPConfig where ipid=@id
	update Station_Info set IPAddressID=null where IPAddressID=@id
	end




end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO



CREATE    proc proc_IpStationConfig_update_txj
(
  @IPAddress nvarchar(20),
  @IPPort  int,
  @PLACE nvarchar(200),
@id int

)
As
	
begin

if((select count(*)  from TcpIPConfig where ipid=@id and IPAddress= @IPAddress)=1)
	begin
	--
	update  TcpIPConfig  set  IPPort=@IPPort,PLACE=@PLACE where ipid=@id
	
	
	end
else if((select count(*)  from TcpIPConfig where IPAddress=@IPAddress)=0)
	begin
		update  TcpIPConfig  set  IPAddress = @IPAddress,IPPort=@IPPort,PLACE=@PLACE where ipid=@id

	end








end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



CREATE    proc proc_Station_tcpip_update_txj
(

 @stationid int,
@ipid int

)
As
	
begin

if((select count(*)  from Station_Info where stationid=@stationid and ipaddressid= @ipid)<>1)
	begin
	--
	update Station_Info set ipaddressid=@ipid where  stationid=@stationid
	
	
	end

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--历史超速欠速报警信息
create proc proc_UpdateHisOverSpeed
	@Cards varchar(6000)
as	
update His_OverSpeed
set IsOutWell=1,IsEnd=1
From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
	  where T1.F1=His_OverSpeed.codeSenderAddress and T1.F1 not in(select CodeSenderAddress from RT_InOutMine)

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--修改实时读卡分站信息
create proc proc_UpdateRealStation
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000),
	@inOutFlag smallint    --进出状态 0为进 1为出
as
	if(@inOutFlag=1)
	begin
     update [RT_InStationHeadInfo]
		set [StationHeadID]=T4.StationHeadID, 
            [CsSetID]=T3.CsSetID, [CsTypeID]=T3.CsTypeID, [UserID]=T3.UserID,[InStationHeadTime]=@DetectTime,[inOutFlag]=@inOutFlag
      From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
      left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1 
	  Inner Join Station_Head_Info as T4 On T4.StationAddress=@StationAddress and T4.StationHeadAddress=@StationHeadAddress
	  where T1.F1=RT_InStationHeadInfo.codeSenderAddress and inStationHeadTime<=@DetectTime and RT_InStationHeadInfo.StationHeadID=T4.StationHeadID
	end
	else
	begin
	update [RT_InStationHeadInfo]
		set [StationHeadID]=T4.StationHeadID, 
            [CsSetID]=T3.CsSetID, [CsTypeID]=T3.CsTypeID, [UserID]=T3.UserID,[InStationHeadTime]=@DetectTime,[inOutFlag]=@inOutFlag,
			[StationHeadTime]=@DetectTime,[Directional]=csd.Directional
      From (Select F1 FROM f_splitstr(@Cards, ',')) As T1
      left Join CodeSender_Set As T3 On T3.CodeSenderAddress=T1.F1 
	  Inner Join Station_Head_Info as T4 On T4.StationAddress=@StationAddress and T4.StationHeadAddress=@StationHeadAddress
	  left join RT_InStationHeadInfo rti on rti.codeSenderAddress=T1.F1
	  left join Station_Head_Info T5 on T5.StationHeadID=rti.StationHeadID 
	  left join CodeSender_DirectionalAntenna csd on csd.BeginStationAddress=T5.StationAddress and 
		csd.BeginStationHeadAddress=T5.StationHeadAddress and csd.EndStationAddress=@StationAddress and
		csd.EndStationHeadAddress=@StationHeadAddress
	  where T1.F1=rti.codeSenderAddress and (StationHeadTime<=@DetectTime or StationHeadTime is null)
	end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--修改实时读卡分站信息
create proc proc_UpdateRealStationByStationError
	@DetectTime datetime,			-- 检测时间
	@StationAddress int			-- 基站号
as
     update [RT_InStationHeadInfo]
		set [InStationHeadTime]=@DetectTime,[inOutFlag]=1
      From Station_Head_Info as T4 
	  where inStationHeadTime<=@DetectTime and T4.StationAddress=@StationAddress 
		and RT_InStationHeadInfo.StationHeadID=T4.StationHeadID 
	

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--修改实时读卡分站信息
create proc proc_UpdateRealStationByStationHeadError
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int		-- 探头号
as
     update [RT_InStationHeadInfo]
		set [InStationHeadTime]=@DetectTime,[inOutFlag]=1
      From Station_Head_Info as T4 
	  where inStationHeadTime<=@DetectTime and T4.StationAddress=@StationAddress 
		and T4.StationHeadAddress=@StationHeadAddress and RT_InStationHeadInfo.StationHeadID=T4.StationHeadID 
	

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




/****** Object:  Stored Procedure dbo.proc_insert_HistoryAttendance_cjg    Script Date: 2007-6-13 15:33:45 ******/
CREATE proc proc_insert_HistoryAttendance_cjg
@blockid int,  --卡号
@OutWorkTime datetime --下班时间
as
	declare @employeeid int
	declare @deptID int
	declare @classID int
	declare @employeeName varchar(50)
	declare @classShortName varchar(20)
	declare @beginWorkTime datetime
	declare @DataAttendance datetime
	declare @TimerIntervalID int 
	select @employeeid=EmployeeID,@employeeName=EmployeeName,@deptID=DeptID,@classID=ClassID,
		@classShortName=ClassShortName,@beginWorkTime=BeginWorkTime,@DataAttendance=DataAttendance,@TimerIntervalID=TimerIntervalID from RealTimeAttendance where blockid=@blockid
	
	insert into HistoryAttendance(BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime,EndWorkTime,WorkTime,DataAttendance,TimerIntervalID) 
	values(@blockid,@employeeid,@employeeName,@deptID,@classID,@classShortName,@beginWorkTime,@OutWorkTime,datediff (minute,@beginWorkTime,@OutWorkTime),@DataAttendance,@TimerIntervalID)

	delete from RealTimeAttendance where blockid=@blockid 




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




/****** Object:  Stored Procedure dbo.proc_insert_RealTimeAttendance    Script Date: 2007-6-13 15:33:45 ******/




CREATE proc proc_insert_RealTimeAttendance
@blockid int,  --卡号
@InWorkTime datetime --进入上班时间
as
declare @employeeID int --员工号
declare @employeeName varchar(50) --员工姓名
declare @deptid int --部门号
declare @classid int --班次号
declare @classShortName varchar(20) --时段简称
declare @StartWorkTime smalldatetime  --上班时间
declare @SWFrontTime int --提前考勤时间（分）
declare @flag bit --是否是正常考勤标志位 0为非正常  1为正常
set @flag=0
declare @count int --该人员是否有班次信息
if exists (select * from tempdb.dbo.sysobjects where id = object_id(N'[tempdb].[dbo].[#temp1]'))
begin
	drop table #temp1
end
select * into #temp1 from Shine_Shen_AttendanceClass where BlockID=@blockid--查询某个员工的所有班次
select @count=count(*) from #temp1
if(@count>0)
begin
	declare csr_class cursor for select employeeid,employeename,deptid,classid,classshorname,StartWorkTime,WFrontTime from #temp1--查询某个员工的所有班次
	open csr_class
	fetch next from csr_class into @employeeID,@employeeName,@deptid,@classid,@classShortName,@StartWorkTime,@SWFrontTime
	while(@@fetch_status=0)
		begin
			if(@flag=0)
			begin
				declare @timeDiff int
				set @timeDiff=datediff(minute,
					convert(varchar(2),DATEPART(hh,@InWorkTime))+':'+convert(varchar(2),DATEPART(mi,@InWorkTime))+':'+convert(varchar(2),DATEPART(ss,@InWorkTime)),
					convert(varchar(2),DATEPART(hh,@StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,@StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,@StartWorkTime)))
				if(@timeDiff<0)--判断获取的时间差是否为负数
				begin
					set @timeDiff=2400-@timeDiff
				end
				if(@timeDiff<=@SWFrontTime)--判断时间差不大于提前多长时间考勤
				begin
					set @flag=1
					insert into RealTimeAttendance(BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime) 
					values(@blockid,@employeeID,@employeeName,@deptid,@classid,@classShortName,@InWorkTime)
					--正常考勤存入到实时考勤表中
				end
			end
			fetch next from csr_class into @employeeID,@employeeName,@deptid,@classid,@classShortName,@StartWorkTime,@SWFrontTime
		end
	close csr_class
	deallocate csr_class
	if(@flag=0)--非正常的
	begin
		--添加到非正常表中
		select distinct @employeeID=employeeid,@employeeName=employeename,@deptid=deptid from #temp1
		insert into RealTimeAttendanceError(BlockID,EmployeeID,EmployeeName,DeptID,BeginWorkTime) 
					values(@blockid,@employeeID,@employeeName,@deptid,@InWorkTime)
	end
end
if exists (select * from tempdb.dbo.sysobjects where id = object_id(N'[tempdb].[dbo].[#temp1]'))
begin
	drop table #temp1
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO




/****** Object:  Stored Procedure dbo.proc_insert_RealTimeAttendance_cjg    Script Date: 2007-6-13 15:33:45 ******/




CREATE          proc [dbo].[proc_insert_RealTimeAttendance_cjg]
@blockid int,  --卡号
@InWorkTime datetime --进入上班时间
as
declare @employeeID int --员工号
declare @employeeName varchar(50) --员工姓名
declare @deptid int --部门号
declare @classid int --班次号
declare @classShortName varchar(20) --时段简称
declare @TimerIntervalID int --时段流水
declare @StartWorkTime datetime  --上班时间
declare @EndWorkTime datetime --下班时间
declare @SWFrontTime int --提前考勤时间（分）
declare @SWAfterTime int --滞后考勤时间（分）
declare @SWDateType int	--是否为前一天考勤
declare @flag bit --是否是正常考勤标志位 0为非正常  1为正常
set @flag=0
declare @count int --该人员是否有班次信息
declare @count1 int --该人员是否在实时班次表中
declare @DataAttendanceType int --记工日期标志 －1为前一日 0为排班日 1为后一日 

if exists (select * from tempdb.dbo.sysobjects where id = object_id(N'[tempdb].[dbo].[#temp1]'))
begin
	drop table #temp1
end
select * into #temp1 from Shine_Shen_AttendanceClass where BlockID=@blockid--查询某个员工的所有班次
select @count=count(*) from #temp1 
select @count1=count(*) from RealTimeAttendance where BlockID=@blockid
if(@count>0)
begin
	declare csr_class cursor for select UserID,UserName,deptid,classid,NameShort,StartWorkTime,EndWorkTime,SWFrontTime,SWAfterTime,SWDateType,TimerIntervalID,DataAttendanceType from #temp1--查询某
	open csr_class
	fetch next from csr_class into @employeeID,@employeeName,@deptid,@classid,@classShortName,@StartWorkTime,@EndWorkTime,@SWFrontTime,@SWAfterTime,@SWDateType,@TimerIntervalID,@DataAttendanceType  
	while(@@fetch_status=0)
	begin
		
		declare @timeDiffBegin int --考勤提前时间
		declare @timeDiffEnd int
		declare @DataAttendance datetime
		set @DataAttendance=convert(datetime,(convert(varchar(4),DATEPART(yyyy,@InWorkTime))+'-'+convert(varchar(2),DATEPART(mm,@InWorkTime))+'-'+convert(varchar(2),DATEPART(dd,@InWorkTime))))
		if(@DataAttendanceType =-1)
		begin
			set @DataAttendance = dateadd(day,-1,@DataAttendance)
		end
		if(@DataAttendanceType = 1)
		begin
			set @DataAttendance = dateadd(day,1,@DataAttendance)
		end
		if(datediff(minute,
				convert(varchar(2),DATEPART(hh,@StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,@StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,@StartWorkTime)),
				convert(varchar(2),DATEPART(hh,@EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,@EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,@EndWorkTime)))>0)
			begin
				set @timeDiffBegin=datediff(minute,
					convert(varchar(2),DATEPART(hh,@InWorkTime))+':'+convert(varchar(2),DATEPART(mi,@InWorkTime))+':'+convert(varchar(2),DATEPART(ss,@InWorkTime)),
					convert(varchar(2),DATEPART(hh,@StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,@StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,@StartWorkTime)))
				set @timeDiffEnd=datediff(minute,
					convert(varchar(2),DATEPART(hh,@InWorkTime))+':'+convert(varchar(2),DATEPART(mi,@InWorkTime))+':'+convert(varchar(2),DATEPART(ss,@InWorkTime)),
					convert(varchar(2),DATEPART(hh,@EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,@EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,@EndWorkTime)))
				
				if(@timeDiffBegin<=0 and @timeDiffEnd>=0)--判断时间差不大于提前多长时间考勤
				begin--正常考勤存入到实时考勤表中
					set @flag=1
					if(@count1<=0)
					begin
						delete RealTimeAttendance where BlockID= @blockid 
						insert into RealTimeAttendance(BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime,DataAttendance,TimerIntervalID) 
						values(@blockid,@employeeID,@employeeName,@deptid,@classid,@classShortName,@InWorkTime,@DataAttendance,@TimerIntervalID)
					end
					else
					begin
						set @flag=1
						update RealTimeAttendance
						set EmployeeID=@employeeID,
							EmployeeName=@employeeName,
							DeptID=@deptid,
							ClassID=@classid,
							ClassShortName=@classShortName,
							BeginWorkTime=@InWorkTime,
							DataAttendance=@DataAttendance,
							TimerIntervalID = @TimerIntervalID 
						where BlockID=@blockid
					end
				end
			end
		if(datediff(minute,
				convert(varchar(2),DATEPART(hh,@StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,@StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,@StartWorkTime)),
				convert(varchar(2),DATEPART(hh,@EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,@EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,@EndWorkTime)))<0)
			begin
				set @timeDiffBegin=datediff(minute,
					convert(varchar(2),DATEPART(hh,@InWorkTime))+':'+convert(varchar(2),DATEPART(mi,@InWorkTime))+':'+convert(varchar(2),DATEPART(ss,@InWorkTime)),
					convert(varchar(2),DATEPART(hh,@StartWorkTime))+':'+convert(varchar(2),DATEPART(mi,@StartWorkTime))+':'+convert(varchar(2),DATEPART(ss,@StartWorkTime)))
				set @timeDiffEnd=datediff(minute,
					convert(varchar(2),DATEPART(hh,@InWorkTime))+':'+convert(varchar(2),DATEPART(mi,@InWorkTime))+':'+convert(varchar(2),DATEPART(ss,@InWorkTime)),
					convert(varchar(2),DATEPART(hh,@EndWorkTime))+':'+convert(varchar(2),DATEPART(mi,@EndWorkTime))+':'+convert(varchar(2),DATEPART(ss,@EndWorkTime)))
				if((@timeDiffBegin<=0 and @timeDiffEnd<=0) or (@timeDiffBegin>=0 and @timeDiffEnd>=0))
				begin
					if(@count1<=0)
						begin
							set @flag=1
							delete RealTimeAttendance where BlockID= @blockid 
							insert into RealTimeAttendance(BlockID,EmployeeID,EmployeeName,DeptID,ClassID,ClassShortName,BeginWorkTime,DataAttendance,TimerIntervalID) 
							values(@blockid,@employeeID,@employeeName,@deptid,@classid,@classShortName,@InWorkTime,@DataAttendance,@TimerIntervalID)
						end
						else
						begin
							set @flag=1
							update RealTimeAttendance
							set EmployeeID=@employeeID,
								EmployeeName=@employeeName,
								DeptID=@deptid,
								ClassID=@classid,
								ClassShortName=@classShortName,
								BeginWorkTime=@InWorkTime,
								DataAttendance=@DataAttendance,
								TimerIntervalID = @TimerIntervalID 
							where BlockID=@blockid
						end
				end
			end
		fetch next from csr_class into @employeeID,@employeeName,@deptid,@classid,@classShortName,@StartWorkTime,@EndWorkTime,@SWFrontTime,@SWAfterTime,@SWDateType,@TimerIntervalID,@DataAttendanceType  
	end
	close csr_class
	deallocate csr_class
	if(@flag=0)--非正常的
	begin
		--添加到非正常表中
		print 'ss'
		select distinct @employeeID=userid,@employeeName=username,@deptid=deptid from #temp1
		insert into RealTimeAttendanceError(BlockID,EmployeeID,EmployeeName,DeptID,BeginWorkTime) 
					values(@blockid,@employeeID,@employeeName,@deptid,@InWorkTime)
	end
end
if exists (select * from tempdb.dbo.sysobjects where id = object_id(N'[tempdb].[dbo].[#temp1]'))
begin
	drop table #temp1
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO






CREATE       proc proc_insert_emp_txj
(
  @EmpName nvarchar(20),
  @EmpNo nvarchar(10),
  @Sex bit,
  @Remark nvarchar(200),
@depid int,
@smax1 int,
@smax2 int,
@qyms int,
@idcards nvarchar(18),
@DutyID int
)
As

declare @string varchar(10)
declare @yi int
declare @ling int
declare @riqi datetime
declare @kong datetime
set @kong=null
set @string=''
set @yi=1
set @ling=0
set @riqi=1800-01-01
BEGIN TRANSACTION

exec KJ128N_Emp_Info_Insert @EmpName,@EmpNo,@Sex,@Remark
exec KJ128N_Emp_Detail_InsertAndUpDate  @EmpNo,@string,@ling,@ling,@string,@string,@ling,@string,@string,@string,@string,@kong,@idcards
exec KJ128N_Emp_Search_InsertAndUpDate @EmpNo,@string,@string,@string,@string,@string,@string,@string,@string,@string
exec KJ128N_Emp_Health_InsertAndUpDate @EmpNo,@ling,@ling,@string
exec KJ128N_Emp_Home_InsertAndUpDate  @EmpNo,@string,@string,@string,@string,@string

exec KJ128N_Emp_InCompany_InsertAndUpDate  @EmpNo,@kong,@kong,@kong,@kong,@ling,@ling,@string,@kong,@string

exec KJ128N_Emp_NowCompany_InsertAndUpDate @EmpNo,@depid,@DutyID,@smax1,@smax2,1,@string,@string,@string

COMMIT



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO





CREATE      proc proc_insert_txj
(
  @ParentDeptID int,
  @DeptLevelID int,
  @DeptNO nvarchar(20),
  @DeptName nvarchar(20),
  @Remark nvarchar(200),
  @ClassID int,
  @SerialNo int
)
As

declare @string varchar(10)
declare @yi int
declare @ling int

declare @max int
declare @min int

declare @riqi datetime
set @string=""
set @yi=1
set @ling=0
set @max=36000
set @min=0
set @riqi=1800-01-01
BEGIN TRANSACTION

exec KJ128N_Dept_Info_Insert @ParentDeptID,@DeptLevelID,@DeptNO,@DeptName,@Remark,@ClassID,@SerialNo
 exec KJ128N_Dept_Detail_InsertAndUpdate @DeptNO,@string,@string,@string,@string,@string,@string

exec KJ128N_Emp_SysSet_Insert @DeptNO,@max,@min
--exec KJ128N_Dept_Lead_Insert @DeptNO,@ling,@riqi

COMMIT

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE         proc proc_select_emp_by_txj
(
  
  @depid int
 
)
As
if @depid=0
	SELECT EmpName, EmpID, EmpNO FROM dbo.Emp_Info
else
SELECT dbo.Emp_Info.EmpName, dbo.Emp_Info.EmpID, dbo.Dept_Info.DeptID
FROM dbo.Emp_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID  where   dbo.Dept_Info.DeptID=@depid

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS OFF 
GO





CREATE proc proc_select_his_station_head_time_txj
@kssj varchar(20),
@jssj varchar(20),
@ksjz varchar(20),
@kstt varchar(20),
@jsjz varchar(20),
@jstt varchar(20),
@depid varchar(20),
@name varchar(20)

as
begin
if(@depid='0' and @name='0')
begin
select    userid,username,instationheadtime,outstationheadtime,stationaddress,stationheadaddress,
stationplace,StationHeadPlace,deptname,deptno,CodeSenderAddress from kj128_his_station_head_time_view_txj
where 
convert(varchar(20),instationheadtime,120)>@kssj  and convert(varchar(20),instationheadtime,120)<@jssj
and (stationaddress=@ksjz and stationheadaddress=@kstt  or  stationaddress=@jsjz and stationheadaddress=@jstt)
order by userid,instationheadtime,outstationheadtime
end
else if(@depid!='0' and @name='0')
begin
select    userid,username,instationheadtime,outstationheadtime,stationaddress,stationheadaddress,
stationplace,StationHeadPlace,deptname,deptno,CodeSenderAddress,deptid  from kj128_his_station_head_time_view_txj
where 
convert(varchar(20),instationheadtime,120)>@kssj  and convert(varchar(20),instationheadtime,120)<@jssj
and (stationaddress=@ksjz and stationheadaddress=@kstt  or  stationaddress=@jsjz and stationheadaddress=@jstt)
and @depid=deptid
order by userid,instationheadtime,outstationheadtime
end
else if(@depid='0' and @name!='0')
begin
select    userid,username,instationheadtime,outstationheadtime,stationaddress,stationheadaddress,
stationplace,StationHeadPlace,deptname,deptno,CodeSenderAddress  from kj128_his_station_head_time_view_txj
where 
convert(varchar(20),instationheadtime,120)>@kssj  and convert(varchar(20),instationheadtime,120)<@jssj
and (stationaddress=@ksjz and stationheadaddress=@kstt  or  stationaddress=@jsjz and stationheadaddress=@jstt)
and username like'%'+@name+'%'
order by userid,instationheadtime,outstationheadtime
end
else
begin
select    userid,username,instationheadtime,outstationheadtime,stationaddress,stationheadaddress,
stationplace,StationHeadPlace,deptname,deptno,CodeSenderAddress,deptid  from kj128_his_station_head_time_view_txj
where 
convert(varchar(20),instationheadtime,120)>@kssj  and convert(varchar(20),instationheadtime,120)<@jssj
and (stationaddress=@ksjz and stationheadaddress=@kstt  or  stationaddress=@jsjz and stationheadaddress=@jstt)
and @depid=deptid and username like'%'+@name+'%'
order by userid,instationheadtime,outstationheadtime
end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE  procedure [dbo].[process_EmpHelpInfo] 
@DetecTime datetime, --检测时间
@StationAddress int, --分站地址
@StationHeadAddress int, --探头地址
@HeadA bit,-- 天线 A
@HeadB bit,--天线B
@Cards varchar(6000) --一串卡号
as
--开始事务
begin transaction EmpHelpInfotrans
declare @CRADNO varchar(20)--发码器编号,对应了人的编号
declare @count int
declare @measure nvarchar(200)
declare @EmpID int

if (@HeadA =1 and @HeadB=1)
begin
	--定义游标
	declare processEmpHelpInfo cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open processEmpHelpInfo
	--移到下一行
	fetch next from processEmpHelpInfo into @CRADNO

	while (@@FETCH_STATUS <> -1)
	begin
		
		if @CRADNO<>''
			begin
				--查找此@CRADNO对应的人的编号
				
				set @EmpID = (select UserID from CodeSender_Set where CodeSenderAddress=@CRADNO and CsTypeId=0)
				if @EmpID is not null
				begin
					print  cast(@EmpID as nvarchar(20))+'求救'
					
					set @count = (select count(EmpID) from RT_EmpHelp where EmpID =@EmpID )

					print cast(@EmpID as nvarchar(20))+'求救条数'+cast(@count as nvarchar(20))
					
					--内容
					set @measure = (select Title from EnumTable where FunID= 47 and EnumID=1)
					if @measure=''
					begin
						set @measure = '无内容'
					end 
					else
					begin
						set @measure = '内容'
					end

					if (@count=0)
					begin
						print cast(@EmpID as nvarchar(20))+'求救信息为0；插入操作'
						
						insert into RT_EmpHelp(CodeSenderAddress,StationAddress,StationHeadAddress,EmpID,BeginDateTime,Measure)
						values(@CRADNO,@StationAddress,@StationHeadAddress,@EmpID,@DetecTime,@measure) 
						
					end

					else
					begin
						print cast(@EmpID as nvarchar(20))+'求救信息不为0；更新操作'
						
						update RT_EmpHelp set CodeSenderAddress=@CRADNO 
						, StationAddress=@StationAddress
						, StationHeadAddress=@StationHeadAddress
						, EmpID=@EmpID
						, BeginDateTime=@DetecTime
						where EmpID = @EmpID
					end
				end		
			end
		
		fetch next from processEmpHelpInfo into @CRADNO
	end

	--关闭游标
	close processEmpHelpInfo
	--释放游标
	deallocate processEmpHelpInfo
end


if @@error=0
begin
	commit transaction EmpHelpInfotrans
end

else
begin
	rollback transaction EmpHelpInfotrans
end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--下井巡检信息处理
CREATE   procedure [dbo].[process_InCheck]
@EmpID int,
@Currenttime datetime
as
--排班ID
declare @Interval int
declare @count int
declare @EmpName varchar(20)
--declare @ctime datetime
--declare @btime datetime
--declare @etime datetime
--declare @Test varchar(3000)
	set @EmpName = (select EmpName from Emp_Info where EmpID=@EmpID)
	print '查询'+@EmpName+'班次，时间是：'+ cast(@Currenttime as varchar(20))
	set @count = (select count(1) from  RealTimePathCheck where EmpID=@EmpID)
	print @EmpName+'的实时巡检信息条数'+cast(@count as varchar(20))
	--实时表查不到信息，插入信息
	if @count=0
	begin
		select @Interval=TimerIntervalID from dbo.Shine_Shen_AttendanceClass 
where 
(datediff(second,StartWorkTime,Convert(datetime,'1900-01-01 '+substring(Convert(varchar(20),@Currenttime,120),12,8)))>0 
and 
datediff(second,Convert(datetime,'1900-01-01 '+substring(Convert(varchar(20),@Currenttime,120),12,8)),EndWorkTime)>0)
and UserName=@EmpName

		print '此人的班次为：'+cast(@Interval as varchar(10))

		exec insert_RealTimePathCheck @EmpID,@Interval,@Currenttime
		print @EmpName+'的班次信息插入'
	end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO






--巡检上井信息处理

CREATE     procedure [dbo].[process_OutCheck]

--@EmpID varchar(20),
@cardID int,

@Currenttime datetime
as

declare @EmpID int
declare @count int

set @EmpID = (select ei.EmpID from CodeSender_Set cs 
		join Emp_Info ei on cs.UserID=ei.EmpID and cs.CsTypeId=0
		where cs.CodeSenderAddress=@cardID)

if @EmpID>0

begin

/*
查看RealTimePathCheck表中是否有数据，
如果有，则向HisPathCheck表写入信息，删除RealTimePathCheck表中的信息
*/
	set @count = (select count(1) from RealTimePathCheck where EmpID=@EmpID)
	if @count<>0
	begin
	--写入历史
	declare @Interval int 
	set @Interval = (select Interval from RealTimePathCheck where EmpID=@EmpID)

	declare @CheckTime datetime 
	set @CheckTime = (select CheckTime from RealTimePathCheck  where EmpID=@EmpID)

	--insert into HisPathCheck(EmpID,Interval,CheckBeginTime,CheckEndTime) select r.EmpID,r.Interval,r.CheckTime,@Currenttime from RealTimePathCheck r where EmpID=@EmpID

	exec insert_HisPathCheck @EmpID,@Interval,@CheckTime,@Currenttime

	--删除实时
	print 'aaa'
	delete RealTimePathCheck where EmpID=@EmpID
	end
end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE     procedure [dbo].[process_RealTimeAlarmPathInfo] 
@DetecTime datetime, --检测时间
@StationAddress int, --分站地址
@StationHeadAddress int, --探头地址
@Cards varchar(6000) --一串卡号
as
--开始事务
begin transaction AlarmPathInfotrans
declare @CRADNO varchar(20)--发码器编号,对应了人的编号
declare @isIn int -- 0表示不在
--declare @PathNo varchar(20) --路线编号
declare @sA int --走过的分站地址
declare @shA int -- 走过的探测器地址
declare @stationType int --基站类型


set @stationType =(select StationHeadTypeID from Station_Head_Info 
	where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress)

print '基站类型为'+ cast(@stationType as varchar(10))

if (@stationType=32)
begin

begin
	--定义游标
	declare processPathInfo cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open processPathInfo
	--移到下一行
	fetch next from processPathInfo into @CRADNO
	while (@@FETCH_STATUS <> -1)
	begin
		if @CRADNO<>''
			begin
				--查看此人是否路线报警了

				--查找此@CRADNO对应的人的编号
				declare @EmpID int
				set @EmpID = (select UserID from CodeSender_Set  
								where CodeSenderAddress=@CRADNO and CsTypeId=0)
				if @EmpID<>''
				begin
                    declare @pathcount int 
					set @pathcount = (select count(PathNo) from Path_Emp_Relation where EmpID = @EmpID)
					if @pathcount<>0
					begin
						--此人配了路线情况下，插入当前路过的探测器信息到路过探测器信息表中
						exec insert_passStationHead @CRADNO,@StationAddress,@StationHeadAddress

						--此人配了路线情况下，向实时巡检信息表中插入巡检信息
						exec process_InCheck @EmpID,@DetecTime 
	
						declare @count int	
						declare @string varchar(1000)
						set @string = ''
						--到此人今天走过的路线中找出走过的探测器信息，构造成字符串
						declare processPathString cursor for (select StationAddress,StationHeadAddress from passStationHead where EmpID = @EmpID)
						--打开游标
						open processPathString
						--移到下一行
						fetch next from processPathString into @sA,@shA
						while (@@FETCH_STATUS <> -1)
						begin
								
							set @string = @string + cast(@sA as varchar(10))+'-'+cast(@shA as varchar(10))+','
								
							
							fetch next from processPathString into @sA,@shA	
						end
						

						--关闭游标
						close processPathString
						--释放游标
						deallocate processPathString		
				
						--上面构造出的走过的路线字符串，和配置的路线字符串进行匹配，如果
						--匹配不到路线，证明走偏了，或没按配置的路线点走，则报警
						print @string
						set @count = (select count(1) from pathString where PathString like @string+'%' )
						--查到不在规定的路线中，路线报警
						if @count=0
						begin
							declare @countA int
							set @countA = (select count(1) from RealTimeAlarmPathInfo where EmpID= @EmpID )
							if @countA=0
							begin
								exec insert_RealTimeAlarmPathInfo 
										@EmpID,@StationAddress,@StationHeadAddress,@DetecTime
							end
						end
					end
				end	
			end			
		fetch next from processPathInfo into @CRADNO
	end

	--关闭游标
	close processPathInfo
	--释放游标
	deallocate processPathInfo
end

end

if @@error=0
begin
	commit transaction AlarmPathInfotrans
end

else
begin
	rollback transaction AlarmPathInfotrans
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--行走异常
CREATE  procedure [dbo].[process_WalkLogic]
@DetecTime datetime, --检测时间
@StationAddress int, --分站地址
@StationHeadAddress int, --探头地址
@HeadA bit,-- 天线 A
@HeadB bit,--天线B
@Cards varchar(6000) --一串卡号
as
--开始事务
begin transaction Walktrans

--发码器编号,对应了人的编号
declare @CRADNO varchar(20)
declare @count int
declare @measure nvarchar(200)
declare @EmpID int
declare @TimeValue int

	--定义游标
	declare processWalk cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open processWalk
	--移到下一行
	fetch next from processWalk into @CRADNO

	while (@@FETCH_STATUS <> -1)
	begin
		
		if @CRADNO<>''
			begin
				--查找此@CRADNO对应的人的编号
				set @EmpID = (select UserID from CodeSender_Set where CodeSenderAddress=@CRADNO and CsTypeId=0)
				if @EmpID is not null
				begin

					--在此人配置了信息的情况下

					if(exists(select * from WalkConfigInfo where EmpID = @EmpID ))
					begin

						--1--判断实时表中是否有A点，如果没有，插入实时表

						if(((select FirstArriveTime from RealTimeWalkInfo 
										where EmpID = @EmpID)is null) and 
						((select count(1) from WalkConfigInfo where 
							FirstStationAddress=@StationAddress 
							and FirstStationHeadAddress =@StationHeadAddress 
							and FirstStationHeadAntennaA=@HeadA 
							and FirstStationHeadAntennaB=@HeadB and EmpID = @EmpID)>0 ))
						begin
						
						insert into RealTimeWalkInfo (EmpID,FirstStationAddress,FirstStationHeadAddress,FirstStationHeadAntennaA,FirstStationHeadAntennaB,
														FirstArriveTime,IsAlarm)
													values(@EmpID,@StationAddress,@StationHeadAddress,@HeadA,@HeadB,@DetecTime,0)
						
						end

						--2--判断实时表中是否有B，如果没有，再判断A是否存在，如果A存在，插入B点
						if(((select MiddleArriveTime from RealTimeWalkInfo 
											where EmpID = @EmpID )is null) and 
						((select count(1) from WalkConfigInfo where 
							MiddleStationAddress=@StationAddress 
							and MiddleStationHeadAddress =@StationHeadAddress 
							and MiddleStationHeadAntennaA=@HeadA 
							and MiddleStationHeadAntennaB=@HeadB and EmpID = @EmpID)>0 ))

						begin
--							if((select FirstArriveTime from RealTimeWalkInfo 
--											where EmpID = @EmpID )<>'')
--							begin
							
							update RealTimeWalkInfo set MiddleStationAddress = @StationAddress , MiddleStationHeadAddress=@StationHeadAddress
														,MiddleStationHeadAntennaA=@HeadA ,MiddleStationHeadAntennaB=@HeadB, MiddleArriveTime = @DetecTime where EmpID = @EmpID
--							end
						end
						
					
						--3--判断实时表中是否有C,如果没有，再判断A是否存在，如果A存在，插入C点，判断超时
						if(((select LastArriveTime from RealTimeWalkInfo 
											where EmpID = @EmpID )is null) and 
						((select count(1) from WalkConfigInfo where 
							LastStationAddress=@StationAddress 
							and LastStationHeadAddress =@StationHeadAddress 
							and LastStationHeadAntennaA=@HeadA 
							and LastStationHeadAntennaB=@HeadB and EmpID = @EmpID)>0))

						begin
							if((select FirstArriveTime from RealTimeWalkInfo 
											where EmpID = @EmpID )is not null)
							begin
							
							update RealTimeWalkInfo set LastStationAddress=@StationAddress,LastStationHeadAddress=@StationHeadAddress,
															LastStationHeadAntennaA=@HeadA ,LastStationHeadAntennaB=@HeadB,LastArriveTime=@DetecTime where EmpID = @EmpID
														
							--判断 是否报警

							set @TimeValue = (select TimeValue from WalkConfigInfo where EmpID = @EmpID)
							
							declare @tmpTimeValue int 
							set @tmpTimeValue = datediff(second,(select FirstArriveTime from RealTimeWalkInfo where EmpID = @EmpID),@DetecTime)
							--行走超时
							if (@tmpTimeValue>@TimeValue)
							begin

							 update RealTimeWalkInfo set IsAlarm = 1 where EmpID = @EmpID

							end
							
							end
						end

						--4--判断实时表中是否有A和B并且无C,拿当前时间和A点时间比对判断超时
						
						if(((select FirstArriveTime from RealTimeWalkInfo where EmpID = @EmpID) is not null) 
							and ((select MiddleArriveTime from RealTimeWalkInfo where EmpID = @EmpID) is not null)
							and ((select LastArriveTime from RealTimeWalkInfo where EmpID = @EmpID) is null))
						begin
							

							--判断 是否报警

							set @TimeValue = (select TimeValue from WalkConfigInfo where EmpID = @EmpID)
							
							declare @tmpTimeValueC int 
							set @tmpTimeValue = datediff(second,(select FirstArriveTime from RealTimeWalkInfo where EmpID = @EmpID),@DetecTime)
							--行走超时
							if (@tmpTimeValueC>@TimeValue)
							begin

							 update RealTimeWalkInfo set IsAlarm = 1 where EmpID = @EmpID

							end

							--print 'Lile'
						end
						--print 'Over'
					end	
				end		
			end
		
		fetch next from processWalk into @CRADNO
	end

	--关闭游标
	close processWalk
	--释放游标
	deallocate processWalk


if @@error=0
begin
	commit transaction Walktrans
end

else
begin
	rollback transaction Walktrans
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--工作异常上井处理
CREATE procedure processupinfo
@cardNo int,--卡号
@time datetime--检测时间
as
--根据卡号删除路线字符
exec delete_pathStringByCardNO @cardNo
--根据卡号删除经过的探测器信息
exec delete_passStationHeadByCardNO @cardNo
--查看是否要记录历史
exec deleteRealWriteToHisAlert @cardNo,@time

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--获地域的名称信息
CREATE procedure selectClimeInfo
as
select TerritorialID,TerritorialName from Territorial_Info
where TerritorialTypeID=(select TerritorialTypeID from Territorial_Type where TypeName='地域')
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--获取限制区域的区域名称信息
CREATE procedure [dbo].[selectConfineAreaInfo]
as
select TerritorialID,TerritorialName from Territorial_Info
where TerritorialTypeID=(select TerritorialTypeID from Territorial_Type where TypeName='限制区域')
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--2008-07-11 

--查询一段时间内员工的状态
create procedure selectEmpStateByTime
@beginTime datetime,
@endTime datetime
as
--分3钟情况，时间在1-4之间

/*第一种情况*/
--4点前上井（在历史表里面查询）

select hiom.CodeSenderAddress as 标示卡编号,hiom.UserName as 人员姓名,hiom.InTime as 下井时间,
hiom.OutTime as 上井时间,hiom.ContinueTime as 井下工作时间, hiosh.StationHeadPlace as 所在位置,
hiosh.InStationHeadTime as 进入时间,hr.InDirection as 进入方向,
hiosh.OutStationHeadTime as 离开时间,hr.OutDirection as 离开方向,
datediff(minute,hiosh.InStationHeadTime,hiosh.OutStationHeadTime) as 停留时间

from His_InOutMine as hiom
left join His_InOutStationHead as hiosh on hiom.UserName = hiosh.UserName
--下面还要关联方向表
left join His_InOutReceiver hr on hiom.CodeSenderAddress = hr.CodeSenderAddress 
and hiosh.StationAddress = hr.Station and hiosh.StationHeadAddress = hr.StationHead

where  hiom.InTime<=@beginTime and hiom.OutTime<=@endTime


union all

/*第二种情况*/
--1-4点下井，4点后上进(到实时表里面查询)

select rtiom.CodeSenderAddress as 标示卡编号,ei.EmpName as 人员姓名,rtiom.InTime as 下井时间,
null as 上井时间,datediff(minute,rtiom.InTime,getdate()) as 井下工作时间, shi.StationHeadPlace as 所在位置,
rtiosh.InStationHeadTime as 进入时间,cd.Directional as 进入方向,
null as 离开时间,null as 离开方向,
datediff(minute,rtiosh.InStationHeadTime,getdate()) as 停留时间
from RT_InOutMine as rtiom

left join CodeSender_Set as css on rtiom.CodeSenderAddress = css.CodeSenderAddress
left join Emp_Info as ei on css.UserID=ei.EmpID 

left join RT_InStationHeadInfo as rtiosh on rtiom.CodeSenderAddress = rtiosh.CodeSenderAddress 
left join Station_Head_Info as shi on rtiosh.StationHeadID = shi.StationHeadID 

--下面还要关联方向表
left join RT_DirectionalAntenna as rtda on rtiom.CodeSenderAddress = rtda.CodeSenderAddress 
and shi.StationAddress = rtda.Station and shi.StationHeadAddress = rtda.Antenna
left join CodeSender_Directional cd on cd.CodeSenderDirlID= rtda.CodeSenderDirlID

where rtiom.InTime>=@beginTime

union all

/*第三种情况*/
--1-4点完成上下井的

select hiom.CodeSenderAddress as 标示卡编号,hiom.UserName as 人员姓名,hiom.InTime as 下井时间,
hiom.OutTime as 上井时间,hiom.ContinueTime as 井下工作时间, hiosh.StationHeadPlace as 所在位置,
hiosh.InStationHeadTime as 进入时间,hr.InDirection as 进入方向,
hiosh.OutStationHeadTime as 离开时间,hr.OutDirection as 离开方向,
datediff(minute,hiosh.InStationHeadTime,hiosh.OutStationHeadTime) as 停留时间

from His_InOutMine as hiom
left join His_InOutStationHead as hiosh on hiom.UserName = hiosh.UserName 

--下面还要关联方向表
left join His_InOutReceiver hr on hiom.CodeSenderAddress = hr.CodeSenderAddress 
and hiosh.StationAddress = hr.Station and hiosh.StationHeadAddress = hr.StationHead

where hiom.InTime>=@beginTime and hiom.OutTime<=@endTime
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--获取重点区域的区域名称信息
CREATE procedure selectKeyAreaInfo
as
select TerritorialID,TerritorialName from Territorial_Info
where TerritorialTypeID=(select TerritorialTypeID from Territorial_Type where TypeName='重点区域')


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--查询实时岗位异常信息存储过程(执行过)
CREATE  procedure selectRealTimePostInfo
@condition varchar(1000)
as
declare @sqlstr  varchar(1000)

set @sqlstr = 'select * from View_SelectRealTimePostInfo'

if ((@condition is null) or (@condition = ''))
begin
	exec(@sqlstr)
end
else
begin
	set @sqlstr = @sqlstr + ' where ' + @condition
	exec(@sqlstr)
end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



CREATE   procedure selectStationConfigInfo
(
@selectModel int,
@strWhere nvarchar(1000) 
)
as
begin
declare @strSql varchar(4000) 

if(@selectModel=0)
begin
	Set @strSql='select StationAddress as 传输分站编号,StationPlace as 安装位置,StationGroup as 分组编号,
		(select Title from EnumTable where FunID=7 and Station_Info.StationState=EnumTable.EnumValue) as 分站状态,
		传输协议 = case StationModel when 1 then ''A版协议'' when 2 then ''V2版协议'' end  ,StationTel as 联系电话 
		from dbo.Station_Info Where' + @strWhere
end
else 
begin
	Set @strSql=' Select * From A_StationHeadState Where '+@strWhere
end

exec (@strSql)

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create   proc selectUserGrupByAccountID
@account varchar(20) 
AS
select menuid,isuse ,m.name from UserGroupMenu1 u 
left join menus1 m on u.menuid = m.id 
left join  usergroups users on u.usergroupid =users.id  
left join admins a  on a.usergroupid = users.[id]
 where a.account =@account



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create  proc selectUserGrupByAdminID
@account varchar(20) 
AS
select menuid,isuse from UserGroupMenu1 u 
left join menus1 m on u.menuid = m.id 
left join  usergroups users on u.usergroupid =users.id  
left join admins a  on a.usergroupid = users.[id]
 where a.account =@account


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create   proc selectUserGrupByUserGroupID
@UserGroupID int 
AS

select m.menuid,m.isuse , m1.name from UserGroupMenu1 m left join menus1 M1  ON M.menuid = m1.id where @UserGroupID =UserGroupID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




create  proc selectUserGrupBymenuID
@menuid int 
AS

select m.menuid,m.isuse , m1.name from UserGroupMenu1 m left join menus1 M1  ON M.menuid = m1.id where @menuid =menuid




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




--查找部门
create procedure select_Dept_Info
as
select DeptId,DeptName from dbo.Dept_Info



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查找实时信息里员工走过的探测器
CREATE procedure [dbo].[select_EmpPassInfo]
@EmpID int,
--开始下井时间
@BeginTime datetime 
as
select His.StationAddress as 分站编号, si.StationPlace as 分站安装位置, 
His.StationHeadAddress as 接收器编号, shi.StationHeadPlace as  接收器安装位置,
His.InStationHeadTime as 进入接收器时间, His.OutStationHeadTime as 离开接收器时间
from His_InOutStationHead as His
left join Emp_Info as Ei on His.UserID=Ei.EmpID and His.CsTypeID=0
left join Station_Info si on His.StationAddress = si.StationAddress
left join Station_Head_Info shi on His.StationHeadAddress = shi.StationHeadAddress 
and His.StationAddress = shi.StationAddress
where Ei.EmpID=@EmpID and InStationHeadTime>=@BeginTime
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--根据部门查找人员信息
create procedure select_Emp_Info
@DeptId int
as
select ei.EmpId,ei.EmpNo,ei.EmpName from Emp_Info ei
left join Emp_NowCompany en on en.EmpId=ei.EmpId
where en.DeptId=@DeptId



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询历史信息
CREATE procedure [dbo].[select_HisPathCheckByInterval]
--查询条件
@Interval int
as
select h.ID,
h.EmpName as 姓名,t.IntervalName as 班次,h.CheckBeginTime as 巡检开始时间,
h.CheckEndTime as 巡检结束时间,p.PathNo as 路线编号
from HisPathCheck h
left join Path_Emp_Relation p on h.EmpID=p.EmpID
join Path_Info po on p.pathNo = po.pathNo 
join TimerInterval t on h.Interval = t.Id
where h.Interval = @Interval
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--查询历史信息
CREATE procedure [dbo].[select_HisPathCheckByPath]
--查询条件
@pathNo varchar(50)
as
select h.ID,h.EmpName as 姓名,
h.CheckBeginTime as 巡检开始时间,h.CheckEndTime as 巡检结束时间,
t.IntervalName as 班次 from HisPathCheck h
left join  Path_Emp_Relation p on h.EmpID = p.EmpID
left join TimerInterval t on h.Interval = t.Id
where p.PathNo = @pathNo
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO



--查询历史信息
CREATE procedure [dbo].[select_HisPath_by_txjl]
--查询条件
@codeid varchar(10),
@rname varchar(20),
@banci varchar(5),
@kssj varchar(20),
@jssj varchar(20),
@pathid varchar(5)
as
begin
if(@codeid='0' and @rname='0' and @pathid='0')
begin
SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE
--  convert(varchar(20),CheckBeginTime,120)>@kssj  and convert(varchar(20),CheckEndTime,120)<@jssj  and t.id=@banci

(h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  and (t.ID = @banci)

end
else if(@codeid='0' and @rname='0' and @pathid!='0')
begin
SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE (po.Id = @pathid) and (h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  
and (t.ID = @banci)
end

else  if(@codeid='0' and @rname!='0' and @pathid!='0')
begin

SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE (po.Id = @pathid) and (h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  
 and Emp_Info.EmpName like'%'+@rname+'%'   and (t.ID = @banci)
end

else if(@codeid!='0' and @rname!='0' and @pathid!='0')
begin
print 'ddddd'
SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE (po.Id = @pathid) and (h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  
 and Emp_Info.EmpName like'%'+@rname+'%'  AND 
      (dbo.CodeSender_Set.CodeSenderAddress = @codeid)
 and (t.ID = @banci)
end
else if(@codeid!='0' and @rname='0' and @pathid='0')
begin

SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE (h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  
  AND       (dbo.CodeSender_Set.CodeSenderAddress = @codeid)  and (t.ID = @banci)



end
else if(@codeid!='0' and @rname!='0' and @pathid='0')

begin

SELECT h.ID, dbo.CodeSender_Set.CodeSenderAddress AS codeid, 
      dbo.Emp_Info.EmpName AS name, dbo.Dept_Info.DeptName AS dept, 
      t.IntervalName AS banci, po.PathName AS pathname, h.CheckBeginTime AS stime, 
      h.CheckEndTime AS jtime, dbo.FunConvertTime(DATEDIFF(ss, h.CheckBeginTime, 
      h.CheckEndTime)) AS xtime, h.EmpID, po.Id AS pid
FROM dbo.HisPathCheck h LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON h.EmpID = p.EmpID INNER JOIN
      dbo.Path_Info po ON p.PathNo = po.PathNo INNER JOIN
      dbo.TimerInterval t ON h.[Interval] = t.ID LEFT OUTER JOIN
      dbo.CodeSender_Set INNER JOIN
      dbo.Emp_Info ON dbo.CodeSender_Set.UserID = dbo.Emp_Info.EmpID ON 
      h.EmpID = dbo.Emp_Info.EmpID LEFT OUTER JOIN
      dbo.Emp_NowCompany INNER JOIN
      dbo.Dept_Info ON dbo.Emp_NowCompany.DeptID = dbo.Dept_Info.DeptID ON 
      dbo.Emp_Info.EmpID = dbo.Emp_NowCompany.EmpID

WHERE  (h.CheckBeginTime > CONVERT(DATETIME, @kssj, 102)) and (h.CheckEndTime < CONVERT(DATETIME, @jssj, 102))  
 and Emp_Info.EmpName like'%'+@rname+'%'  AND 
      (dbo.CodeSender_Set.CodeSenderAddress = @codeid)  and (t.ID = @banci)


end

end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--根据查询条件查询历史路线报警信息
CREATE procedure [dbo].[select_His_PathAlert]
--查询条件
@condition varchar(200)
as
declare @execValue varchar(2500)
if @condition='' or @condition is null
begin
	set @execValue='select hp.*,ei.EmpName,si.StationPlace,shi.StationHeadPlace
	from His_PathAlert hp 
	join Emp_Info ei on ei.EmpID=hp.EmpID
	join Station_Info si on si.StationAddress=hp.StationAddress
	join Station_Head_Info shi on shi.StationHeadAddress=hp.StationHeadAddress and shi.StationAddress = hp.StationAddress
	where 1=1'
end
else
begin
	set @execValue='select hp.*,ei.EmpName,si.StationPlace,shi.StationHeadPlace
	from His_PathAlert hp 
	join Emp_Info ei on ei.EmpID=hp.EmpID
	join Station_Info si on si.StationAddress=hp.StationAddress
	join Station_Head_Info shi on shi.StationHeadAddress=hp.StationHeadAddress and shi.StationAddress = hp.StationAddress
	where ' + @condition
end
exec (@execValue)
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


--查询Path_Detail信息
CREATE    procedure select_Path_Detail
--查询条件
@condition varchar(1000)
as
declare @execValue varchar(1050)

if @condition=''
begin
	set @execValue = 'select pd.*, pi.PathName, si.StationPlace, shi.StationHeadPlace 
	from Path_Detail pd, Station_Head_Info shi, Station_Info si, Path_Info pi 
	where pd.StationAddress = si.StationAddress 
	and pd.StationHeadAddress = shi.StationHeadAddress  and si.StationAddress=shi.StationAddress
	and pd.PathNo = pi.PathNo order by pd.PathNo,pd.ID'
end
else
begin
	set @execValue ='select pd.*, pi.PathName, si.StationPlace, shi.StationHeadPlace 
	from Path_Detail pd 
	join Path_Info pi on pd.PathNo=pi.PathNo
	join Station_Info si on pd.StationAddress=si.StationAddress
	join Station_Head_Info shi on pd.StationHeadAddress=shi.StationHeadAddress and si.StationAddress=shi.StationAddress
	where '+@condition+'order by pd.Id'
--, Station_Head_Info shi, Station_Info si, Path_Info pi 
end
exec (@execValue)


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




--查询Path_Emp_Relation
CREATE procedure [dbo].[select_Path_Emp_Relation]
--查询条件
@condition varchar(1000)
as
declare @execValue varchar(1500)

if @condition=''
begin
	set @execValue ='select per.*,ei.EmpName,ei.EmpNo,pi.PathName from Path_Emp_Relation per 
	join Emp_Info ei on per.EmpID=ei.EmpID
	join Path_info pi on per.PathNo=pi.PathNo'
end
else
begin
	set @execValue ='select per.*,ei.EmpName,ei.EmpNo,pi.PathName from Path_Emp_Relation per 
	join Emp_Info ei on per.EmpID=ei.EmpID
	join Path_info pi on per.PathNo=pi.PathNo 
	where '+@condition
end
exec (@execValue)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查询Path_Info相关信息
create procedure select_Path_Info
--查询条件
@condition varchar(100)
as
declare @execValue varchar(150)

if @condition='' or @condition is null
begin
	set @execValue ='select * from Path_Info order by PathNo'
end
else
begin
	set @execValue ='select * from Path_Info where '+@condition+' order by PathNo'
end
exec (@execValue)



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--获取实时路线报警信息
CREATE procedure [dbo].[select_RealTimeAlarmPathInfo]
as
select rtap.*,ei.EmpName,si.StationPlace,shi.StationHeadPlace 
from RealTimeAlarmPathInfo rtap 
--join Path_Info pi on pi.PathNo=rtap.PathNo
left join Emp_Info ei on ei.EmpID=rtap.EmpID
left join Station_Info si on si.StationAddress=rtap.StationAddress
left join Station_Head_Info shi on shi.StationHeadAddress=rtap.StationHeadAddress 
and shi.StationAddress = rtap.StationAddress
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--按排班查询实时巡检信息
CREATE procedure [dbo].[select_RealTimePathCheckByInterval]
@Interval int 
as
select r.ID,r.EmpID,e.EmpName as 姓名,r.CheckTime as 巡检时间,t.IntervalName as 班次,p.PathNo as 路线编号 
from RealTimePathCheck r
left join Emp_Info e on r.EmpID = e.EmpID
left join Path_Emp_Relation p on r.EmpID=p.EmpID
left join TimerInterval t on r.Interval = t.Id
where r.Interval = @Interval
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--按路线查询实时巡检信息
CREATE procedure [dbo].[select_RealTimePathCheckByPath]
@pathNo varchar(50)
as
select r.ID,r.EmpID,e.EmpNo as 人员编号,e.EmpName as 姓名,r.CheckTime as 巡检时间,
t.IntervalName as 班次 from RealTimePathCheck r
join Emp_Info e on r.EmpID = e.EmpID
left join  Path_Emp_Relation p on r.EmpID = p.EmpID
join TimerInterval t on r.Interval = t.Id
where p.PathNo = @pathNo
GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS OFF 
GO


CREATE procedure [dbo].[select_RealTimePath_by_txj]
@codeid varchar(10),
@rname varchar(20),
@banci varchar(5),
@pathid varchar(5)
as
begin
if(@codeid='0' and @rname='0' and @pathid='0' and @banci!='0')
begin
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE (t.ID =@banci)

end
else if(@codeid='0' and @rname!='0' and @pathid!='0' and @banci!='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE (Path_Info.Id = @pathid)  AND (t.ID =@banci) and e.EmpName  like'%'+@rname+'%'



end
else if(@codeid!='0' and @rname='0' and   @pathid!='0' and @banci!='0')
begin
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE (Path_Info.Id = @pathid)  AND (t.ID =@banci)  and CodeSender_Set.CodeSenderAddress=@codeid

end

else if (@codeid!='0' and @rname!='0'  and @pathid!='0' and @banci!='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE (Path_Info.Id = @pathid)  AND (t.ID =@banci)  and CodeSender_Set.CodeSenderAddress=@codeid and   e.EmpName  like'%'+@rname+'%' 


end
else if(@codeid='0' and @rname!='0' and @pathid='0' and @banci!='0')
begin 
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  (t.ID =@banci)    and   e.EmpName  like'%'+@rname+'%' 







end
else if(@codeid!='0' and @rname='0' and @pathid='0' and @banci!='0')
begin 
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  (t.ID =@banci)  and CodeSender_Set.CodeSenderAddress=@codeid  







end
else if(@codeid!='0' and @rname!='0' and @pathid='0' and @banci!='0')
begin 
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  (t.ID =@banci)  and CodeSender_Set.CodeSenderAddress=@codeid and   e.EmpName  like'%'+@rname+'%' 







end
else if(@codeid='0' and @rname='0' and @pathid!='0' and @banci!='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  (t.ID =@banci)   and  (Path_Info.Id = @pathid) 




end
else if(@codeid='0' and @rname='0' and @pathid!='0' and @banci='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE    (Path_Info.Id = @pathid) 

end

else if(@codeid='0' and @rname='0' and @pathid='0' and @banci='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
 

end
else if(@codeid='0' and @rname!='0' and @pathid='0' and @banci='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE   e.EmpName  like'%'+@rname+'%' 

end
else if(@codeid!='0' and @rname='0' and @pathid='0' and @banci='0')
begin
SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  CodeSender_Set.CodeSenderAddress=@codeid  


end
else if(@codeid!='0' and @rname!='0' and @pathid='0' and @banci='0')
begin

SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE    CodeSender_Set.CodeSenderAddress=@codeid and   e.EmpName  like'%'+@rname+'%' 

end

else if(@codeid!='0' and @rname='0' and @pathid!='0' and @banci='0')
begin


SELECT r.ID, dbo.CodeSender_Set.CodeSenderAddress AS sendid, e.EmpName AS rname, 
      dbo.Dept_Info.DeptName AS bumen, t.IntervalName AS banci, 
      dbo.Path_Info.PathName AS pathname, r.CheckTime AS xtime, 
      dbo.RealTimeCodeSender.LastPlace AS weizhi, 
      dbo.RealTimeCodeSender.StationHeadDetectTime AS weizhitime, r.EmpID, 
      dbo.Path_Info.Id AS pid, t.ID AS tid
FROM dbo.Path_Info INNER JOIN
      dbo.RealTimePathCheck r INNER JOIN
      dbo.Emp_Info e ON r.EmpID = e.EmpID LEFT OUTER JOIN
      dbo.Path_Emp_Relation p ON r.EmpID = p.EmpID INNER JOIN
      dbo.TimerInterval t ON r.[Interval] = t.ID INNER JOIN
      dbo.CodeSender_Set ON e.EmpID = dbo.CodeSender_Set.UserID ON 
      dbo.Path_Info.PathNo = p.PathNo INNER JOIN
      dbo.RealTimeCodeSender ON 
      dbo.CodeSender_Set.CsSetID = dbo.RealTimeCodeSender.CsSetID LEFT OUTER JOIN
      dbo.Dept_Info INNER JOIN
      dbo.Emp_NowCompany ON 
      dbo.Dept_Info.DeptID = dbo.Emp_NowCompany.DeptID ON 
      e.EmpID = dbo.Emp_NowCompany.EmpID
WHERE  (t.ID =@banci)  and CodeSender_Set.CodeSenderAddress=@codeid  

end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


create procedure select_StationHeadInfo
@stationAddress int
as 
select StationHeadAddress,StationHeadPlace from Station_Head_Info 
where StationAddress=@stationAddress
------------------------


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--查找分站信息
create procedure select_StationInfo
as 
select StationAddress,StationPlace from dbo.Station_Info


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

create procedure select_TimeInterval
as
select ID,IntervalName from TimerInterval

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create proc updateMenu1
(
@id  int,
@PMenuID int,
@Title varchar (50),

@Remark varchar(200),
@name varchar (20)

)
as 
UPDATE menus1
SET  [PMenuID]=@PMenuID, [Title]=@Title, [name]=@name
WHERE id =@id



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO


CREATE   PROCEDURE updateUser
(

@Account varchar (20),
@Password varchar (16),
@Passwordback varchar(16),
@IsEnable bit,
@IsUseEndDate bit,
@UseEndDate smalldatetime,
@UserGroupID int,
@CreateID int,
@CreateIP bigint,
@Remark varchar (200),
@ID int
)
AS
	UPDATE Admins Set 
	[Account] = @Account, [Password] = @Password,[Passwordback]=@Passwordback ,[IsEnable] = @IsEnable, [IsUseEndDate] = @IsUseEndDate, [UseEndDate] = @UseEndDate, [UserGroupID] = @UserGroupID, [LoginTotal] = 0, [CreateID] = @CreateID, [CreateDate] = getdate(), [CreateIP] = @CreateIP, [Remark] = @Remark
	Where [ID] = @ID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--修改Path_Detail
CREATE  procedure update_Path_Detail
@Id int,
@PathNo varchar(50),
@StationAddress int,
@StationHeadAddress int
as 
--declare @count int 
--set @count = (select count(*) from Path_Detail where (PathNo=@PathNo
 --and (StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress)) and Id<>@Id)

--if @count=0
--begin
	update Path_Detail set PathNo=@PathNo,StationAddress=@StationAddress,
	StationHeadAddress=@StationHeadAddress where Id=@id
--end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--修改Path_Emp_Relation
CREATE procedure [dbo].[update_Path_Emp_Relation]
@Id int,
@PathNo varchar(20),
@EmpID varchar(20)
as
declare @count int 
set @count=(select count(*) from Path_Emp_Relation where (PathNo=@PathNo and  EmpID=@EmpID) and Id<>@Id)
if @count=0
begin
update Path_Emp_Relation set PathNo=@PathNo,EmpID=@EmpID where Id=@Id
end


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


--修改Path_Info			  
create procedure update_Path_Info
@Id int,
@PathNo varchar(50),
@PathName varchar(100),
@Remark varchar(200)
as
declare @count int 

set @count = (select count(*) from Path_Info where (PathNo=@PathNo or PathName=@PathName) and Id<>@Id)
if @count=0
begin
	update Path_Info set PathNo=@PathNo,PathName=@PathName,Remark=@Remark where Id=@Id
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



--更新实时报警信息
create procedure update_RealTimeAlarmPathInfo
--@PathNo varchar(20),
@EmpNo varchar(20),  
@StationAddress int,
@StationHeadAddress int,
@AlarmDatetime datetime
as
update RealTimeAlarmPathInfo set EmpNo=@EmpNo,
StationAddress=@StationAddress,StationHeadAddress=@StationHeadAddress,
AlarmDatetime=@AlarmDatetime where EmpNo=@EmpNo



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--更新
create procedure update_RealTimePathCheck
@EmpNo varchar(20),
@Interval int,
@CheckTime datetime
as
update RealTimePathCheck set Interval=@Interval, CheckTime=@CheckTime
where EmpNo=@EmpNo 

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create procedure workExceptionStatement
@beginTime datetime,
@endTime datetime
as

select distinct  css.CodeSenderAddress as 标识卡,ei.EmpNo as 人员编号 ,ei.EmpName as 人员姓名,
dui.DutyName as 职务,wti.WtName as 工种,di.DeptName as 部门,
(select count(hpa1.EmpID) from His_PathAlert as hpa1 where hpa1.EmpID=hpa.EmpID and hpa1.AlertBeginTime>=@beginTime and hpa1.AlertBeginTime<@endTime) as 报警次数,
dbo.FunConvertTime((select sum(AlertTimeValue) from His_PathAlert as hpa2 where hpa2.EmpID=hpa.EmpID and hpa2.AlertBeginTime>=@beginTime and hpa2.AlertBeginTime<@endTime)) as 报警时间总长
from His_PathAlert as hpa
join Emp_Info as ei on hpa.EmpID = ei.EmpID
join Emp_NowCompany as enc on ei.EmpID = enc.EmpID
join Dept_Info as di on enc.DeptID = di.DeptID
join CodeSender_Set as css on css.UserID=ei.EmpID
left join Duty_Info as dui on dui.DutyID = enc.DutyID
left Join Emp_WorkType as ewt on ewt.EmpID = ei.EmpID
left join WorkType_Info as wti on wti.WorkTypeID = ewt.WorkTypeID

where AlertBeginTime>=@beginTime and AlertBeginTime<@endTime
order by css.CodeSenderAddress


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc zdc_Auto_buzou
as
-- 第一步,将历史数据表 从数据库从删除
-- 第二步,创建历史数据表的视图
-- 第三步,删除所有乱记录
-- 第四步,测试历史数据表的视图
-- 第五步,向视图中插入数据
drop table dbo.His_InOutMine

drop table dbo.His_InOutStation

drop table dbo.His_InOutStationHead

-- 删除多余的视图

drop table dbo.His_InOutStationHead_1

drop table His_InOutMine_1

drop view dbo.His_InOutMineww

drop view dbo.His_InOutStationHeadww

drop view dbo.His_InOutStationww

-- 删除自动生成的表

exec dbo.Auto_Delete_His_View


-- 执行创建


exec dbo.CreateHistoryDataTable '2007-10-1'


-- 执行插入His_InOutStation




exec KJ128N_Insert_HisInOutStation '2007-1-1 1:00:1',1,1,1,0,'112,113,1314',1

--服务器: 消息 4448，级别 16，状态 17，过程 KJ128N_Insert_HisInOutStation，行 25
--无法插入 (INSERT) 分区视图 'His_InOutStation' 中，因为没有为所有列提供值。
Insert Into [His_InOutStation] ([HisInStationID],[StationAddress], [StationHeadAddress], 
		[StationHeadAntennaA], [StationHeadAntennaB], [StationHeadDetectTime], 
		[CodeSenderID],[InStationAntenna],[StationHeadPlace],
                [StationAntennaPlace],[CsSetID],[CsTypeID],[UserID],[CodeSenderAddress])
values(1,1,1,1,1,'2007-1-1',1,1,'1','1',1,1,1,1)


select * from His_InOutStation


exec dbo.KJ128N_Insert_HisStationHeadInfo '2007-1-1 1:00:1',1,1,1,0,'112,113,1314',1


select * from dbo.His_InOutStationHead


exec dbo.KJ128N_Insert_His_InOutMine '2007-1-1 1:00:1',1,1,1,0,'112,113,1314'


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE    proc zdc_KJ128N_Test_11Month4Day
	
as   
-- 测试基站各种状态

-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线B 接收到
exec dbo.Wwy_Station_InOutStation '2007-11-4 11:00:00',9,1,1,0,'113,114,115,116,117,118'


-- 存在 113 114 115 116 117 118  六个发码器进入 1号基站 0 探头 天线A 天线B都没有接收到
exec dbo.Wwy_Station_InOutStation '2007-11-4 19:00:00',9,1,0,1,'113,114,115,116,117,118,121,123'

exec dbo.Wwy_Station_InOutStation '2007-11-4 18:20:00',1,1,0,1,'113,114,115,116,117,118,121,123'

-- 下井

exec dbo.Wwy_Station_InOutStation '2007-11-5 8:00:00',9,1,0,1,'113,114,115,116,117,118,121,123'
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:01:00',9,1,1,0,'113,114,115,116,117,118,121,123'
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:02:00',9,1,0,0,'113,114,115,116,117,118,121,123'
--
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:10:00',1,1,0,1,'113,114,115,116,117,118,121,123'
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:11:00',1,1,1,0,'113,114,115,116,117,118,121,123'
--
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:12:00',1,1,0,0,'113,114,115,116,117,118,121,123'
exec dbo.Wwy_Station_InOutStation '2007-11-5 8:13:00',1,2,1,0,'113,114,115,116,117,118,121,123'


exec dbo.Wwy_Station_StateChange 1,0,2000,null


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

--********************************************************************************************************************--

--******************************************************************************************************************--
/*
	删除历史数据
*/
CREATE proc [dbo].[zjw_DeleteHisData]
(
	@DeleteDateTime datetime	--要删除数据的时间
)
as
begin
	declare @year varchar(4)
	declare @month varchar(2)
	declare @sql varchar(4000)
	set @year=DATEPART(yyyy,@DeleteDateTime)
	set @month=DATEPART(m,@DeleteDateTime)
--	delete From dbo.His_EmpHelp where BeginDateTime< @DeleteDateTime
	
	set @sql='delete From dbo.His_InOutMine_'+@year+@month+' where InTime<'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)
--	delete From dbo.His_InOutStation Where StationHeadDetectTime < @DeleteDateTime
	set @sql='delete From dbo.His_InOutStationHead_'+@year+@month+' Where InStationHeadTime <'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)
--	delete From dbo.His_InOutTerritorial Where InTerritorialTime < @DeleteDateTime
	set @sql='delete From dbo.His_OverEmployees where His_OverEmployeeBeginTime <'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)
	set @sql='delete From dbo.His_OverTimeAlarm Where InMineTime <'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)
--	delete From dbo.His_PathAlert where AlertBeginTime < @DeleteDateTime
--	delete From dbo.HisPathCheck Where CheckBeginTime< @DeleteDateTime
	set @sql='delete From dbo.HistoryAttendance where BeginWorkTime<'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)
	
	--历史分站接收器故障信息
	set @sql='delete From dbo.HistoryBadStations Where BadBeginTime <'+char(39)+convert(varchar(20),@DeleteDateTime)+char(39)
	exec (@sql)

end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




CREATE    proc zjw_Delete_AllTable
as
begin
	--AlarmSet表，不能删除，只需恢复到初始状态


	delete from dbo.Certificate_Info
	delete from dbo.CodeSender_Directional
	delete from dbo.CodeSender_Info
	delete from dbo.CodeSender_Set
	delete from dbo.ConfigFile_ZZHA

	delete from dbo.Dept_Info
	delete from dbo.Duty_Info
	delete from dbo.Emp_Certificate
	delete from dbo.Emp_Info
	delete from dbo.Emp_Photo
	delete from dbo.Equ_BaseInfo
	delete from dbo.Equ_DetailInfo
	delete from dbo.Equ_HisCheck
	delete from dbo.FactoryInfo

--历史数据
	delete from dbo.His_AreaDirection_20081
	delete from dbo.His_AreaDirection_20082
	delete from dbo.His_AreaDirection_20083
	delete from dbo.His_AreaDirection_20084
	delete from dbo.His_AreaDirection_20085
	delete from dbo.His_AreaDirection_20086
	delete from dbo.His_AreaDirection_20087
	delete from dbo.His_AreaDirection_20088
	delete from dbo.His_AreaDirection_20089
	delete from dbo.His_AreaDirection_200810
	delete from dbo.His_AreaDirection_200811
	delete from dbo.His_AreaDirection_200812

	delete from dbo.His_Directional_20081
	delete from dbo.His_Directional_20082
	delete from dbo.His_Directional_20083
	delete from dbo.His_Directional_20084
	delete from dbo.His_Directional_20085
	delete from dbo.His_Directional_20086
	delete from dbo.His_Directional_20087
	delete from dbo.His_Directional_20088
	delete from dbo.His_Directional_20089
	delete from dbo.His_Directional_200810
	delete from dbo.His_Directional_200811
	delete from dbo.His_Directional_200812

	delete from dbo.His_InOutMine_20081
	delete from dbo.His_InOutMine_200810
	delete from dbo.His_InOutMine_200811
	delete from dbo.His_InOutMine_200812
	delete from dbo.His_InOutMine_20082
	delete from dbo.His_InOutMine_20083
	delete from dbo.His_InOutMine_20084
	delete from dbo.His_InOutMine_20085
	delete from dbo.His_InOutMine_20086
	delete from dbo.His_InOutMine_20087
	delete from dbo.His_InOutMine_20088
	delete from dbo.His_InOutMine_20089

	delete from dbo.His_InOutReceiver_20081
	delete from dbo.His_InOutReceiver_20082
	delete from dbo.His_InOutReceiver_20083
	delete from dbo.His_InOutReceiver_20084
	delete from dbo.His_InOutReceiver_20085
	delete from dbo.His_InOutReceiver_20086
	delete from dbo.His_InOutReceiver_20087
	delete from dbo.His_InOutReceiver_20088
	delete from dbo.His_InOutReceiver_20089
	delete from dbo.His_InOutReceiver_200810
	delete from dbo.His_InOutReceiver_200811
	delete from dbo.His_InOutReceiver_200812


	delete from dbo.His_InOutStation_20081
	delete from dbo.His_InOutStation_200810
	delete from dbo.His_InOutStation_200811
	delete from dbo.His_InOutStation_200812
	delete from dbo.His_InOutStation_20082
	delete from dbo.His_InOutStation_20083
	delete from dbo.His_InOutStation_20084
	delete from dbo.His_InOutStation_20085
	delete from dbo.His_InOutStation_20086
	delete from dbo.His_InOutStation_20087
	delete from dbo.His_InOutStation_20088
	delete from dbo.His_InOutStation_20089

	delete from dbo.His_InOutStationHead_20081
	delete from dbo.His_InOutStationHead_200810
	delete from dbo.His_InOutStationHead_200811
	delete from dbo.His_InOutStationHead_200812
	delete from dbo.His_InOutStationHead_20082
	delete from dbo.His_InOutStationHead_20083
	delete from dbo.His_InOutStationHead_20084
	delete from dbo.His_InOutStationHead_20085
	delete from dbo.His_InOutStationHead_20086
	delete from dbo.His_InOutStationHead_20087
	delete from dbo.His_InOutStationHead_20088
	delete from dbo.His_InOutStationHead_20089

	delete from dbo.His_InOutTerritorial
	delete from dbo.His_OverEmployees
	delete from dbo.His_OverTimeAlarm
	delete from dbo.His_PathAlert
	delete from dbo.His_PostInfo

	delete from dbo.HisPathCheck
	delete from dbo.HistoryAttendance
	delete from dbo.HistoryBadStations
	delete from dbo.HistoryWalkInfo

--dbo.HolidayType 和 dbo.InfoClass 需手工更改

	delete from dbo.passStationHead
	delete from dbo.Path_Detail
	delete from dbo.Path_Emp_Relation
	delete from dbo.Path_Info
	delete from dbo.pathString
	delete from dbo.Points
	delete from dbo.RealTimeAlarmPathInfo
	delete from dbo.RealTimeAttendance
	delete from dbo.RealTimeAttendanceError
	delete from dbo.RealTimeCodeSender
	delete from dbo.RealTimePathCheck
	delete from dbo.RealTimeWalkInfo
	delete from dbo.Route
	delete from dbo.RT_EmpHelp
	delete from dbo.RT_InOutMine
	delete from dbo.RT_InOutStation
	delete from dbo.RT_InStationHeadInfo
	delete from dbo.RT_OverEmployees
	delete from dbo.RT_OverTimeInfo
	delete from dbo.RT_PostInfo
	delete from dbo.RT_TerritorialInfo
	delete from dbo.SpecialWorkTypeTerrialSet
	delete from dbo.Station_Head_Info
	delete from dbo.Station_Info
	delete from dbo.Territorial_Info
	delete from dbo.Territorial_Set

--dbo.Territorial_Type表 需手工更改

	delete from dbo.WalkConfigInfo
	delete from dbo.WorkType_Info
	delete from dbo.WorkType_SysSet

	delete from CodeSender_DirectionalAntenna
	delete from Dept_Detail
	delete from Emp_Search

	delete from G_DConfigFile
	delete from G_DPicFile
	delete from G_DPoint
	delete from G_DRoute
	delete from G_File_Station

	delete from His_EmpHelp
	delete from Log_StationError
	delete from RT_AreaDirection
	delete from RT_DirectionalAntenna
	delete from TcpIPConfig
	delete from Territorial_Config

end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc zjw_Delete_RT_EmpHelp
(
	@EmpID int
)
as
--将实施救援表中的数据更新到历史求救表中，同时删除实时求救表中的记录

declare @EndTime datetime		--救援结束时间

set @EndTime=getdate()

insert into dbo.His_EmpHelp (CodeSenderAddress,StationAddress,StationPlace,StationHeadAddress,StationHeadPlace,EmpName,DeptName,
			DutyName,WtName,BeginDateTime,EndDateTime,Measure)
select 发码器编号,分站编号,分站安装位置,接收器编号,接收器安装位置,姓名,部门,职务,工种,求救开始时间,@EndTime,救援措施 from dbo.zjw_RT_EmpHelp_View where EmpID=@EmpID

delete RT_EmpHelp where EmpID=@EmpID




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





CREATE    proc zjw_DeptInfo_Insert
(
--基本表
  @ParentDeptID int,
  @DeptLevelID int,
  @DeptNO nvarchar(20),
  @DeptName nvarchar(20),
  @Remark nvarchar(200),
  @ClassID int,

--配置表
  @MaxTimeSec int,
  @MinTimeSec int,

--信息表
  @DeptTel1 nvarchar(20),
  @DeptTel2 nvarchar(20),
  @DeptFax nvarchar(20),
  @DeptPost nvarchar(6),
  @DeptAddress nvarchar(250),
  @DeptEmail nvarchar(100),

--领导表
  @EmpID int,
  @LeadDateTime datetime
)
as

begin
declare @DeptID int	--部门ID

if( not exists( Select 1 From Dept_Info Where DeptNO=@DeptNO))
begin
	--部门基本表
	Insert into [Dept_Info]
	(ParentDeptID,DeptLevelID,DeptNO,DeptName,Remark,ClassID)
	values
	(@ParentDeptID,@DeptLevelID,@DeptNO,@DeptName,@Remark,@ClassID)
end
else
begin
	Update Detp_Info
	Set ParentDeptID=@ParentDeptID,DeptLevelID=@DeptLevelID,DeptName=@DeptName,
		Remark=@Remark,ClassID=@ClassID
	where DeptNO=@DeptNO
end	


select @DeptID = DeptID from Dept_Info where DeptNO = @DeptNO

--print @DeptID

if(@DeptID is not null)
begin
	
	--部门信息表
	if((select count(*) from Dept_Detail where DeptID=@DeptID)>0)
	begin
--print '部门信息 1'
		Update Dept_Detail 
		   set DeptTel1=@DeptTel1,DeptTel2=@DeptTel2,DeptFax=@DeptFax,
		       DeptPost=@DeptPost,DeptAddress=@DeptAddress,DeptEmail=@DeptEmail
		where DeptID=@DeptID
	end
	else
	begin
--print '部门信息 2'
		Insert into [Dept_Detail]
		(DeptID,DeptTel1,DeptTel2,DeptFax,DeptPost,DeptAddress,DeptEmail)
		values
		(@DeptID,@DeptTel1,@DeptTel2,@DeptFax,@DeptPost,@DeptAddress,@DeptEmail)
	end

	--部门配置表
	if(not exists(select 1 from Dept_SysSet where DeptID = @DeptID ))
	begin
--print '部门配置'
	Insert into [Dept_SysSet]
	(DeptID,MaxTimeSec,MinTimeSec)
	values
	(@DeptID,@MaxTimeSec,@MinTimeSec)
	end	

	--部门领导表
	if(@EmpID>0)
	begin
		if((select count(*) from Dept_Lead where DeptID=@DeptID)>0)
		begin
--print '部门领导 1'
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			update Dept_Lead 
			set EmpID=@EmpID,LeadDateTime=@LeadDateTime
			where DeptID = @DeptID
		end
		else
		begin
			
--print '部门领导 2'
			if @LeadDateTime='1800-01-01' 
			begin
				set @LeadDateTime=null
			end	

			Insert into [Dept_Lead]
			    (DeptID,EmpID,LeadDateTime)
			values
			    (@DeptID,@EmpID,@LeadDateTime)
		
		end
	end

end

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

/*
	添加员工岗位配置信息
	赵建伟
	2008-07-08 13:01:00
*/


create proc zjw_EmpPost_Insert
(
	@CodeSenderAddress int,
	@TerritorialID int,
	@WorkTime int,
	@Remark nvarchar(200)
)
as
begin
	declare @EmpID int
	
	select @EmpID=UserID From CodeSender_Set Where CodeSenderAddress=@CodeSenderAddress and CsTypeID=0

	if(@EmpID is not null)
	begin
		if(not exists(Select 1 From Emp_Post Where EmpID=@EmpID))
		begin
			insert into Emp_Post(EmpID,TerritorialID,WorkTime,Remark)
			values(@EmpID,@TerritorialID,@WorkTime,@Remark)
		end	
	end

end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
	修改员工岗位配置信息
	赵建伟
	2008-07-09 09:17:00
*/


create  proc zjw_EmpPost_Updata
(
	@CodeSenderAddress int,
	@TerritorialID int,
	@WorkTime int,
	@Remark nvarchar(200)
)
as
begin
	declare @EmpID int
	
	select @EmpID=UserID From CodeSender_Set Where CodeSenderAddress=@CodeSenderAddress and CsTypeID=0

	if(@EmpID is not null)
	begin
		if(exists(Select 1 From Emp_Post Where EmpID=@EmpID))
		begin
			Update Emp_Post
			Set TerritorialID=@TerritorialID,WorkTime=@WorkTime,Remark=@Remark
			Where EmpID=@EmpID
		end	
	end
end





GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





/*
	增加员工信息
	李乐
	2008-06-23 13：52
*/

CREATE     proc zjw_Emp_Insert
(
	@EmpName nvarchar(20),
	@Sex bit,
	@Remark nvarchar(200),
	@EmpNO nvarchar(10),
	@DeptID int,

	@DutyID int,
	@MaxSecTime int,
	@MinSecTime int,
	@Selectmode int,
	@ClassGroup nvarchar(50),

	@WorkPlace nvarchar(50),
	@Photo image =null,
	@EmpTel1 nvarchar(20),
	@EmpTel2 nvarchar(20),
	@EmpTel3 nvarchar(20),

	@EmpQQ nvarchar(20),
	@EmpMsn nvarchar(20),
	@HomePage nvarchar(200),
	@EmpEmail nvarchar(80),
	@EmpEmailBackup nvarchar(80),

	@Nation nvarchar(30),
	@WedlockID int,
	@ClanID int,
	@NativePlace nvarchar(50)=null,
	@CensusRegister nvarchar(50),

	@SchoolRecordID int,
	@GraduateFrom nvarchar(35),
	@Specialty nvarchar(50),
	@OfficialDesignation nvarchar(50),
	@Idcard nvarchar(20),

	@BirthDay datetime,
	@Height int,
	@Weight int,
	@StateOfHealth nvarchar(50),
	@HomeTel1 nvarchar(20),

	@HomeTel2 nvarchar(20),
	@HomeAddress nvarchar(250),
	@Postalcode nvarchar(6),
	@ProbationDate datetime,
	@OfficiallyDate datetime,

	@ContractExpDate datetime,
	@ContractExpAppendDate datetime,
	@IsGearShift bit,
	@HireTypeID int,
	@Archives nvarchar(100),

	@DimissionTime datetime,
	@EmpDetailRemark nvarchar(200),
	@EmpSerchRemark nvarchar(200),
	@EmpHomeRemark nvarchar(200),
	@EmpInCompanyRemark nvarchar(200),

	@EmpNowCompanyRemark nvarchar(200),
	@WorkTypeID1 int,
	@IsMostly1 bit,
	@IsEnable1 bit,
	@WorkTypeID2 int,

	@IsMostly2 bit,
	@IsEnable2 bit,
	@WorkTypeID3 int,
	@IsMostly3 bit,
	@IsEnable3 bit
)
as
begin

declare @EmpID int	--定义员工ID
declare @PhotoID int	--员工照片表ID

BEGIN TRANSACTION		--创建事务

if(not exists(Select 1 From Emp_Info Where EmpNO=@EmpNO))	
begin
	--插入员工信息表(Emp_Info)
	Insert into [Emp_Info](EmpName,Sex,Remark,EmpNO)
	values(@EmpName,@Sex,@Remark,@EmpNO)

	--为员工ID(EmpID)赋值
	select @EmpID=EmpID From Emp_Info where EmpNO=@EmpNO

	--插入员工在公司表
	if(not exists ( Select 1 From Emp_NowCompany Where EmpID=@EmpID))
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end

		Insert into [Emp_NowCompany] (EmpID,DeptID,DutyID,MaxSecTime,MinSecTime,
				Selectmode,ClassGroup,WorkPlace,Remark)
		values (@EmpID,@DeptID,@DutyID,@MaxSecTime,@MinSecTime,@Selectmode,
			@ClassGroup,@WorkPlace,@EmpNowCompanyRemark)

	end

	--插入员工照片表
	if( @Photo is not null )
	begin
	    Insert into [Emp_Photo]
	      (EmpID,Photo)
	    values
	      (@EmpID,@Photo)
	end

	--为@PhotoID赋值
	select @PhotoID=PhotoID From Emp_Photo where EmpID=@EmpID 

	--插入员工家庭联系方式表(Emp_Search)
	if(not exists ( Select 1 From dbo.Emp_Search Where EmpID=@EmpID))
	begin
		Insert into [Emp_Search] (EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,
			EmpEmail,EmpEmailBackup,Remark)
		values (@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,
			@EmpEmail,@EmpEmailBackup,@EmpSerchRemark)
	end
	
	--插入员工详细信息表(Emp_Detail)

	if(not exists( Select 1 From Emp_Detail Where EmpID=@EmpID))
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		insert into Emp_Detail(EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,
			GraduateFrom,Specialty,OfficialDesignation,PhotoID,Idcard,BirthDay,Remark)
		values ( @EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,
			@GraduateFrom,@Specialty,@OfficialDesignation,@PhotoID,@Idcard,@BirthDay,@EmpDetailRemark)
	end

	--插入员工健康表(Emp_Health)
	if(not exists ( Select 1 From Emp_Health Where EmpID=@EmpID))
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		insert into Emp_Health(EmpID,Height,Weight,StateOfHealth)
		values (@EmpID,@Height,@Weight,@StateOfHealth)
	end

	--插入员工家庭表(Emp_Home)
	if( not exists ( Select 1 From Emp_Home Where EmpID=@EmpID))
	begin
		insert into Emp_Home(EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
		values (@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@EmpHomeRemark)
	end

	--插入员工进公司表(Emp_InCompany)
	if( not exists ( Select 1 From Emp_InCompany where EmpID=@EmpID))
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		insert into Emp_InCompany(EmpID,ProbationDate,OfficiallyDate,ContractExpDate,
			ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
		values (@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,
			@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@EmpInCompanyRemark)
	end

	--插入员工工种表1
	if( @WorkTypeID1 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID1 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID1,@IsMostly1,@IsEnable1)
	
		end
	end

	--插入员工工种表2
	if( @WorkTypeID2 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID2 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID2,@IsMostly2,@IsEnable2)
	
		end
	end

	--插入员工工种表3
	if( @WorkTypeID3 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID3 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID3,@IsMostly3,@IsEnable3)
	
		end
	end
end

commit
end






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


/*
	增加员工信息
	赵建伟
	2008-06-23 13：52
*/

CREATE    proc zjw_Emp_Update
(
	@EmpName nvarchar(20),
	@Sex bit,
	@Remark nvarchar(200),
	@EmpNO nvarchar(10),
	@DeptID int,

	@DutyID int,
	@MaxSecTime int,
	@MinSecTime int,
	@Selectmode int,
	@ClassGroup nvarchar(50),

	@WorkPlace nvarchar(50),
	@Photo image =null,
	@EmpTel1 nvarchar(20),
	@EmpTel2 nvarchar(20),
	@EmpTel3 nvarchar(20),

	@EmpQQ nvarchar(20),
	@EmpMsn nvarchar(20),
	@HomePage nvarchar(200),
	@EmpEmail nvarchar(80),
	@EmpEmailBackup nvarchar(80),

	@Nation nvarchar(30),
	@WedlockID int,
	@ClanID int,
	@NativePlace nvarchar(50)=null,
	@CensusRegister nvarchar(50),

	@SchoolRecordID int,
	@GraduateFrom nvarchar(35),
	@Specialty nvarchar(50),
	@OfficialDesignation nvarchar(50),
	@Idcard nvarchar(20),

	@BirthDay datetime,
	@Height int,
	@Weight int,
	@StateOfHealth nvarchar(50),
	@HomeTel1 nvarchar(20),

	@HomeTel2 nvarchar(20),
	@HomeAddress nvarchar(250),
	@Postalcode nvarchar(6),
	@ProbationDate datetime,
	@OfficiallyDate datetime,

	@ContractExpDate datetime,
	@ContractExpAppendDate datetime,
	@IsGearShift bit,
	@HireTypeID int,
	@Archives nvarchar(100),

	@DimissionTime datetime,
	@EmpDetailRemark nvarchar(200),
	@EmpSerchRemark nvarchar(200),
	@EmpHomeRemark nvarchar(200),
	@EmpInCompanyRemark nvarchar(200),

	@EmpNowCompanyRemark nvarchar(200),
	@WorkTypeID1 int,
	@IsMostly1 bit,
	@IsEnable1 bit,
	@WorkTypeID2 int,

	@IsMostly2 bit,
	@IsEnable2 bit,
	@WorkTypeID3 int,
	@IsMostly3 bit,
	@IsEnable3 bit
)
as
begin

declare @EmpID int	--定义员工ID
declare @PhotoID int	--员工照片表ID

begin transaction EmpInfo_Trans	--创建事务

begin

if(exists(Select 1 From Emp_Info Where EmpNO=@EmpNO))	
begin
	--修改员工信息表(Emp_Info)
	update Emp_Info 
	Set EmpName=@EmpName,Sex=@Sex,Remark=@Remark
	where EmpNO=@EmpNO

	--为员工ID(EmpID)赋值
	select @EmpID=EmpID From Emp_Info where EmpNO=@EmpNO 

	--修改员工在公司表
	if(not exists ( Select 1 From Emp_NowCompany Where EmpID=@EmpID))
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end

		Insert into [Emp_NowCompany] (EmpID,DeptID,DutyID,MaxSecTime,MinSecTime,
				Selectmode,ClassGroup,WorkPlace,Remark)
		values (@EmpID,@DeptID,@DutyID,@MaxSecTime,@MinSecTime,@Selectmode,
			@ClassGroup,@WorkPlace,@EmpNowCompanyRemark)

	end
	else
	begin
		if(@DeptID=0)
		begin
			set @DeptID=null
		end
	
		if(@DutyID=0)
		begin
			set @DutyID=null
		end
		
		update Emp_NowCompany
		Set DeptID=@DeptID,DutyID=@DutyID,MaxSecTime=@MaxSecTime,MinSecTime=@MinSecTime,
			Selectmode=@Selectmode,ClassGroup=@ClassGroup,WorkPlace=@WorkPlace,Remark=@EmpNowCompanyRemark
		Where EmpID=@EmpID
	
	end

	--修改员工照片表
	if( @Photo is not null )
	begin
		if( not exists(Select 1 From Emp_Photo Where EmpID=@EmpID) )
		begin
			Insert into [Emp_Photo](EmpID,Photo)
			values(@EmpID,@Photo)
		end
		else
		begin
			UPdate Emp_Photo
			Set Photo=@Photo
			where EmpID=@EmpID
		end
	end
	
	--为@PhotoID赋值
	select @PhotoID=PhotoID From Emp_Photo where EmpID=@EmpID 

	--修改员工家庭联系方式表(Emp_Search)
	if(not exists ( Select 1 From dbo.Emp_Search Where EmpID=@EmpID))
	begin
		Insert into [Emp_Search] (EmpID,EmpTel1,EmpTel2,EmpTel3,EmpQQ,EmpMsn,HomePage,
			EmpEmail,EmpEmailBackup,Remark)
		values (@EmpID,@EmpTel1,@EmpTel2,@EmpTel3,@EmpQQ,@EmpMsn,@HomePage,
			@EmpEmail,@EmpEmailBackup,@EmpSerchRemark)
	end
	else
	begin
		Update Emp_Search
		Set EmpTel1=@EmpTel1,EmpTel2=@EmpTel2,EmpTel3=@EmpTel3,EmpQQ=@EmpQQ,EmpMsn=@EmpMsn,
			HomePage=@HomePage,EmpEmail=@EmpEmail,EmpEmailBackup=@EmpEmailBackup,Remark=@EmpSerchRemark
		where EmpID=@EmpID

	end

	--修改员工详细信息表(Emp_Detail)
	if(not exists( Select 1 From Emp_Detail Where EmpID=@EmpID))
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		insert into Emp_Detail(EmpID,Nation,WedlockID,ClanID,NativePlace,CensusRegister,SchoolRecordID,
			GraduateFrom,Specialty,OfficialDesignation,PhotoID,Idcard,BirthDay,Remark)
		values ( @EmpID,@Nation,@WedlockID,@ClanID,@NativePlace,@CensusRegister,@SchoolRecordID,
			@GraduateFrom,@Specialty,@OfficialDesignation,@PhotoID,@Idcard,@BirthDay,@EmpDetailRemark)
	end
	else
	begin
		if(@BirthDay='1900-1-1 00:00:01')
		begin
			set @BirthDay=null
		end
		
		update Emp_Detail
		Set Nation=@Nation,WedlockID=@WedlockID,ClanID=@ClanID,NativePlace=@NativePlace,CensusRegister=@CensusRegister,
			SchoolRecordID=@SchoolRecordID,GraduateFrom=@GraduateFrom,Specialty=@Specialty,OfficialDesignation=@OfficialDesignation,
			PhotoID=@PhotoID,Idcard=@Idcard,BirthDay=@BirthDay,Remark=@EmpDetailRemark
		where EmpID=@EmpID
	end

	--修改员工健康表(Emp_Health)
	if(not exists ( Select 1 From Emp_Health Where EmpID=@EmpID))
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		insert into Emp_Health(EmpID,Height,Weight,StateOfHealth)
		values (@EmpID,@Height,@Weight,@StateOfHealth)
	end
	else
	begin
		if(@Height=0)
		begin
			set @Height=null
		end

		if(@Weight=0)
		begin
			set @Weight=null
		end

		update Emp_Health
		Set Height=@Height,Weight=@Weight,StateOfHealth=@StateOfHealth
		Where EmpID=@EmpID
	end


	--修改员工家庭表(Emp_Home)
	if( not exists ( Select 1 From Emp_Home Where EmpID=@EmpID))
	begin
		insert into Emp_Home(EmpID,HomeTel1,HomeTel2,HomeAddress,Postalcode,Remark)
		values (@EmpID,@HomeTel1,@HomeTel2,@HomeAddress,@Postalcode,@EmpHomeRemark)
	end
	else
	begin
		Update Emp_Home
		Set HomeTel1=@HomeTel1,HomeTel2=@HomeTel2,HomeAddress=@HomeAddress,Postalcode=@Postalcode,Remark=@EmpHomeRemark
		Where EmpID=@EmpID
	end
	

	--修改员工进公司表(Emp_InCompany)
	if( not exists ( Select 1 From Emp_InCompany where EmpID=@EmpID))
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		insert into Emp_InCompany(EmpID,ProbationDate,OfficiallyDate,ContractExpDate,
			ContractExpAppendDate,IsGearShift,HireTypeID,Archives,DimissionTime,Remark)
		values (@EmpID,@ProbationDate,@OfficiallyDate,@ContractExpDate,@ContractExpAppendDate,
			@IsGearShift,@HireTypeID,@Archives,@DimissionTime,@EmpInCompanyRemark)
	end
	else
	begin
		if(@ProbationDate='1900-1-1 00:00:01')
		begin
			set @ProbationDate=null
		end

		if(@OfficiallyDate='1900-1-1 00:00:01')
		begin
			set @OfficiallyDate=null
		end

		if(@ContractExpDate='1900-1-1 00:00:01')
		begin
			set @ContractExpDate=null
		end

		if(@ContractExpAppendDate='1900-1-1 00:00:01')
		begin
			set @ContractExpAppendDate=null
		end	

		if(@DimissionTime='1900-1-1 00:00:01')
		begin
			set @DimissionTime=null
		end	

		update Emp_InCompany
		Set ProbationDate=@ProbationDate,OfficiallyDate=@OfficiallyDate,ContractExpDate=@ContractExpDate,
			ContractExpAppendDate=@ContractExpAppendDate,IsGearShift=@IsGearShift,HireTypeID=@HireTypeID,
			Archives=@Archives,DimissionTime=@DimissionTime,Remark=@EmpInCompanyRemark
		Where EmpID=@EmpID
	end

	--删除该员工的工种表
	delete From Emp_WorkType Where EmpID=@EmpID

	--插入员工工种表1
	if( @WorkTypeID1 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID1 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID1,@IsMostly1,@IsEnable1)
	
		end
	end

	--插入员工工种表2
	if( @WorkTypeID2 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID2 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID2,@IsMostly2,@IsEnable2)
	
		end
	end

	--插入员工工种表3
	if( @WorkTypeID3 <> 0)
	begin
		if(not exists ( Select 1 From Emp_WorkType Where EmpID=@EmpID and WorkTypeID=@WorkTypeID3 ))
		begin
			insert into Emp_WorkType(EmpID,WorkTypeID,IsMostly,IsEnable)
			Values (@EmpID,@WorkTypeID3,@IsMostly3,@IsEnable3)
	
		end
	end
end

end

end


--判断是否全部执行成功
if @@error=0

begin
	commit transaction EmpInfo_Trans
        
end

else
begin
	
	rollback TRANSACTION EmpInfo_Trans
end




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




create   Proc zjw_GetPagingRecord_HisInWellCounts
(
	@keyField	VarChar(255),		--主键
	@PageIndex	int,			--页号,从0开始
	@PageSize	int = 20,		--页尺寸
	@strTime	varchar(500),		--时间条件     
	@strWhere	VarChar(8000),		--条件
	@orderType	bit = 1			--排序,1,降序,0,升序
)
As
	Declare @strSql VarChar(8000)
	declare @tblName varchar(1000)
	declare @fieldList varchar(100)
	declare @orderField	VarChar(255)

	set @fieldList='*'	
	set @orderField='发码器'

	set @tblName='Select Distinct  Hi.CodeSenderAddress As 发码器,  
		Ei.EmpName As 姓名,  
		Di.DeptName As 部门,  
		Wi.WtName As 工种,  
		(  Select Count(*) From His_InOutMine As Hi Where Hi.UserID = Ei.EmpID And Hi.CsTypeID = 0  ) As 下井次数,  
		dbo.FunConvertTime((  Select Sum(ContinueTime) From His_InOutMine As Hi Where Hi.UserID = Ei.EmpID And Hi.CsTypeID =0  )) As 下井时长  
		,Ed.Idcard,Wi.WorkTypeID,Ci.CerTypeID,Dio.DutyID,Et.EnumID
		From  Emp_Info As Ei  
		Left Join Emp_Detail As Ed On Ed.EmpID = Ei.EmpID 
		 Left Join Emp_NowCompany As En On En.EmpID = Ei.EmpID 
		 Left Join Dept_Info As Di On Di.DeptID = En.DeptID  
		Left Join Emp_WorkType As Ew On Ew.EmpID = Ei.EmpID  and Ew.IsEnable=1
		Left Join WorkType_Info As Wi On Wi.WorkTypeID = Ew.WorkTypeID  
		Left Join Emp_Certificate As Ec On Ec.EmpID = Ei.EmpID  
		Left Join Certificate_Info As Ci On Ci.CerTypeID = Ec.CerTypeID  
		Left Join Duty_Info As Dio On Dio.DutyID = En.DutyID  
		Left Join EnumTable As Et On Et.EnumID = Dio.DutyClassID  and Et.FunID = 4
		Left Join His_InOutMine As Hi On Hi.UserID = Ei.EmpID  
		Where   Hi.CsTypeID = 0  and '+@strTime

	--处理SQL中危险字符,并且将条件处理成易嵌入的形式     
	set @strWhere = replace(@strWhere,'''','''''')     
	set @strWhere = replace(@strWhere,'--','')     
	set @strWhere = replace(@strWhere,';','')     
	set @strSql = 'declare @CurPageNum int;'
	set @strSql = @strSql + 'declare @nextpagenum int;'
	set @strSql = @strSql + 'set @curpagenum = ' + cast(@PageIndex as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'set @nextpagenum = ' + cast(@PageIndex + 1 as varchar) + '*' + cast(@PageSize as varchar) + ';'     
	set @strSql = @strSql + 'declare @strSql varchar(6000);'     
	If @orderType = 1
	Begin
		Set @strSql = @strSql + 'set @strSql=''select '+ @fieldList + 
			' from(select top ''+cast(@nextpagenum as varchar)+'' * from ' + 
			@tblName + ' as C '+ ' where ' + @strWhere + ' order by ' + @orderField + 
			' desc)as a where ' + @keyField + ' not in(select top '' + cast(@curpagenum as varchar) + '' ' + 
			@keyField + ' from ' + @tblName +' as D ' + ' where ' + @strWhere + 'order by ' + 
			@orderField + ' desc)order by ' + @orderField + ' desc'';'   
	End
	Else
	Begin
		Set @strSql = @strSql + 'Set @strSql=''select ' + @fieldList + 
			' from (select top '' + cast(@nextpagenum as varchar) + '' * from ' + @tblName + ' as C '+
			' where ' + @strWhere + ' order by ' + @orderField + ' asc)as a where ' + @keyField + 
			' not in (select top '' + cast(@curpagenum as varchar)+'' ' + @keyField + ' from ' + 
			@tblName + 'as D ' + ' where ' + @strWhere + ' order by ' + @orderField + ' asc)order by ' + @orderField + ' asc'';'
	End
	Set @strSql = @strSql + 'execute(@strSql)'
	Execute(@strSql)

	If (@strWhere = '')
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName +' as E ' + '];''execute(@strSql);'
	Else
		Set @strSQL = 'declare @strSql varchar(6000);set @strSql=''select count(*) as Total from [' + @tblName +' as E ' + ']'+' where ' + @strWhere + ';''execute(@strSql);'
	Exec (@strSQL)








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc zjw_HisInOutMine_Select
(
 @strWhere varchar(1000) 
)
as
declare @strSQL varchar(4000)
set @strSQL='
Select Distinct  Hi.CodeSenderAddress As 发码器,  
Ei.EmpName As 姓名,  
Di.DeptName As 部门,  
Wi.WtName As 工种,  
(  Select Count(*) From His_InOutMine As Hi Where Hi.UserID = Ei.EmpID And Hi.CsTypeID = 0  ) As 下井次数,  
dbo.FunConvertTime((  Select Sum(ContinueTime) From His_InOutMine As Hi Where Hi.UserID = Ei.EmpID And Hi.CsTypeID =0  )) As 下井时长  


From  Emp_Info As Ei  
Left Join Emp_Detail As Ed On Ed.EmpID = Ei.EmpID 
 Left Join Emp_NowCompany As En On En.EmpID = Ei.EmpID 
 Left Join Dept_Info As Di On Di.DeptID = En.DeptID  
Left Join Emp_WorkType As Ew On Ew.EmpID = Ei.EmpID  and Ew.IsEnable=1
Left Join WorkType_Info As Wi On Wi.WorkTypeID = Ew.WorkTypeID  
Left Join Emp_Certificate As Ec On Ec.EmpID = Ei.EmpID  
Left Join Certificate_Info As Ci On Ci.CerTypeID = Ec.CerTypeID  
Left Join Duty_Info As Dio On Dio.DutyID = En.DutyID  
Left Join EnumTable As Et On Et.EnumID = Dio.DutyClassID  
Left Join His_InOutMine As Hi On Hi.UserID = Ei.EmpID  
Where  Et.FunID = 4 And Hi.CsTypeID = 0 '+@strWhere 

Exec (@strSQL)




GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE    proc zjw_OverEmpInWell
as

Declare @OrgCount int		--额定人数
Declare @NewCount int		--当前人数	
declare @TempCount int	--实时超员表的记录数
declare @Temp_RTOverEmpCount int	--实时超员表中的超员人数
declare @RT_OrgCount int	--实时超员表中的额定人数
declare @RT_NewCount int	--实时超员表中的下井人数
declare @Hi_OrgCount int 	--历史超员表中的额定人数
declare @Hi_NewCount int  	--历史超员表中的下井人数
declare @Hi_ID int		--历史超员表中的新一条记录

select @NewCount=count(1) from RT_InOutMine as Ri left join CodeSender_Set as Css on Ri.CodeSenderAddress=Css.CodeSenderAddress
where CsTypeID=0

select @OrgCount=EnumValue From EnumTable Where FunID=8 and EnumID=1

/*
set @OrgCount=100
set @NewCount=1001
*/
print @OrgCount	
print @NewCount

if(@NewCount>@OrgCount)
begin
	print '超员'
		
	select @TempCount=count(1) from RT_OverEmployees


	print @TempCount

	if ( @TempCount>0 )   --存在实时超员记录
	begin
		print '存在超员记录'
		
		Select @RT_OrgCount=RT_RatingEmployeesCount,@RT_NewCount =RT_FactEmployeeCount
		From RT_OverEmployees

			select @Hi_ID=His_OverEmployeeID,@Hi_OrgCount=His_RatingEmployeesCount,@Hi_NewCount=His_FactEmployeeCount
			From His_OverEmployees
			where His_OverEmployeeID in( select Max(His_OverEmployeeID) From His_OverEmployees)
			
		--实时超员表中的额定超员人数和当前额定超员人数不相同,结束当前超员，开始新的超员记录
		if(@OrgCount<>@RT_OrgCount)
		begin
			print '额定人数不相同'

			
			if(@Hi_NewCount>=@NewCount)	--历史下井人数大于当前下井人数
			begin
				update His_OverEmployees
				set His_OverEmployeeEndTime=getdate()
				where His_OverEmployeeID=@Hi_ID
			end
			else					--历史下井人数小于当前下井人数
			begin
				update His_OverEmployees
				set His_OverEmployeeEndTime=getdate(),His_FactEmployeeCount=@NewCount
				where His_OverEmployeeID=@Hi_ID
			end
			
			delete from RT_OverEmployees		--删除实时超员表中的记录
			
			--写入新的实时超员信息
			insert into RT_OverEmployees (RT_OverEmployeeTypeID,RT_RatingEmployeesCount,RT_FactEmployeeCount,RT_OverEmployeeBeginTime)
			values('1',@OrgCount,@NewCount,getDate())
	
			--写入历史超员表
			insert into His_OverEmployees (His_OverEmployeeTypeID,His_RatingEmployeesCount,His_FactEmployeeCount,His_OverEmployeeBeginTime)
			values('1',@OrgCount,@NewCount,getDate())

		end
		--实时超员表中的额定超员人数和当前额定超员人数相同
		else
		begin
			print '额定人数相同'
			print str(@RT_NewCount)
			print (str(@RT_NewCount)+'<'+str(@NewCount))
			print (str(@Hi_NewCount)+'<'+str(@NewCount))

			--更新实时超员表
			update RT_OverEmployees
			set RT_FactEmployeeCount=@NewCount

			--历史超员表的最后一条超员记录的下井人数小于当前下井人数,更新历史超员表的下井人数
			if(@Hi_NewCount < @NewCount)
			begin

				--更新历史超员表
				update His_OverEmployees
				set His_FactEmployeeCount=@NewCount
				where His_OverEmployeeID in ( Select Max(His_OverEmployeeID) From His_OverEmployees )

			end
		end
	end
	else			--不存在实时超员记录
	begin
		--写入实时超员表
		insert into RT_OverEmployees (RT_OverEmployeeTypeID,RT_RatingEmployeesCount,RT_FactEmployeeCount,RT_OverEmployeeBeginTime)
		values('1',@OrgCount,@NewCount,getDate())

		--写入历史超员表
		insert into His_OverEmployees (His_OverEmployeeTypeID,His_RatingEmployeesCount,His_FactEmployeeCount,His_OverEmployeeBeginTime)
		values('1',@OrgCount,@NewCount,getDate())

	end
		
end
else
begin
	print '正常'
end

/*
select * from RT_OverEmployees
select * from His_OverEmployees
*/


/*

delete from RT_OverEmployees
delete From His_OverEmployees

*/


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE  proc zjw_OverEmpOutWell
as

Declare @OrgCount int		--额定人数
Declare @NewCount int		--当前人数	
declare @TempCount int	--实时超员表的记录数
declare @RT_OrgCount int	--实时超员表中的额定人数
declare @RT_NewCount int	--实时超员表中的下井人数




select @NewCount=count(1) from RT_InOutMine as Ri left join CodeSender_Set as Css on Ri.CodeSenderAddress=Css.CodeSenderAddress
where CsTypeID=0

select @OrgCount=EnumValue From EnumTable Where FunID=8 and EnumID=1

select @TempCount=count(1) from RT_OverEmployees


print @TempCount

if(@NewCount>@OrgCount)
begin
	print '超员'
	

	if ( @TempCount>0 )   --存在实时超员记录
	begin
		Select @RT_OrgCount=RT_RatingEmployeesCount,@RT_NewCount =RT_FactEmployeeCount
		From RT_OverEmployees

		--实时超员表的下井人数不等与当前下井人数,更新实时超员表的下井人数
		if(@RT_NewCount<>@NewCount)
		begin
			--更新实时超员表
			update RT_OverEmployees
			set RT_FactEmployeeCount=@NewCount
		end
	end
	
end
else	--正常
begin
	if ( @TempCount>0 )   --存在实时超员记录
	begin
		--删除实时超员表的超员记录
		delete from RT_OverEmployees
	
		--写入历史超员表最后一条记录的超员结束事件
		update His_OverEmployees
		set His_OverEmployeeEndTime=getdate()
		where His_OverEmployeeID in ( Select Max(His_OverEmployeeID) From His_OverEmployees )

	end

end

--select * from His_OverEmployees


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



create   proc zjw_RTPost_Delete
(
	@Cards  varchar(6000),
	@DateTime datetime
)

as
--写入历史岗位记录，并删除实时岗位记录

declare @CRADNO varchar(20)--发码器编号,对应了人的编号
declare @EmpID int
Declare @TerritorialID	int		--区域ID		
declare @WorkTime int			--工作时长
declare @BeginTime datetime		--进入区域时间
declare @FactTime int		--实际工作时长

begin
	--定义游标
	declare processRTPostDelete cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open processRTPostDelete
	--移到下一行
	fetch next from processRTPostDelete into @CRADNO

	while (@@FETCH_STATUS <> -1)
	begin
		if @CRADNO<>''
			begin
				--查找此@CRADNO对应的人的编号

				set @EmpID = (select UserID from CodeSender_Set where CodeSenderAddress=@CRADNO and CsTypeId=0)
				if @EmpID is not null
				begin
					--实时岗位表中存在该员工记录
					if(EXISTS ( select * from RT_PostInfo where EmpID=@EmpID ))
					begin
						set @WorkTime=( Select WorkTime From Emp_Post Where EmpID=@EmpID)

						Select @TerritorialID=TerritorialID,@BeginTime=BeginTime
						From RT_PostInfo
						Where EmpID=@EmpID

						if(@BeginTime is not null )
						begin
							set @FactTime= DATEDIFF ( ss , @BeginTime , @DateTime ) 
							if (@FactTime >= @WorkTime )   	--工作时间满足要求，不报警
							begin
								insert into His_PostInfo(TerritorialID,EmpID,WorkTime,BeginTime,EndTime,FactTime,IsAlarm)
								values(@TerritorialID,@EmpID,@WorkTime,@BeginTime,@DateTime,@FactTime,0)
							end
							else					--工作时间不满足要求，报警
							begin
								insert into His_PostInfo(TerritorialID,EmpID,WorkTime,BeginTime,EndTime,FactTime,IsAlarm)
								values(@TerritorialID,@EmpID,@WorkTime,@BeginTime,@DateTime,@FactTime,1)
							end
						end	
					
					delete from RT_PostInfo where EmpID=@EmpID
	
					end
				end		
			end
		
		fetch next from processRTPostDelete into @CRADNO
		
	end

	--关闭游标
	close processRTPostDelete
	--释放游标
	deallocate processRTPostDelete
end







GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO




create    proc zjw_RTPost_Inset
(
	@Cards  varchar(6000)
)

as
declare @CRADNO varchar(20)--发码器编号,对应了人的编号
declare @EmpID int

begin
	--定义游标
	declare RTPostInsert cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open RTPostInsert
	--移到下一行
	fetch next from RTPostInsert into @CRADNO

	while (@@FETCH_STATUS <> -1)
	begin
		if @CRADNO<>''
			begin
				--查找此@CRADNO对应的人的编号

				set @EmpID = (select UserID from CodeSender_Set where CodeSenderAddress=@CRADNO and CsTypeId=0)
				if @EmpID is not null
				begin
					if(EXISTS ( select * from Emp_Post where EmpID=@EmpID ))
					begin
						
						Declare @TerritorialID	int		--区域ID		
						set @TerritorialID=( Select TerritorialID From Emp_Post Where EmpID=@EmpID )
						

						--实时岗位表中存在该员工记录
						if( exists( Select * From RT_PostInfo where EmpID=@EmpID ))						
						begin
							delete from RT_PostInfo where EmpID=@EmpID
						end
						/*
						else 	--实时岗位表中不存在该员工记录
						begin
							--向实时岗位表中，插入该员工的信息，并标志未到达
							insert into RT_PostInfo(TerritorialID,EmpID,IsArrive)
							values(@TerritorialID,@EmpID,0)
						end
						*/
						--向实时岗位表中，插入该员工的信息，并标志未到达
						insert into RT_PostInfo(TerritorialID,EmpID,IsArrive)
						values(@TerritorialID,@EmpID,0)
						
					end
				end		
			end
		
		fetch next from RTPostInsert into @CRADNO
		
	end

	--关闭游标
	close RTPostInsert
	--释放游标
	deallocate RTPostInsert
end








GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO





create     proc zjw_RTPost_UpDate
(
	@DetectTime datetime,			-- 检测时间
	@StationAddress int,			-- 基站号
	@StationHeadAddress int,		-- 探头号
	@Cards varchar(6000)
)
as

--修改实时岗位表
begin
	declare @CRADNO varchar(20)--发码器编号,对应了人的编号
	declare @EmpID int
	declare @TerID int	--指定区域ID
	declare @BeginTime datetime	--到达时间
	declare @FactTime int 		--实时工作时长
	declare @WorkTime int		--额定工作时长
	declare @EmpName nvarchar(20)	--员工姓名
	declare @DeptName nvarchar(20)	--部门名称 
	declare @WorkName nvarchar(20)	--工种名称
	declare @DutyName nvarchar(20)	--职务名称
	declare @CodeSenderAddress int 	--发码器编号

	--定义游标
	declare RTPostUpdate cursor for (select F1 from dbo.f_splitstr(@Cards,','))
	--打开游标
	open RTPostUpdate
	--移到下一行
	fetch next from RTPostUpdate into @CRADNO
	
	while (@@FETCH_STATUS <> -1)
	begin
		if @CRADNO<>''
		begin
			--查找此@CRADNO对应的人的编号
			set @EmpID = (select UserID from CodeSender_Set where CodeSenderAddress=@CRADNO and CsTypeId=0)
			if @EmpID is not null
			begin
				if(EXISTS ( select * from RT_PostInfo where EmpID=@EmpID ))
				begin

					--获取该该员工所配置的区域ID
					set @TerID=( Select TerritorialID From RT_PostInfo Where EmpID=@EmpID)		
					set @BeginTime=( Select BeginTime From RT_PostInfo Where EmpID=@EmpID )
					set @WorkTime =( Select WorkTime From Emp_Post Where EmpID=@EmpID )

					if( @BeginTime is null )
					begin
						--员工配置区域与该区域相符
						if( exists ( select * from Territorial_Set as Ts left join Station_Head_Info as Shi on Ts.StationHeadID =Shi.StationHeadID where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and IsTerriorialEnter=0 and TerritorialID=@TerID ))
						begin
							update RT_PostInfo 
							set BeginTime=@DetectTime,IsArrive=1
							where EmpID=@EmpID
						end		
					end								
					else
					begin
						--员工配置区域与该区域不相符,该员工已经出区域
						if( not exists ( select * from Territorial_Set as Ts left join Station_Head_Info as Shi on Ts.StationHeadID =Shi.StationHeadID where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and IsTerriorialEnter=0 and TerritorialID=@TerID ))
						begin
			
							Select @EmpName=Ei.EmpName,@DeptName=Dei.DeptName,@WorkName=WtName,@DutyName=Dui.DutyName,@CodeSenderAddress=CodeSenderAddress
							From Emp_Info as Ei left join Emp_NowCompany as Enc on Ei.EmpID=Enc.EmpID
								left join Dept_Info as Dei on Enc.DeptID=Dei.DeptID
								left join Duty_Info as Dui on Enc.DutyID=Dui.DutyID
								left join Emp_WorkType as Ewt on Ei.EmpID=Ewt.EmpID
								left join WorkType_Info as Wti on Ewt.WorkTypeID=Wti.WorkTypeID and Ewt.IsEnable=1
								left join CodeSender_Set as Css on Ei.EmpID=Css.UserID and Css.CsTypeID=0
							where Ei.EmpID=@EmpID and Ewt.IsEnable=1 and Css.CsTypeID=0
			
							--删除实时记录，写入历史记录
							 							

							set @FactTime= DATEDIFF ( ss , @BeginTime , @DetectTime ) 
							if (@FactTime >= @WorkTime )   	--工作时间满足要求，不报警
							begin
								insert into His_PostInfo(TerritorialID,EmpID,WorkTime,BeginTime,EndTime,FactTime,IsAlarm,EmpName,DeptName,WorkName,DutyName,CodeSenderAddress)
								values(@TerID,@EmpID,@WorkTime,@BeginTime,@DetectTime,@FactTime,0,@EmpName,@DeptName,@WorkName,@DutyName,@CodeSenderAddress)
							end
							else					--工作时间不满足要求，报警
							begin
								insert into His_PostInfo(TerritorialID,EmpID,WorkTime,BeginTime,EndTime,FactTime,IsAlarm,EmpName,DeptName,WorkName,DutyName,CodeSenderAddress)
								values(@TerID,@EmpID,@WorkTime,@BeginTime,@DetectTime,@FactTime,1,@EmpName,@DeptName,@WorkName,@DutyName,@CodeSenderAddress)
							end

							delete from RT_PostInfo where EmpID=@EmpID
						end
					end
				end	
				else
				begin
					if(exists ( Select * From Emp_Post Where EmpID=@EmpID))
					begin
						set @TerID=( Select TerritorialID From Emp_Post Where EmpID=@EmpID )

						--员工配置区域与该区域相符
						if( exists ( select * from Territorial_Set as Ts left join Station_Head_Info as Shi on Ts.StationHeadID =Shi.StationHeadID where StationAddress=@StationAddress and StationHeadAddress=@StationHeadAddress and IsTerriorialEnter=0 and TerritorialID=@TerID ))
						begin
							insert into RT_PostInfo (TerritorialID,EmpID,BeginTime,IsArrive)
							values(@TerID,@EmpID,@DetectTime,1)
						end						
						
			
		
					end
				end	
			end
		end
		fetch next from RTPostUpdate into @CRADNO
	end
	
	--关闭游标
	close RTPostUpdate
	--释放游标
	deallocate RTPostUpdate
end










GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO


CREATE proc zjw_SavePrint
(
  @str1 nvarchar(20),
  @str2 nvarchar(20),
  @str3 nvarchar(20),
  @str4 nvarchar(20),
  @str5 nvarchar(20),
  @str6 nvarchar(20),
  @str7 nvarchar(20),
  @strTime nvarchar(20)
)
as
begin
	--下井人员总数及人员
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=1))
	begin
		update EnumTable 
		set EnumValue=@str1
		where FunID=15 and EnumID=1
	end
	else
	begin   
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,1,@str1,'下井人员总数及人员',0,'定时打印项目')
	end
	--重点区域人数及总数
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=2))
	begin
		update EnumTable 
		set EnumValue=@str2
		where FunID=15 and EnumID=2
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,2,@str2,'重点区域人数及总数',0,'定时打印项目')
	end
	--超时报警人员总数及人员
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=3))
	begin
		update EnumTable 
		set EnumValue=@str3
		where FunID=15 and EnumID=3
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,3,@str3,'超时报警人员总数及人员',0,'定时打印项目')
	end
	--超员报警人员总数及人员
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=4))
	begin
		update EnumTable 
		set EnumValue=@str4
		where FunID=15 and EnumID=4
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,4,@str4,'超员报警人员总数及人员',0,'定时打印项目')
	end
	--限制区域报警人员总数及人员
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=5))
	begin
		update EnumTable 
		set EnumValue=@str5
		where FunID=15 and EnumID=5
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,5,@str5,'限制区域报警人员总数及人员',0,'定时打印项目')
	end
	--特种作业人员工作异常报警总数及人员
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=6))
	begin
		update EnumTable 
		set EnumValue=@str6
		where FunID=15 and EnumID=6
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,6,@str6,'特种作业人员工作异常报警总数及人员',0,'定时打印项目')
	end
	--领导干部每月下井总数及时间统计
	if(EXISTS (Select * from dbo.EnumTable where FunID=15 and EnumID=7))
	begin
		update EnumTable 
		set EnumValue=@str7
		where FunID=15 and EnumID=7
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (15,7,@str7,'领导干部每月下井总数及时间统计',0,'定时打印项目')
	end
	--定时打印时间
	if(EXISTS (Select * from dbo.EnumTable where FunID=16 and EnumID=1))
	begin
		update EnumTable 
		set EnumValue=@strTime
		where FunID=16 and EnumID=1
	end
	else
	begin
		Insert into EnumTable
 		    (FunID,EnumID,EnumValue,Title,IsBase,Remark)
		values
		    (16,1,@strTime,'定时打印时间',0,'定时打印时间')
	end
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
	查询实时求救信息
*/
create proc zjw_Select_RT_EmpHelp
(
	@where varchar(2000)			--查询条件
)
as
declare @strSql varchar(6000) 

set @strSql=' Select * From zjw_RT_EmpHelp_View Where '+@where

exec (@strSql)






GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

create proc [zjw_Select_Station]
	@sign int 
AS
if(@sign=0)
begin
	 select * From Station_Info
end
else if(@sign=1)
begin
	select StationID as ID,StationAddress as [Address],StationGroup,1 as ipAddress,1 as ipPort,StationModel,
		Ver=case WHEN StationVersion IS NULL THEN  1 else StationVersion end
	from Station_Info
end
else if(@sign=2)
begin
	select s.StationID as ID,s.StationAddress as [Address],s.StationGroup,t.ipAddress,t.ipPort,StationModel,
		Ver=case WHEN StationVersion IS NULL THEN  1 else StationVersion end
	from Station_Info s join TcpIpConfig t on s.ipAddressID=t.ipid
end

GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO



/*
	增加工种信息
	赵建伟
	2008-06-23 11：02

*/
CREATE proc zjw_WorkType_Insert
(
	@WtName nvarchar(50),
	@CerTypeID int,
	@Remark nvarchar(50),
	@MaxTimeSec int,
	@MinTimeSec int,
	@ID int
)
as
begin

declare	@WorkTypeID int

if( not exists( Select 1 From dbo.WorkType_Info Where WtName=@WtName))
begin
	insert into WorkType_Info(WorkTypeID,WtName,CerTypeID,Remark) values(@ID,@WtName,@CerTypeID,@Remark)
	
	select @WorkTypeID=WorkTypeID From WorkType_Info where WtName=@WtName 
	
	if(not exists (Select 1 From dbo.WorkType_SysSet Where WorkTypeID=@WorkTypeID))
	begin
		insert into WorkType_SysSet(WorkTypeSysSetID,WorkTypeID,MaxTimeSec,MinTimeSec) 
		values(@WorkTypeID,@WorkTypeID,@MaxTimeSec,@MinTimeSec) 	
	end
end 

end



GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

SET QUOTED_IDENTIFIER ON 
GO
SET ANSI_NULLS ON 
GO

/*
	修改工种信息
	赵建伟
	2008-06-23 13:25
*/

CREATE proc zjw_WorkType_Update
(
	@WtName nvarchar(50),
	@CerTypeID int,
	@Remark nvarchar(50),
	@MaxTimeSec int,
	@MinTimeSec int
)
as
begin

declare	@WorkTypeID int

if( exists( Select 1 From dbo.WorkType_Info Where WtName=@WtName))
begin
	update WorkType_Info Set CerTypeID=@CerTypeID,Remark=@Remark
	where WtName=@WtName

	select @WorkTypeID=WorkTypeID From WorkType_Info where WtName=@WtName 

	if(exists (Select 1 From dbo.WorkType_SysSet Where WorkTypeID=@WorkTypeID))
	begin
		update WorkType_SysSet Set MaxTimeSec=@MaxTimeSec,MinTimeSec=@MinTimeSec
		where WorkTypeID=@WorkTypeID
	end
end 
end 


GO
SET QUOTED_IDENTIFIER OFF 
GO
SET ANSI_NULLS ON 
GO

